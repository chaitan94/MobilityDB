
		<sect1>
			<title>Bounding Box Operators</title>
			<para>These operators test whether the bounding boxes of their arguments satisfy the predicate and result in a Boolean value. As stated in Section <xref linkend="temporal_types" />, the bounding box associated to a temporal type depends on the base type: It is the <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types, the <varname>box</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types, and the <varname>gbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types.</para>

			<para>A first set of operators consider the relative position of the bounding boxes. The operators <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname> consider the value dimension for <varname>tint</varname> and <varname>tfloat</varname> types and the X coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, and <varname>|&amp;&gt;</varname> consider the Y coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, and <varname>/&amp;&gt;</varname> consider the Z coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, and the operators <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname>, and <varname>#&amp;&gt;</varname> consider the time dimension for all temporal types. The operators for the value dimension of the <varname>tint</varname> and <varname>tfloat</varname> types are given next.</para>

			<itemizedlist>
				<listitem>
					<para>Bounding box operators</para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&lt; tint '[2@2012-01-03, 2@2012-01-05)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&gt;&gt;</varname>: Is the bounding box always strictly greater than?</para>
					<para>Signature: <varname>{base, numrange, ttype} &gt;&gt; {base, numrange, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[4@2012-01-01, 4@2012-01-04)' &gt;&gt; intrange '[1,4)';
-- true
SELECT tint '[4@2012-01-01, 4@2012-01-04)' &gt;&gt; tfloat '[4@2012-01-01, 5@2012-01-04)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;</varname>: Is the bounding box never greater than?</para>
					<para>Signature: <varname>{base, numrange, ttype} &amp;&lt; {base, numrange, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &amp;&lt; tfloat '{2@2012-01-03, 3@2012-01-05}';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&amp;&gt;</varname>: Is the bounding box never less than?</para>
					<para>Signature: <varname>{base, numrange, ttype} &amp;&gt; {base, numrange, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &amp;&gt;25014>
tfloat '{[2@2012-01-02, 3@2012-01-04), [3@2012-01-04, 2@2012-01-06)}';
-- false
					</programlisting>
				</listitem>
			</itemizedlist>
			<para>The operators for the value dimension of the temporal point types are given next.</para>

			<itemizedlist>
				<listitem>
					<para><varname>&lt;&lt;</varname>: Is the bouding box strictly to the left of?</para>
					<para>Signature: <varname>{geo, tgeompoint} &lt;&lt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &lt;&lt;25017>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&gt;&gt;</varname>: Is the bouding box strictly to the right of?</para>
					<para>Signature: <varname>{geo, tgeompoint} &gt;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &gt;&gt;25020>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;</varname>: The bouding box does not extend to the right of?</para>
					<para>Signature: <varname>{geo, tgeompoint} &amp;&lt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &amp;&lt;25023>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&amp;&gt;</varname>: The bouding box does not extend to the left of?</para>
					<para>Signature: <varname>{geo, tgeompoint} &amp;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &amp;&gt;25026>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;|</varname>: Is the bouding box strictly below?</para>
					<para>Signature: <varname>{geo, tgeompoint} &lt;&lt;| {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &lt;&lt;|25029>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>|&gt;&gt;</varname>: Is the bouding box strictly above?</para>
					<para>Signature: <varname>{geo, tgeompoint} |&gt;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' |&gt;&gt;25032>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;|</varname>: The bouding box does not extend above?</para>
					<para>Signature: <varname>{geo, tgeompoint} &amp;&lt;| {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &amp;&lt;|25035>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>|&amp;&gt;</varname>: The bouding box does not extend below?</para>
					<para>Signature: <varname>{geo, tgeompoint} |&amp;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' |&amp;&gt;25038>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;/</varname>: Is the bouding box strictly in front?</para>
					<para>Signature: <varname>{geo, tgeompoint} &lt;&lt;/ {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0 0)@2001-01-01' &lt;&lt;/25041>
tgeompoint '[Point(1 1 1)@2001-01-01, Point(1 2 2)@2001-01-02)';
-- true
SELECT tgeompoint 'Point(0 0)@2001-01-01' &lt;&lt;/25044>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- NULL
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>/&gt;&gt;</varname>: Is the bouding box strictly back?</para>
					<para>Signature: <varname>{geo, tgeompoint} /&gt;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0 0)@2001-01-01' /&gt;&gt;25047>
tgeompoint '[Point(1 1 1)@2001-01-01, Point(1 2 2)@2001-01-02)';
-- false
SELECT tgeompoint 'Point(0 0)@2001-01-01' /&gt;&gt;25050>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- NULL
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;/</varname>: The bouding box does not extend in front?</para>
					<para>Signature: <varname>{geo, tgeompoint} &amp;&lt;/ {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0 0)@2001-01-01' &amp;&lt;/25053>
tgeompoint '[Point(1 1 1)@2001-01-01, Point(1 2 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>/&amp;&gt;</varname>: The bouding box does not extend back?</para>
					<para>Signature: <varname>{geo, tgeompoint} /&amp;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0 0)@2001-01-01' /&amp;&gt;25056>
tgeompoint '[Point(1 1 1)@2001-01-01, Point(1 2 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The operators for the temporal dimension of all the temporal types are as follows.</para>
			<itemizedlist>
				<listitem>
					<para><varname>&lt;&lt;#</varname>: Is the bounding box always before?</para>
					<para>Signature: <varname>{time, ttype} &lt;&lt;# {time, ttype}: boolean</varname></para>
					<programlisting>
SELECT tbool '[t@2012-01-01, t@2012-01-04)' &lt;&lt;# timestamptz '2012-01-03';
-- false
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&lt;# tint '[2@2012-01-03, 2@2012-01-05)';
-- false
SELECT tgeompoint 'Point(0 0)@2001-01-01' &lt;&lt;#25065>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>#&gt;&gt;</varname>: Is the bounding box always after?</para>
					<para>Signature: <varname>{time, ttype} #&gt;&gt; {time, ttype}: boolean</varname></para>
					<programlisting>
SELECT tbool '[t@2012-01-03, t@2012-01-04)' #&gt;&gt; period '[2012-01-01, 2012-01-02)';
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' #&gt;&gt; tfloat '[2@2012-01-03, 2@2012-01-05)';
-- false
SELECT tgeompoint 'Point(0 0)@2001-01-01' #&gt;&gt;25074>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;#</varname>: Is the bounding box never after?</para>
					<para>Signature: <varname>{time, ttype} &amp;&lt;# {time, ttype}: boolean</varname></para>
					<programlisting>
SELECT tbool '[t@2012-01-01, t@2012-01-04)' &amp;&lt;# tbool '[f@2012-01-03, f@2012-01-05)';
-- true
SELECT tfloat '[1@2012-01-01, 1@2012-01-04)' &amp;&lt;# tfloat '[2@2012-01-03, 2@2012-01-05)';
-- true
SELECT tgeompoint 'Point(0 0)@2001-01-01' &amp;&lt;#25083>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>#&amp;&gt;</varname>: Is the bounding box never before?</para>
					<para>Signature: <varname>{time, ttype} #&amp;&gt; {time, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' #&amp;&gt; tfloat '{2@2012-01-03, 3@2012-01-05}';
-- false
SELECT tgeompoint 'Point(0 0)@2001-01-01' #&amp;&gt;25089>
tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>Another set of operators consider the topological relationships between the bounding boxes. There are four topological operators: overlaps (<varname>&amp;&amp;</varname>), contains (<varname>@&gt;</varname>), contained (<varname>&lt;@</varname>), and same (<varname>~=</varname>). The arguments of these operators can be a base type, a box, or a temporal type and the operators verify the topological relationship taking into account the value and/or the time dimension depending on the type of the arguments.</para>

			<para>The topological operators for temporal alphanumeric types are given next.</para>

			<itemizedlist>
				<listitem>
					<para><varname>&amp;&amp;</varname>: Does the bounding boxes overlap?</para>
					<para>Signature: <varname>{base, numrange, time, box, ttype} &amp;&amp;</varname></para>
					<para><varname>    {base, numrange, time, box, ttype}: boolean</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' &amp;&amp; 3;
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &amp;&amp; floatrange '[1,4)';
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &amp;&amp; tint '[2@2012-01-03, 2@2012-01-05)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>@&gt;</varname>: Does the first bounding box contains the second one?</para>
					<para>Signature: <varname>{base, numrange, time, box, ttype} @&gt;</varname></para>
					<para><varname>    {base, numrange, time, box, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' @&gt; timestamptz '2012-01-03';
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' @&gt; period '[2012-01-03, 2012-01-05)';
-- false
SELECT ttext '[A@2012-01-01, B@2012-01-06]' @&gt; ttext '[C@2012-01-03, D@2012-01-05]';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&lt;@</varname>: Is the first bounding box contained in the second one?</para>
					<para>Signature: <varname>{base, numrange, time, box, ttype} &lt;@</varname></para>
					<para><varname>    {base, numrange, time, box, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;@25108>
box(floatrange '[1,4)', period '[2012-01-01, 2012-01-05)');
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;@ tint '[2@2012-01-03, 2@2012-01-05)';
-- false
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;@ tfloat '{2@2012-01-03, 3@2012-01-05}';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>~=</varname>: Are the bounding boxes equal?</para>
					<para>Signature: <varname>{base, numrange, time, box, ttype} ~=</varname></para>
					<para><varname>    {base, numrange, time, box, ttype}: boolean</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' ~=25117>  tint '{4@2012-01-01, 3@2012-01-03, 1@2012-01-04}';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The topological operators for temporal point types are given next.</para>

			<itemizedlist>
				<listitem>
					<para><varname>&amp;&amp;</varname>: Does the bounding boxes overlap?</para>
					<para>Signature: <varname>{geo, time, gbox, tpoint} &amp;&amp; {geo, time, gbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(2 2)@2012-01-04)' &amp;&amp;25120>
tgeompoint '[Point(0 1)@2012-01-03, Point(2 0)@2012-01-05)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>@&gt;</varname>: Does the first bounding box contains the second one?</para>
					<para>Signature: <varname>{geo, time, gbox, tpoint} @&gt; {geo, time, gbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' &amp;&amp;25123>
tgeompoint '[Point(1 1)@2012-01-03, Point(2 0)@2012-01-05)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&lt;@</varname>: Is the first bounding box contained in the second one?</para>
					<para>Signature: <varname>{geo, time, gbox, tpoint} &lt;@ {geo, time, gbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(1 1)@2012-01-01' &lt;@25126>
tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>~=</varname>: Are the bounding boxes equal?</para>
					<para>Signature: <varname>{geo, time, gbox, tpoint} ~= {geo, time, gbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' ~=25129>
tgeompoint '[Point(0 2)@2012-01-01, Point(2 0)@2012-01-04)';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Distance Operators</title>
			<para>There are two distance operators. The first one computes the distance between either a temporal point and a geometry or between two temporal points at their nearest point of approach, which is a float. This is the same as the function <varname>nearestApproachDistance</varname> discussed before but as an operator it can be used for doing nearest neightbor searches using a GiST index (see Section <xref linkend="indexing_temporal_types" />).</para>

			<para>On the other hand, the temporal distance operator computes the distance at each instant of the intersection of the temporal extents of their arguments and results in a temporal float. Computing temporal distance is useful in many mobility applications. For example, a moving cluster (also known as convoy or flock) is defined as a set of objects that move close to each other for a long time interval. This requires to compute temporal distance between two moving objects.</para>
		
			<para>The temporal distance operator accepts a geometry/geography restricted to a point or a temporal point as arguments. Notice that the temporal types only consider linear interpolation between values, while the distance is a root of a quadratic function. Therefore, the temporal distance operator gives a linear approximation of the actual distance value for temporal sequence points. In this case, the arguments are synchronized in the temporal dimension, and for each of the composing line segments of the arguments, the spatial distance between the start point, the end point, and the nearest point of approach is computed, as shown in the examples below.</para>

			<itemizedlist>
				<listitem>
					<para><varname>|=|</varname>: Smallest distance ever between the two arguments</para>
					<para>Signature: <varname>{geometry, tgeompoint} |=| {geometry, tgeompoint}: float</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-02, Point(1 1)@2012-01-04, Point(0 0)@2012-01-06)' |=|26002>
geometry 'Linestring(2 2,2 1,3 1)';
-- "1"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03, Point(0 0)@2012-01-05)' |=|26006>
tgeompoint '[Point(2 0)@2012-01-02, Point(1 1)@2012-01-04, Point(2 2)@2012-01-06)';
-- "0.5"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&lt;-&gt;</varname>: Distance &Z_support; &geography_support;</para>
					<para>Signature: <varname>{point, tpoint} &lt;-&gt; {point, tpoint}: tfloat</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt; geometry 'Point(0 1)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;
tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 1)@2012-01-01, Point(0 0)@2012-01-03)' &lt;-&gt;
tgeompoint '[Point(0 0)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)' &lt;-&gt;26020>
tgeompoint '[Point(0 1)@2012-01-01, Point(1 2)@2012-01-02)';
-- "[1@2012-01-01,1@2012-01-02)"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="spatial_relationships_temporal_points">
			<title>Spatial Relationships for Temporal Points</title>

			<para>There are two versions of the spatial relationship functions such as <varname>ST_Intersects</varname> and <varname>ST_Relate</varname> generalized to the temporal point types.</para>

			<itemizedlist>
				<listitem>
					<para>The first version applies the traditional spatial function to the union of all values taken by the temporal point (which is a <varname>geometry</varname> or <varname>geography</varname>) and returns a <varname>boolean</varname> or a <varname>text</varname>. Examples are the <varname>intersects</varname> and <varname>relate</varname> functions.</para>
				</listitem>

				<listitem>
					<para>The second version is defined with the temporal semantics, that is, the traditional spatial function is computed at each instant and results in a <varname>tbool</varname> or a <varname>ttext</varname>. Examples are the <varname>tintersects</varname> and <varname>trelate</varname> functions.</para>
				</listitem>
			</itemizedlist>
			<para>Notice that semantics conveyed by the first version of the relationships varies depending on the relationship and the type of the arguments. For example, the following query
				<programlisting>
SELECT intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',27002>
tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
			tests whether the temporal point ever intersected the geometry, since the query is conceptually equivalent to the following one.
				<programlisting>
SELECT ST_Intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', geometry 'Linestring(0 1,1 1)');
				</programlisting>
			where the second geometry is obtained by applying the <varname>trajectory</varname> function to the temporal point. On the other hand, the query
				<programlisting>
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',27005>
tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
				tests whether the geometry always contains the temporal point. Finally, the following query
				<programlisting>
SELECT intersects(tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)',27007>
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
				tests whether the temporal points may intersect, since the query above is conceptually equivalent to the following one 
				<programlisting>
SELECT ST_Intersects('Linestring(0 1,1 0)', 'Linestring(0 0,1 1)');
				</programlisting>
			</para>
						
			<para>The first versions of the relationships are typically used in combination with a spatio-temporal index when computing the temporal relationships. For example, the following query
				<programlisting>
SELECT T.TripId, R.RegionId, tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
WHERE intersects(T.Trip, R.Geom)
				</programlisting>
			which verifies whether a trip <varname>T</varname> (which is a temporal point) intersects a region <varname>R</varname> (which is a geometry), will benefit rom a spatio-temporal index on the column <varname>T.Trip</varname> since the <varname>intersects</varname> function will automatically perform the bounding box comparison <varname>T.Trip &amp;&amp; R.Geom</varname>. This is further explained later in this document.
			</para>
			
			<para>Three spatial relationships available in PostGIS are not provided in the temporal version.
				<itemizedlist>
					<listitem>
						<para><varname>tcontainsproperly</varname> since it would always be equal to <varname>tcontains</varname>: <varname>ST_Contains</varname> returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A. <varname>ST_ContainsProperly</varname> returns true if B intersects the interior of A but not the boundary (or exterior).</para>
					</listitem>

					<listitem>
						<para><varname>tcrosses</varname> since it would always returns false: <varname>ST_Crosses</varname> returns true if the supplied geometries have some, but not all, interior points in common.</para>
					</listitem>

					<listitem>
						<para><varname>toverlaps</varname> since it would always returns false: <varname>ST_Overlaps</varname> returns true if the geometries share space, are of the same dimension, but are not completely contained by each other.</para>
					</listitem>
				</itemizedlist>
				</para>
			
			<para>All spatial relationships in the two versions are defined for temporal geometry points, while only four of them are defined for temporal geography points, namely, <varname>covers</varname>, <varname>coveredby</varname>, <varname>intersects</varname>, and <varname>dwithin</varname>, and the corresponding temporal versions. The arguments of these functions are either a temporal point or a base type (that is, a geometry or a geography), but these functions do not allow a base type in both arguments. Furthermore, both arguments must be of the same base type, that is, these functions do not allow to have a temporal geometry point (or a geometry) and a temporal geography point (or a geography) as arguments.</para>
		
			<para>The <varname>relate</varname> and the <varname>trelate</varname> functions have two forms with either two or three arguments. The two-argument forms consider the spatial relationship between the interior, the boundary, and the exterior of the arguments and return a <varname>text</varname> or a <varname>ttext</varname> value representing the maximum intersection matrix pattern. This pattern is defined using the Dimensionally Extended 9 Intersection Model or DE-9IM (see the PostGIS documentation for more details). The three-argument forms determine whether the first two arguments satisfy the intersection matrix pattern given as third argument (a <varname>text</varname> value) and return a Boolean or a temporal Boolean.</para>

			<sect2>
				<title>Possible Spatial Relationships</title>
				<itemizedlist>
					<listitem>
						<para><varname>contains</varname>: May contain</para>
						<para>Signature: <varname>contains({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
	SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',28002>
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
	-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>containsproperly</varname>: May contain properly</para>
						<para>Signature: <varname>containsproperly({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
	SELECT containsproperly(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',28005>
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
	-- false
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>covers</varname>: May cover</para>
						<para>Signature: <varname>covers({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
	SELECT covers(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',28008>
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
	-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>coveredby</varname>: May be covered by</para>
						<para>Signature: <varname>coveredby({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
	SELECT coveredby(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',28011>
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
	-- false
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>crosses</varname>: May cross</para>
						<para>Signature: <varname>crosses({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
	SELECT crosses(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',28014>
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
	-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>disjoint</varname>: May be disjoint</para>
						<para>Signature: <varname>disjoint({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
	SELECT disjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',28017>
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
	-- false
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>equals</varname>: May be equal</para>
						<para>Signature: <varname>equals({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
	SELECT equals(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',28020>
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
	-- false
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>intersects</varname>: May intersect &Z_support;</para>
					<para>Signature: <varname>intersects({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
	SELECT intersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',28023>tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
	-- false
	SELECT intersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',28027>tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
	-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>overlaps</varname>: May overlap</para>
						<para>Signature: <varname>overlaps({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
	SELECT overlaps(geometry 'Linestring(1 1,3 3)',28030>
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
	-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>touches</varname>: May touch</para>
						<para>Signature: <varname>touches({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
	SELECT touches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',28033>
	tgeompoint '[Point(0 0)@2012-01-01, Point(0 1)@2012-01-03)');
	-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>within</varname>: May be within</para>
						<para>Signature: <varname>within({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
	SELECT within(geometry 'LineString(1 1,2 2)',28036>
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-03)');
	-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>dwithin</varname>: May be at distance within &Z_support;</para>
					<para>Signature: <varname>dwithin({geo, tpoint}, {geo, tpoint}, double): boolean</varname></para>
						<programlisting>
	SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
	tgeompoint 'Point(0 2 1)@2000-01-01,Point(2 2 1)@2000-01-02', 1)
	-- true
	SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
	tgeompoint 'Point(0 2 2)@2000-01-01,Point(2 2 2)@2000-01-02', 1)
	--false
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>relate</varname>: May relate</para>
						<para>Signature: <varname>relate({geo, tgeompoint}, {geo, tgeompoint}): text</varname></para>
						<programlisting>
	SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
	-- "1F2F01FF2"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>relate</varname>: May relate</para>
						<para>Signature: <varname>relate({geo, tgeompoint}, {geo, tgeompoint}, text): boolean</varname></para>
						<programlisting>
	SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)','1F2F01FF2');
	-- true
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>       

			<sect2>
				<title>Temporal Spatial Relationships</title>
				<itemizedlist>
					<listitem>
						<para><varname>tcontains</varname>: Temporal contains</para>
						<para>Signature: <varname>tcontains({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
	SELECT tcontains(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
	-- "{[f@2012-01-01,f@2012-01-02], (t@2012-01-02,t@2012-01-03), [f@2012-01-03,f@2012-01-04)}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>tcovers</varname>: Temporal covers</para>
						<para>Signature: <varname>tcovers({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
	SELECT tcovers(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
	-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>tcoveredby</varname>: Temporal covered by</para>
						<para>Signature: <varname>tcoveredby({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
	SELECT tcoveredby(tgeompoint '[Point(1 1)@2012-01-02, Point(3 3)@2012-01-04)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
	-- "{[t@2012-01-02, t@2012-01-03)}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>tdisjoint</varname>: Temporal disjoint</para>
						<para>Signature: <varname>tdisjoint({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
	SELECT tdisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
	-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-03], (t@2012-01-03, t@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>tequals</varname>: Temporal equals</para>
						<para>Signature: <varname>tequals({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
	SELECT tequals(geometry 'Point(1 1)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
	-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>tintersects</varname>: Temporal intersects &Z_support;</para>
					<para>Signature: <varname>tintersects({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
	SELECT tintersects(geometry 'MultiPoint(1 1,2 2)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
	-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, t@2012-01-03],
	--  (f@2012-01-03, f@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>ttouches</varname>: Temporal touches</para>
						<para>Signature: <varname>ttouches({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
	SELECT ttouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
	-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>twithin</varname>: Temporal within</para>
						<para>Signature: <varname>twithin({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
	SELECT twithin(geometry 'Point(1 1)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
	-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03]}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>tdwithin</varname>: Temporal distance within</para>
						<para>Signature: <varname>tdwithin({geo, tpoint}, {geo, tpoint}, double): tbool</varname></para>
						<programlisting>
	SELECT tdwithin(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 1);
	-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>trelate</varname>: Temporal relate</para>
						<para>Signature: <varname>trelate({geo, tgeompoint}, {geo, tgeompoint}): ttext</varname></para>
						<programlisting>
	SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
	-- "{[FF2FF10F2@2012-01-01, FF20F1FF2@2012-01-02, FF20F1FF2@2012-01-03],
	--  (FF2FF10F2@2012-01-03, FF2FF10F2@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>trelate</varname>: Temporal relate</para>
						<para>Signature: <varname>trelate({geo, tgeompoint}, {geo, tgeompoint}, text): tbool</varname></para>
						<programlisting>
	SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 'FF20F1FF2');
	-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
	2012-01-04)}"
						</programlisting>
					</listitem>
				</itemizedlist>
				</sect2>
		</sect1>

		<sect1>
			<title>Aggregate Functions for Temporal Network Points</title>
			<para></para>
		
			<itemizedlist>
				<listitem>
					<para><varname>tcount</varname>: Temporal count</para>
					<programlisting>
WITH Temp(temp) AS (
	SELECT tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)' UNION
	SELECT tnpoint '[NPoint(1, 0.2)@2012-01-02, NPoint(1, 0.4)@2012-01-04)' UNION
	SELECT tnpoint '[NPoint(1, 0.3)@2012-01-03, NPoint(1, 0.5)@2012-01-05)' )
SELECT tcount(Temp)
FROM Temp
-- "{[1@2012-01-01, 2@2012-01-02, 1@2012-01-04, 1@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>wcount</varname>: Window count</para>
					<programlisting>

WITH Temp(temp) AS (
	SELECT tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)' UNION
	SELECT tnpoint '[NPoint(1, 0.2)@2012-01-02, NPoint(1, 0.4)@2012-01-04)' UNION
	SELECT tnpoint '[NPoint(1, 0.3)@2012-01-03, NPoint(1, 0.5)@2012-01-05)' )
SELECT wcount(Temp, '1 day')
FROM Temp
-- "{[1@2012-01-01, 2@2012-01-02, 3@2012-01-03, 2@2012-01-04, 1@2012-01-05, 1@2012-01-06)}"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>tcentroid</varname>: Temporal centroid</para>
					<para>Signature: <varname>tcentroid(tgeompoint): tgeompoint</varname></para>
					<programlisting>
WITH Temp(temp) AS (
	SELECT tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)' UNION
	SELECT tnpoint '[NPoint(1, 0.2)@2012-01-01, NPoint(1, 0.4)@2012-01-03)' UNION
	SELECT tnpoint '[NPoint(1, 0.3)@2012-01-01, NPoint(1, 0.5)@2012-01-03)' )
SELECT astext(tcentroid(Temp))
FROM Temp
-- "{[POINT(72.451531682218 76.5231414472853)@2012-01-01, POINT(55.7001249027598 72.9552602410653)@2012-01-03)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>
	</chapter>

	<chapter id="indexing_temporal_types">
		<title>Indexing of Temporal Types</title>
		<para>GiST and SP-GiST indexes can be created for table columns of temporal types. The GiST index implements an R-tree for temporal alphanumeric types and a TB-tree for temporal point types. The SP-GiST index implements a Quad-tree for temporal alphanumeric types and an Oct-tree for temporal point types. Examples of index creation are as follows:
			<programlisting>
CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);31002>CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
			</programlisting>
		</para>

		<para>The GiST and SP-GiST indexes store the bounding box for the temporal types. As explained in Section <xref linkend="temporal_types" />, these are
			<itemizedlist>
				<listitem>
					<para>the period <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types,</para>
				</listitem>

				<listitem>
					<para>the <varname>box</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types,</para>
				</listitem>

				<listitem>
					<para>the <varname>gbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types.</para>
				 </listitem>
			 </itemizedlist>
		</para>
			
		<para>A GiST or SP-GiST index can accelerate queries involving the following operators (see Section <xref linkend="operators_temporal_types" /> for more information):
			<itemizedlist>
				 <listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, which only consider the value dimension in temporal alphanumeric types,</para>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, and <varname>/&amp;&gt;</varname>, which only consider the spatial dimension in temporal point types,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, which only consider the time dimension for all temporal types,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, and <varname>~=</varname>, which consider as many dimensions as they are shared by the indexed column and the query argument. These operators work on bounding boxes (that is, either periods or 2D/3D boxes), not the entire values.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>In addition, a GiST index can accelerate nearest neighbor queries involving the <varname>|=|</varname> operator.</para>
			
		<para>For example, given the index defined above on the <varname>Department</varname> table and a query that involves a condition with the <varname>&amp;&amp;</varname> (overlaps) operator, if the right argument is a temporal float then both the value and the time dimensions are considered for filtering the tuples of the relation, while if the right argument is a float value, a float range, or a time type, then either the value or the time dimension will be used for filtering the tuples of the relation. Furthermore, a 2D/3D box can be constructed from a value/range and a timestamp/period, which can be used for filtering the tuples of the relation. Examples of queries using the index on the <varname>Department</varname> table defined above are given next.
			<programlisting>
SELECT * FROM Department WHERE NoEmps &amp;&amp; 5;
SELECT * FROM Department WHERE NoEmps &amp;&amp; intrange '[1,5)';
SELECT * FROM Department WHERE NoEmps &amp;&amp; timestamptz '2012-04-01';
SELECT * FROM Department WHERE NoEmps &amp;&amp; period '[2012-04-01, 2012-05-01)';
SELECT * FROM Department WHERE NoEmps &amp;&amp;31008>
box(intrange '[1,5)', period '[2012-04-01, 2012-05-01)');
SELECT * FROM Department WHERE NoEmps &amp;&amp;31010>
tfloat '{[1@2012-01-01, 1@2012-02-01), [5@2012-04-01, 5@2012-05-01)}';
			</programlisting>
		</para>

		<para>Similarly, examples of queries using the index on the <varname>Trips</varname> table defined above are given next.
			<programlisting>
SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';
SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';
SELECT * FROM Trips WHERE Trip &amp;&amp; period '[2001-01-01, 2001-01-05)';
SELECT * FROM Trips WHERE Trip &amp;&amp;31015>
gbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', period '[2001-01-01, 2001-01-05]');
SELECT * FROM Trips WHERE Trip &amp;&amp;31017>
tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';
			</programlisting>
		</para>
				
		<para>Finally, B-tree indexes can be created for table columns of all temporal types. For this index type, the only useful operation is equality. There is a B-tree sort ordering defined for values of temporal types, with corresponding <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname>, <varname>&gt;=</varname> and operators, but the ordering is rather arbitrary and not usually useful in the real world. B-tree support for temporal types is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>

		<para>In order to speed up several of the functions in Section <xref linkend="manipulating_temporal_types" />, a bounding box comparison that make uses of the available indexes can be added in the <varname>WHERE</varname> clause of queries. For example, this would be typically the case for the functions that project the temporal types to the value/spatial and/or time dimensions. This will filter out the tuples with an index as shown in the following query.
			<programlisting>
SELECT atPeriod(T.Trip, period(2001-01-01, 2001-01-02))
FROM Trips T
-- Bouding box index filtering
WHERE T.Trip &amp;&amp; period(2001-01-01, 2001-01-02)
			 </programlisting>
		</para>
				
		<para>In the case of temporal points, all spatial relationships with the &ldquo;ever&rdquo; semantics (see Section <xref linkend="spatial_relationships_temporal_points" />), excepted <varname>disjoint</varname>and <varname>relate</varname>, will automatically include a bounding box comparison that will make use of any indexes that are available on the temporal points. For this reason, the first version of the relationships is typically used for filtering the tuples with the help of an index when computing the temporal relationships as shown in the following query.
			<programlisting>
SELECT tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
-- Bouding box index filtering
WHERE intersects(T.Trip, R.Geom);
			</programlisting>
		</para>
	</chapter>
		
	<chapter id="statistics_temporal_types">
		<title>Statistics for Temporal Types</title>
		<para>The PostgreSQL planner relies on statistical information about the contents of tables in order to generate the most efficient execution plan for queries. These statistics include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. For large tables, a random sample of the table contents is taken, rather than examining every row. This enables large tables to be analyzed in a small amount of time. The statistical information is gathered by the <varname>ANALYZE</varname> command and stored in the <varname>pg_statistic</varname> catalog table. Since different kinds of statistics may be appropriate for different kinds of data, the table only stores very general statistics (such as number of null values) in dedicated columns. Everything else is stored in five &ldquo;slots&rdquo;, which are couples of array columns that store the statistics for a column of an arbitrary type.</para>

		<para>The statistics collected for time types and temporal types are based on those collected by PostgreSQL for scalar types, array types, and range types. For scalar types, like <varname>float</varname>, the following statistics are collected:
			<orderedlist>
				<listitem>
					<para>fraction of null values,</para>
				</listitem>
				<listitem>
					<para>average width, in bytes, of non-null values,</para>
				</listitem>
				<listitem>
					<para>number of distinct non-null values,</para>
				</listitem>
				<listitem>
					<para>array of most common values and array of their frequencies,</para>
				</listitem>
				<listitem>
					<para>histogram of values, where the most common values are excluded,</para>
				</listitem>
				<listitem>
					<para>correlation between physical and logical row ordering.</para>
				</listitem>
			</orderedlist>
		</para>

		<para>For array types, like <varname>float[]</varname>, in addition to the above, the following statistics are collected:
			<orderedlist>
				<listitem>
					<para>array of most common elements and array of their frequencies,</para>
				</listitem>
				<listitem>
				<para>histogram of distinct element counts.</para>
					</listitem>
			</orderedlist>
		</para>

		<para>For range types, like <varname>tstzrange</varname>, three additional histograms are collected:
			<orderedlist>
				<listitem>
					<para>length histogram of non-empty ranges,</para>
				</listitem>
				<listitem>
					<para>histograms of lower and upper bounds.</para>
				</listitem>
			</orderedlist>
		</para>

		<para>For geometries, in addition to (1)&#x2013;(3), the following statistics are collected:
				 <orderedlist>
					<listitem>
						<para>number of dimensions of the values, N-dimensional bounding box, number of rows in the table, number of rows in the sample, number of non-null values,</para>
					</listitem>
					<listitem>
						<para>N-dimensional histogram that divides the bounding box into a number of cells and keeps the proportion of values that intersects with each cell.</para>
					</listitem>
				</orderedlist>
		</para>

		<para>The statistics collected for the new time types <varname>timestampset</varname>, <varname>period</varname>, and <varname>periodset</varname> replicate those collected by PostgreSQL for the <varname>tstzrange</varname>. This is clear for the <varname>period</varname> type, which is equivalent to <varname>tszrange</varname>, excepted that periods cannot be empty. For the <varname>timestampset</varname> and the <varname>periodset</varname> types, a value is converted into its bounding box which is a <varname>period</varname>, then the <varname>period</varname> statistics are collected.</para>

		<para>The statistics collected for temporal types depend on their duration and their base type. In addition to statistics (1)&#x2013;(3) that are collected for all temporal types, we collect statistics for the value dimension and the time dimension independently. More precisely, the following statistics are collected for the time dimension:
			<itemizedlist>
				<listitem>
					<para>For temporal instant values, the statistics (4)&#x2013;(6) are collected for the timestamps.</para>
				</listitem>

				<listitem>
					<para>For temporal instant set values, the statistics (7) and (8) are collected for the timestamps.</para>
				</listitem>

				<listitem>
					<para>For temporal sequence (set) values, the statistics (9) and (10) are collected for the (bounding box) periods.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>The following statistics are collected for the value dimension:
			<itemizedlist>
				<listitem>
					<para>For temporal discrete types (that is, <varname>tbool</varname>, <varname>ttext</varname>, and <varname>tint</varname>):
						<itemizedlist>
							<listitem>
								<para>For the instant duration, the statistics (4)&#x2013;(6) are collected for the values.</para>
							</listitem>
		
							<listitem>
								<para>For all other durations, the statistics (7) and (8) are collected for the values.</para>
							</listitem>
						 </itemizedlist>
					</para>
				</listitem>

				<listitem>
					<para>For temporal float types (that is, <varname>tfloat</varname>):
						<itemizedlist>
							<listitem>
								<para>For instant values, the statistics (4)&#x2013;(6) are collected for the values.</para>
							 </listitem>
							<listitem>
								<para>For instant set values, the statistics (7) and (8) are collected for the values.</para>
							</listitem>
							<listitem>
								<para>For the sequence (set) values, the statistics (9) and (10) are collected for the (bounding) value ranges.</para>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>

				<listitem>
					<para>For temporal point types (that is, <varname>tgeompoint</varname> and <varname>tgeogpoint</varname>) the statistics (11)&#x2013;(12) are collected for the points.</para>
				</listitem>
			</itemizedlist>
		</para>
	</chapter>

	<chapter id="selectivity_operators">
		<title>Selectivity of Operators</title>
		<para>Boolean operators in PostgreSQL can be associated with two selectivity functions, which compute how likely a value of a given type will match a given criterion. These selectivity functions rely on the statistics collected. There are two types of selectivity functions. The restriction selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>column OP constant</varname>. The join selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>table1.column1 OP table2.column2</varname>.</para>

		<para>The temporal extension defines 23 classes of Boolean operators (such as <varname>=</varname>, <varname>&lt;</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), each of which can have as left or right arguments a built-in type (such as <varname>int</varname>, <varname>timestamptz</varname>, <varname>box</varname>, etc.) or a new type defined in the temporal extension (such as <varname>period</varname>, <varname>tintseq</varname>, etc.). As a consequence, there is a very high number of operators with different arguments to be considered for the selectivity functions. The approach taken was to group these combinations into classes corresponding to the value and temporal features. The classes correspond to the type of statistics collected as explained in the previous section.</para>    
	</chapter>
