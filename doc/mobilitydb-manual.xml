<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!ENTITY geography_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/world.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/world.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/world.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">

<!ENTITY Z_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/cube.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/cube.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/cube.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">

<!ENTITY python_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/python.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/python.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/python.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">

]>
<book lang="en">
	<bookinfo>
		<title>MobilityDB Manual</title>

		<author>
			<firstname>Esteban</firstname>
			<surname>Zim&aacute;nyi</surname>
			<affiliation>
				<orgname>Universit&eacute; libre de Bruxelles, Belgium</orgname>
			</affiliation>
		</author>

		<pubdate>07.01.2020</pubdate>
		<abstract>
			<para>MobilityDB is an extension to the PostgreSQL object-relational database system and its spatial extension PostGIS. It allows temporal and spatio-temporal objects to be stored in the database, that is, objects whose attribute values and/or location evolves in time. MobilityDB includes functions for analysis and processing of temporal and spatio-temporal objects and provides support for GiST and SP-GiST indexes. MobilityDB is open source and its code is available on <ulink url="https://github.com/ULB-CoDE-WIT/MobilityDB">Github</ulink>. An adapter for the Python programming language is also available on <ulink url="https://github.com/ULB-CoDE-WIT/python-mobilityDB">Github</ulink>.</para>

			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref='images/mobilitydb-logo.png' width='200pt' />
					</imageobject>
				</inlinemediaobject>
			</para>

			<para>
			MobilityDB is developed by the Computer &amp; Decision Engineering Department of the Universit&eacute; Libre de Bruxelles (ULB) under the direction of Prof. Esteban Zim&aacute;nyi. ULB is an OGC Associate Member.
			</para>

			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref='images/OGC_Associate_Member_3DR.png' width='100pt' />
					</imageobject>
				</inlinemediaobject>
			</para>
		</abstract>
	</bookinfo>

	<chapter id ="introduction">
		<title>Introduction</title>

		<para>MobilityDB is an extension of <ulink url="http://postgresql.org">PostgreSQL</ulink> and <ulink url="http://postgis.net">PostGIS</ulink> that provides temporal types. Such types are data types that represent the evolution on time of values of some element type, called the base type of the temporal type. For instance, temporal integers may be used to represent the evolution on time of the number of employees of a department. In this case, the data type is &ldquo;temporal integer&rdquo; and &ldquo;integer&rdquo; is the base type. Similarly, a temporal float may be used to represent the evolution on time of the temperature of a room. As another example, a temporal point may be used to represent the evolution on time of the location of a car, as reported by GPS devices. Temporal types are useful because representing values that evolve in time is essential in many applications, for example in mobility applications. Furthermore, the operators on the base types (such as arithmetic operators and aggregation for integers and floats, spatial relationships and distance for geometries) can be intuitively generalized when the values evolve in time.</para>

		<para>MobilityDB provides the following temporal types: <varname>tbool</varname>, <varname>tint</varname>, <varname>tfloat</varname>, <varname>ttext</varname>, <varname>tgeompoint</varname> and <varname>tgeogpoint</varname>. These temporal types are based, respectively, on the <varname>bool</varname>, <varname>int</varname>, <varname>float</varname>, and <varname>text</varname> base types provided by PostgreSQL, and on the <varname>geometry</varname> and <varname>geography</varname> base types provided by PostGIS (restricted to 2D or 3D points).<footnote><para>Although 4D temporal points can be represented, the M dimension is currently not taken into account.</para></footnote> Furthermore, MobilityDB uses four time types to represent extents of time: the <varname>timestamptz</varname> type provided by PostgreSQL and three new types which are <varname>period</varname>, <varname>timestampset</varname>, and <varname>periodset</varname>. In addition, two range types are defined in MobilityDB: <varname>intrange</varname> and <varname>floatrange</varname>.</para>
		
	</chapter>
	
	<chapter id="time_types_range_types">
		<title>Time Types and Range Types</title>

		<para>Temporal types are based on four time types: the <varname>timestamptz</varname> type provided by PostgreSQL and three new types which are <varname>period</varname>, <varname>timestampset</varname>, and <varname>periodset</varname>.</para>

		<para>The <varname>period</varname> type is a specialized version of the <varname>tstzrange</varname> (short for timestamp with time zone range) type provided by PostgreSQL. Type <varname>period</varname> has similar functionality as type <varname>tstzrange</varname> but has a more efficient implementation, in particular it is of fixed length while the <varname>tstzrange</varname> type is of variable length. Furthermore, empty periods and infinite bounds are not allowed in <varname>period</varname> values, while they are allowed in <varname>tstzrange</varname> values.</para>

		<para>A value of the <varname>period</varname> type has two bounds, the lower bound and the upper bound, which are <varname>timestamptz</varname> values. The bounds can be inclusive or exclusive. An inclusive bound means that the boundary instant is included in the period, while an exclusive bound means that the boundary instant is not included in the period. In the text form of a <varname>period</varname> value, inclusive and exclusive lower bounds are represented, respectively, by &ldquo;<varname>[</varname>&rdquo; and &ldquo;<varname>(</varname>&rdquo;. Likewise, inclusive and exclusive upper bounds are represented, respectively, by &ldquo;<varname>]</varname>&rdquo; and &ldquo;<varname>)</varname>&rdquo;. In a <varname>period</varname> value, the lower bound must be less than or equal to the upper bound. A <varname>period</varname> value with equal and inclusive bounds is called an instant period and corresponds to a <varname>timestamptz</varname> value. Examples of <varname>period</varname> values are as follows:
			<programlisting>
SELECT period '[2012-01-01 08:00:00, 2012-01-03 09:30:00)';
-- Instant period
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00]';
-- Erroneous periods
SELECT period '[2012-01-01 08:10:00, 2012-01-01 08:00:00]'; -- invalid bounds
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00)'; -- empty period
			</programlisting>
		</para>

		<para>The <varname>timestampset</varname> type represents a set of distinct <varname>timestamptz</varname> values. A <varname>timestampset</varname> value must contain at least one element, in which case it corresponds to a <varname>timestamptz</varname> value. The elements composing a <varname>timestampset</varname> value must be ordered. Examples of <varname>timestampset</varname> values are as follows:
			<programlisting>
SELECT timestampset '{2012-01-01 08:00:00, 2012-01-03 09:30:00}';
-- Singleton timestampset
SELECT timestampset '{2012-01-01 08:00:00}';
-- Erroneous timestampset values
SELECT timestampset '{2012-01-01 08:10:00, 2012-01-01 08:00:00}'; -- unordered elements
SELECT timestampset '{2012-01-01 08:00:00, 2012-01-01 08:00:00}'; -- duplicate elements
			</programlisting>
		</para>

		<para>Finally, the <varname>periodset</varname> type represents a set of disjoint <varname>period</varname> values. A <varname>periodset</varname> value must contain at least one element, in which case it corresponds to a <varname>period</varname> value. The elements composing a <varname>periodset</varname> value must be ordered. Examples of <varname>periodset</varname> values are as follows:
			<programlisting>
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],
[2012-01-01 08:20:00, 2012-01-01 08:40:00]}';
-- Singleton periodset
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00]}';
-- Erroneous periodset values
SELECT periodset '{[2012-01-01 08:20:00, 2012-01-01 08:40:00],
	[2012-01-01 08:00:00, 2012-01-01 08:10:00]}';
-- unordered elements
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],
	[2012-01-01 08:05:00, 2012-01-01 08:15:00]}';
-- overlapping elements
			</programlisting>
		</para>

		<para>Values of the <varname>periodset</varname> type are converted into a <emphasis role="strong">normal</emphasis> form so that equivalent values have identical representations. For this, consecutive adjacent period values are merged when possible. An example of transformation into a normal form is as follows:
			<programlisting>
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00),
	[2012-01-01 08:10:00, 2012-01-01 08:10:00], (2012-01-01 08:10:00, 2012-01-01 08:20:00]}';
-- "{[2012-01-01 08:00:00+00,2012-01-01 08:20:00+00]}"
			</programlisting>
		</para>

		<para>Values of the <varname>timestamptz</varname> type, the <varname>tstzrange</varname> type, or the time types can be converted to one another using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation. This is shown next.
			<programlisting>
-- Converts a timestamptz to another time type
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS period);
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS timestampset);
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS periodset);
-- Converts a period to a periodset
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::periodset;
-- Converts a period to a tstzrange
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::tstzrange;
-- Converts a tstzrange to a period
SELECT tstzrange '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::period;
			</programlisting>
		</para>

		<para>Besides the built-in range types provided by PostgreSQL, two additional range types are defined, <varname>intrange</varname> (another name for <varname>int4range</varname>) and <varname>floatrange</varname>.</para>

		<sect1 id ="functions_operations_time_types">
			<title>Functions and Operators for Time Types and Range Types</title>
				
			<para>We present next the functions and operators for time types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this in the signature of the operators, we use the following notation:
				<itemizedlist>
					<listitem>
						<para>A set of types such as <varname>{period, timestampset, periodset}</varname> represents any of the types listed,</para>
					</listitem>
					<listitem>
						<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
					</listitem>
					<listitem>
						<para><varname>number</varname> represents any numeric type, that is, <varname>int</varname> or <varname>float</varname>,</para>
					</listitem>
					<listitem>
						<para><varname>range</varname> represents any numeric range type, that is, <varname>intrange</varname> or <varname>floatrange</varname>.</para>
					</listitem>
					<listitem>
						<para><varname>type[]</varname> represents an array of <varname>type</varname>.
						</para>
					</listitem>
				</itemizedlist>
			</para>
				
			<para>As an example, the signature of the contains operator (<varname>@&gt;</varname>) is as follows:
				<programlisting>
{timestampset, period, periodset} @&gt; time
				</programlisting>
			In the following, for conciseness, the time part of the timestamps is omitted in the examples. Recall that in that case PostgreSQL assumes the time <varname>00:00:00</varname>.
			</para>

			<sect2>
				<title>Constructor Functions</title>

				<para>The <varname>period</varname> type has a constructor function that accepts two or four arguments. The two-argument form constructs a period in <emphasis role="strong">normal</emphasis> form, that is, with inclusive lower bound and exclusive upper bound. The four-argument form constructs a period with bounds specified by the third and fourth arguments, which are Boolean values stating, respectively, whether the left and right bounds are inclusive or not.
				</para>
				<itemizedlist>
					<listitem>
						<para>Constructor for periods</para>
						<para><varname>period(timestamptz, timestamptz, left_inc = true, right_inc = false): period</varname></para>
						<programlisting>
-- It is assumed that the lower bound is inclusive and the upper bound is exclusive.
SELECT period('2012-01-01 08:00:00', '2012-01-03 08:00:00');
-- Period defined with four arguments
SELECT period('2012-01-01 08:00:00', '2012-01-03 09:30:00', false, true);
						</programlisting>
					</listitem>
				</itemizedlist>

				<para>The <varname>timestampset</varname> type has a constructor function that accepts a single argument which is an array of <varname>timestamptz</varname> values.
				</para>
				<itemizedlist>
					<listitem>
						<para>Constructor for timestampsets</para>
						<para><varname>timestampset(timestamptz[]): timestampset</varname></para>
						<programlisting>
SELECT timestampset(ARRAY[timestamptz '2012-01-01 08:00:00', '2012-01-03 09:30:00']);
-- "{2012-01-01 08:00:00+00, 2012-01-03 09:30:00+00}"
						</programlisting>
					</listitem>
				</itemizedlist>

				<para>The <varname>periodset</varname> type has a constructor function that accepts a single argument which is an array of <varname>period</varname> values.
				</para>
				<itemizedlist>
					<listitem>
						<para>Constructor for periodsets</para>
						<para><varname>periodset(period[]): periodset</varname></para>
						<programlisting>
SELECT periodset(ARRAY[period '[2012-01-01 08:00:00, 2012-01-01 08:10:00]',
-- '[2012-01-01 08:20:00, 2012-01-01 08:40:00]']);
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Accessor Functions</title>

				<itemizedlist>
					<listitem>
					<para>Memory size in bytes</para>
						<para><varname>memSize({timestampset, periodset}): integer</varname></para>
						<programlisting>
SELECT memSize(timestampset '{2012-01-01, 2012-01-02, 2012-01-03}');
-- 104
SELECT memSize(periodset '{[2012-01-01, 2012-01-02], [2012-01-03, 2012-01-04], 
	[2012-01-05, 2012-01-06]}');
-- 136
						</programlisting>
					</listitem>

					<listitem>
					<para>Lower bound</para>
					<para><varname>lower(period): timestamptz</varname></para>
					<programlisting>
SELECT lower(period '[2011-01-01, 2011-01-05)');
-- "2011-01-01"
					</programlisting>
					</listitem>

					<listitem>
						<para>Upper bound</para>
						<para><varname>upper(period): timestamptz</varname></para>
						<programlisting>
SELECT upper(period '[2011-01-01, 2011-01-05)');
-- "2011-01-05"
						</programlisting>
					</listitem>

					<listitem>
						<para>Is the lower bound inclusive?</para>
						<para><varname>lower_inc(period): boolean</varname></para>
						<programlisting>
SELECT lower_inc(period '[2011-01-01, 2011-01-05)');
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Is the upper bound inclusive?</para>
						<para><varname>upper_inc(period): boolean</varname></para>
						<programlisting>
SELECT upper_inc(period '[2011-01-01, 2011-01-05)');
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para>Timespan</para>
						<para><varname>timespan({period, periodset}): interval</varname></para>
						<programlisting>
SELECT timespan(period '[2012-01-01, 2012-01-03)');
-- "2 days"
SELECT timespan(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "3 days"
						</programlisting>
					</listitem>

					<listitem>
						<para>Period on which the timestamp set or period set is defined ignoring the potential time gaps</para>
						<para><varname>period({timestampset, periodset}): period</varname></para>
						<programlisting>
SELECT period(timestampset '{2012-01-01, 2012-01-03, 2012-01-05}');
-- "[2012-01-01, 2012-01-05]"
SELECT period(periodset '{[2012-01-01, 2012-01-02), [2012-01-03, 2012-01-04)}');
-- "[2012-01-01, 2012-01-04)"
						</programlisting>
					</listitem>

					<listitem>
						<para>Number of distinct timestamps</para>
						<para><varname>numTimestamps({timestampset, periodset}): int</varname></para>
						<programlisting>
SELECT numTimestamps(timestampset '{2012-01-01, 2012-01-03, 2012-01-04}');
-- 3
SELECT numTimestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- 3
						</programlisting>
					</listitem>

					<listitem>
						<para>Start timestamp</para>
						<para><varname>startTimestamp({timestampset, periodset}): timestamptz</varname></para>
						<programlisting>
SELECT startTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "2012-01-01"
						</programlisting>
						<para>The function does not take into account whether the bounds are inclusive or not.</para>
					</listitem>

					<listitem>
						<para>End timestamp</para>
						<para><varname>endTimestamp({timestampset, periodset}): timestamptz</varname></para>
						<programlisting>
SELECT endTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "2012-01-05"
						</programlisting>
						<para>The function does not take into account whether the bounds are inclusive or not.</para>
					</listitem>

					<listitem>
						<para>N-th distinct timestamp</para>
						<para><varname>timestampN({timestampset, periodset}, int): timestamptz</varname></para>
						<programlisting>
SELECT timestampN(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}', 3);
-- "2012-01-04"
						</programlisting>
						<para>The function does not take into account whether the bounds are inclusive or not.</para>
					</listitem>

					<listitem>
						<para>Distinct timestamps</para>
						<para><varname>timestamps({timestampset, periodset}): timestampset</varname></para>
						<programlisting>
SELECT timestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "{"2012-01-01", "2012-01-03", "2012-01-05"}"
						</programlisting>
						<para>The function does not take into account whether the bounds are inclusive or not.</para>
					</listitem>

					<listitem>
						<para>Number of periods</para>
						<para><varname>numPeriods(periodset): int</varname></para>
						<programlisting>
SELECT numPeriods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
	[2012-01-05, 2012-01-06)}');
-- 3
						</programlisting>
					</listitem>

					<listitem>
						<para>Start period</para>
						<para><varname>startPeriod(periodset): period</varname></para>
						<programlisting>
SELECT startPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
	[2012-01-05, 2012-01-06)}');
-- "[2012-01-01,2012-01-03)"
						</programlisting>
					</listitem>

					<listitem>
						<para>End period</para>
						<para><varname>endPeriod(periodset): period</varname></para>
						<programlisting>
SELECT endPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
	[2012-01-05, 2012-01-06)}');
-- "[2012-01-05,2012-01-06)"
						</programlisting>
					</listitem>

					<listitem>
						<para>N-th period</para>
						<para><varname>periodN(periodset, int): period</varname></para>
						<programlisting>
SELECT periodN(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
	[2012-01-05, 2012-01-06)}', 2);
-- "[2012-01-04,2012-01-04]"
						</programlisting>
					</listitem>

					<listitem>
						<para>Periods</para>
						<para><varname>periods(periodset): period[]</varname></para>
						<programlisting>
SELECT periods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04], 
	[2012-01-05, 2012-01-06)}');
-- "{"[2012-01-01,2012-01-03)","[2012-01-04,2012-01-04]","[2012-01-05,2012-01-06)"}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Shift</para>
						<para><varname>shift({timestampset,period,periodset}): {timestampset,period,periodset}</varname></para>
						<programlisting>
SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);
-- "{2001-01-02, 2001-01-04, 2001-01-06}"
SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);
-- "[2001-01-02, 2001-01-04]"
SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}', 
	'1 day'::interval);
-- "{[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}"
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>
			
			<sect2 id="operators">
				<title>Operators</title>
				<para>In PostgreSQL, the range operators <varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&gt;</varname>, and <varname>-|-</varname> only accept a range as left or right argument. We extended these operators for numeric ranges so that one argument may be an integer or a float.</para>

				<para>The comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right arguments be of the same type. Excepted equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on time types.</para>

				<para>The operators available for the time types and range types are given next.</para>

				<itemizedlist>
					<listitem>
						<para>Equal</para>
						<para><varname>time = time</varname></para>
						<programlisting>
SELECT period '[2012-01-01, 2012-01-04)' = period '[2012-01-01, 2012-01-04)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Not equal</para>
						<para><varname>time &lt;&gt; time</varname></para>
						<programlisting>
SELECT period '[2012-01-01, 2012-01-04)' &lt;&gt; period '[2012-01-03, 2012-01-05)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Less than</para>
						<para><varname>time &lt; time</varname></para>
						<programlisting>
SELECT timestampset '{2012-01-01, 2012-01-04}' &lt; timestampset '{2012-01-01, 2012-01-05}';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Greater than</para>
						<para><varname>time &gt; time</varname></para>
						<programlisting>
SELECT period '[2012-01-03, 2012-01-04)' &gt; period '[2012-01-02, 2012-01-05)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Less than or equal to</para>
						<para><varname>time &lt;= time</varname></para>
						<programlisting>
SELECT periodset '{[2012-01-01, 2012-01-04)}' &lt;= 
	periodset '{[2012-01-01, 2012-01-05), [2012-01-06, 2012-01-07)}';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Greater than or equal to</para>
						<para><varname>time &gt;= time</varname></para>
						<programlisting>
SELECT period '[2012-01-03, 2012-01-05)' &gt;= period '[2012-01-03, 2012-01-04)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Contains</para>
						<para><varname>{timestampset, period, periodset} @&gt; time</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-05-01)' @&gt; period '[2011-02-01, 2011-03-01)';
-- true
SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Is contained by</para>
						<para><varname>time &lt;@ {timestampset, period, periodset}</varname></para>
						<programlisting>
SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Overlap (have points in common)</para>
						<para><varname>{timestampset, period, periodset} &amp;&amp; {timestampset, period, periodset}</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Is adjacent to</para>
						<para><varname>time -|- time</varname></para>
						<para><varname>{number, range} -|- {number, range}</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';
-- true
SELECT floatrange '[15, 20)' -|- 20;
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Scritly left of</para>
						<para><varname>{number, range} &lt;&lt; {number, range}</varname></para>
						<programlisting>
SELECT intrange '[15, 20)' &lt;&lt; 20;
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Strictly right of</para>
						<para><varname>{number, range} &gt;&gt; {number, range}</varname></para>
						<programlisting>
SELECT intrange '[15, 20)' &gt;&gt; 10;
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Does not extend to the right of</para>
						<para><varname>{number, range} &amp;&lt; {number, range}</varname></para>
						<programlisting>
SELECT intrange '[15, 20)' &amp;&lt; 18;
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para>Does not extend to the left of</para>
						<para><varname>{number, range} &amp;&gt; {number, range}</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-03)' &amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
SELECT intrange '[15, 20)' &amp;&gt; 30;
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Scritly before</para>
						<para><varname>time &lt;&lt;# time</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Strictly after</para>
						<para><varname>time #&gt;&gt; time</varname></para>
						<programlisting>
SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt; 
	periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Is not after of</para>
						<para><varname>time &amp;&lt;# time</varname></para>
						<programlisting>
SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para>Is not before of</para>
						<para><varname>time #&amp;&gt; time</varname></para>
						<programlisting>
SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>Union</para>
						<para><varname>time + time</varname></para>
						<programlisting>
SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +
	timestampset '{2011-01-03, 2011-01-06}';
-- "{2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}"
SELECT period '[2011-01-01, 2011-01-05)' + period '[2011-01-03, 2011-01-07)';
-- "[2011-01-01, 2011-01-07)"
SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +
	period '[2011-01-03, 2011-01-04)';
-- "{[2011-01-01, 2011-01-05)}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Intersection</para>
						<para><varname>time * time</varname></para>
						<programlisting>
SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';
-- "{2011-01-03}"
SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';
-- "[2011-01-03, 2011-01-05)"
						</programlisting>
					</listitem>

					<listitem>
						<para>Difference</para>
						<para><varname>time - time</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';
-- "[2011-01-01, 2011-01-03)"
SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'
-- "{[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}"
SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -
	periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05], 
	[2011-01-08, 2011-01-09]}';
-- "{[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],
[2011-01-07,2011-01-08), (2011-01-09,2011-01-10]}"
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>
		</sect1>

		<sect1 id ="indexing_time_types">
			<title>Indexing of Time Types</title>
			<para>GiST and SP-GiST indexes can be created for table columns of the <varname>timestampset</varname>, <varname>period</varname>, and <varname>periodset</varname> types. An example of creation of a GiST index in a column <varname>during</varname> of type <varname>period</varname> in a table <varname>reservation</varname> is as follows:
					<programlisting>
CREATE TABLE reservation (ReservationID integer PRIMARY KEY, RoomID integer, 
	During period);
CREATE INDEX reservation_during_idx ON reservation USING GIST(during);
					</programlisting>
			</para>
			<para>A GiST or SP-GiST index can accelerate queries involving the following operators: <varname>=</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname>.</para>
			<para>In addition, B-tree indexes can be created for table columns of a time type. For these index types, basically the only useful operation is equality. There is a B-tree sort ordering defined for values of time types, with corresponding <varname>&lt;</varname> and <varname>&gt;</varname> operators, but the ordering is rather arbitrary and not usually useful in the real world. The B-tree support is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>
		</sect1>
	</chapter>

	<chapter id="temporal_types">
		<title>Temporal Types</title>
		<para>There are six built-in temporal types, <varname>tbool</varname>, <varname>tint</varname>, <varname>tfloat</varname>, <varname>ttext</varname>, <varname>tgeompoint</varname>, and <varname>tgeogpoint</varname>, which are, respectively, based on the base types <varname>bool</varname>, <varname>int</varname>, <varname>float</varname>, <varname>text</varname>, <varname>geometry</varname>, and <varname>geography</varname> (the last two types restricted to 2D or 3D points with Z dimension). 
		</para>

		<para>The <emphasis role="strong">interpolation</emphasis> of a temporal value states how the value evolves between successive instants. The interpolation is <emphasis role="strong">stepwise</emphasis> when the value remains constant between two successive instants. For example, the number of employees of a department may be represented with a temporal integer, which indicates that its value is constant between two time instants. On the other hand, the interpolation is <emphasis role="strong">linear</emphasis> when the value evolves linearly between two successive instants. For example, the temperature of a room may be represented with a temporal float, which indicates that the values are known at the two time instants but continuously evolve between them. Similarly, the location of a vehicule may be represented by a temporal point where the location between two consecutive GPS readings is obtained by linear interpolation. Temporal types based on discrete base types, that is the <varname>tbool</varname>, <varname>tint</varname>, or <varname>ttext</varname> evolve necesssarily in a stepwise manner. On the other hand, temporal types based on continuous base types, that is <varname>tfloat</varname>, <varname>tgeompoint</varname>, or <varname>tgeogpoint</varname> may evolve in a stepwise or linear manner.</para>

		<para>The <emphasis role="strong">duration</emphasis> of a temporal value states the temporal extent at which the evolution of values is recorded. Temporal values come in four durations, namely, instant, instant set, sequence, and sequence set.</para>

		<para>A temporal value of <emphasis role="strong">instant</emphasis> duration (briefly, an instant value) represents the value at a time instant, for example
			<programlisting>
SELECT tfloat '17@2018-01-01 08:00:00';
			</programlisting>
		</para>

		<para>A temporal value of <emphasis role="strong">instant set</emphasis> duration (briefly, an instant set value) represents the evolution of the value at a set of time instants, where the values between these instants are unknown. An example is as follows:
			<programlisting>
SELECT tfloat '{17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00, 18@2018-01-01 08:10:00}';
			</programlisting>
		</para>

		<para>A temporal value of <emphasis role="strong">sequence</emphasis> duration (briefly, a sequence value) represents the evolution of the value during a sequence of time instants, where the values between these instants are interpolated using either a stepwise or a linear function (see below). An example is as follows:
			<programlisting>
SELECT tint '(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]';
			</programlisting>
		</para>
				
		<para>As can be seen, a value of a type with sequence duration has a lower and an upper bound that can be inclusive (represented by &lsquo;<varname>[</varname>&rsquo; and &lsquo;<varname>]</varname>&rsquo;) or exclusive (represented by &lsquo;<varname>(</varname>' and &lsquo;<varname>)</varname>'). A temporal sequence value with a single instant such as
			<programlisting>
SELECT tint '[10@2018-01-01 08:00:00]';
			</programlisting>
		is called an <emphasis role="strong">instantaneous sequence</emphasis>. In that case, both bounds must be inclusive.
		</para>
				
		<para>The value of a temporal sequence is interpreted by assuming that the period of time defined by every pair of consecutive values <varname>v1@t1</varname> and <varname>v2@t2</varname> is lower inclusive and upper exclusive, unless they are the first or the last instants of the sequence and in that case the bounds of the whole sequence apply. Furthermore, the value taken by the temporal sequence between two consecutive instants depends on whether the interpolation is stepwise or linear. For example, the temporal sequence above represents that the value is <varname>10</varname> during <varname>(2018-01-01 08:00:00, 2018-01-01 08:05:00)</varname>, <varname>20</varname> during <varname>[2018-01-01 08:05:00, 2018-01-01 08:10:00)</varname>, and <varname>15</varname> at the end instant <varname>2018-01-01 08:10:00</varname>. On the other hand, the following temporal sequence
			<programlisting>
SELECT tfloat '(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]';
			</programlisting>
		represents that the value evolves linearly from <varname>10</varname> to <varname>20</varname> during <varname>(2018-01-01 08:00:00, 2018-01-01 08:05:00)</varname> and evolves from <varname>20</varname> to <varname>15</varname> during <varname>[2018-01-01 08:05:00, 2018-01-01 08:10:00]</varname>.</para>

		<para>Finally, a temporal value of <emphasis role="strong">sequence set</emphasis> duration (briefly, a sequence set value) represents the evolution of the value at a set of sequences, where the values between these sequences are unknown. An example is as follows:
			<programlisting>
SELECT tfloat '{[17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00],
	[18@2018-01-01 08:10:00, 18@2018-01-01 08:15:00]}';
			</programlisting>
		</para>
				
		<para>Temporal values with instant or sequence duration are called <emphasis role="strong">temporal unit values</emphasis>, while temporal values with instant set or sequence set duration are called <emphasis role="strong">temporal set values</emphasis>. Temporal set values can be thought of as an array of the corresponding unit values. Temporal set values must be <emphasis role="strong">uniform</emphasis>, that is, they must be constructed from unit values of the same base type and the same duration.</para>

			<para>Temporal sequence values are converted into a <emphasis role="strong">normal</emphasis> form so that equivalent values have identical representations. For this, consecutive instant values are merged when possible. For stepwise interpolation, three consecutive instant values can be merged into two if they have the same value. For linear interpolation, three consecutive instant values can be merged into two if the linear functions defining the evolution of values are the same. Examples of transformation into a normal form are as follows.
				<programlisting>
SELECT tint '[1@2001-01-01, 2@2001-01-03, 2@2001-01-04, 2@2001-01-05)';
-- "[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00, 2@2001-01-05 00:00:00+00)"
SELECT tgeompoint '[Point(1 1)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:05:00,
	Point(1 1)@2001-01-01 08:10:00)';
-- "[Point(1 1)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:10:00)"
SELECT tfloats(ARRAY[tfloat '[1@2001-01-01, 2@2001-01-03, 3@2001-01-05]']);
-- "{[1@2001-01-01 00:00:00+00, 3@2001-01-05 00:00:00+00]}"
SELECT tgeompoint '[Point(1 1)@2001-01-01 08:00:00, Point(2 2)@2001-01-01 08:05:00,
	Point(3 3)@2001-01-01 08:10:00]';
-- "[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00]"
				</programlisting>
			</para>

			<para> Similary, temporal sequence set values are converted into a normal form. For this, consecutive sequence values are merged when possible. Examples of transformation into a normal form are as follows.
				<programlisting>
SELECT tints(ARRAY[tint '[1@2001-01-01, 1@2001-01-03)', '[2@2001-01-03, 2@2001-01-05)']);
-- '{[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00, 2@2001-01-05 00:00:00+00)}'
SELECT tfloats(ARRAY[tfloat '[1@2001-01-01, 2@2001-01-03)', 
	'[2@2001-01-03, 3@2001-01-05]']);
-- '{[1@2001-01-01 00:00:00+00, 3@2001-01-05 00:00:00+00]}'
SELECT tfloats(ARRAY[tfloat '[1@2001-01-01, 3@2001-01-05)', '[3@2001-01-05]']);
-- '{[1@2001-01-01 00:00:00+00, 3@2001-01-05 00:00:00+00]}'
SELECT tgeompoint '{[Point(0 0)@2001-01-01 08:00:00,
	Point(1 1)@2001-01-01 08:05:00, Point(1 1)@2001-01-01 08:10:00),
	[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)}';
-- "{[[Point(0 0)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:05:00,
	Point(1 1)@2001-01-01 08:15:00)}"
SELECT tgeompoint '{[Point(1 1)@2001-01-01 08:00:00, Point(2 2)@2001-01-01 08:05:00),
	[Point(2 2)@2001-01-01 08:05:00, Point(3 3)@2001-01-01 08:10:00]}';
-- "{[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00]}"
SELECT tgeompoint '{[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00),
	[Point(3 3)@2001-01-01 08:10:00]}';
-- "{[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00]}"
				</programlisting>
			</para>

		<para>Temporal types support <emphasis role="strong">type modifiers</emphasis> (or <varname>typmod</varname> in PostgreSQL terminology), which specify additional information for a column definition. For example, in the following table definition:
			<programlisting>
CREATE TABLE Department(DeptNo integer, DeptName varchar(25), NoEmps tint(Sequence));
			</programlisting>
		the type modifier for the type <varname>varchar</varname> is the value 25, which indicates the maximum length of the values of the column, while the type modifier for the type <varname>tint</varname> is the string <varname>Sequence</varname>, which restricts the duration of the values of the column to be sequences. In the case of temporal alphanumeric types (that is, <varname>tbool</varname>, <varname>tint</varname>, <varname>tfloat</varname>, and <varname>ttext</varname>), the possible values for the type modifier are <varname>Instant</varname>, <varname>InstantSet</varname>, <varname>Sequence</varname>, and <varname>SequenceSet</varname>. If no type modifier is specified for a column, values of any duration are allowed.</para>

		<para>On the other hand, in the case of temporal point types (that is, <varname>tgeompoint</varname> or <varname>tgeogpoint</varname>) the type modifier may be used to specify specify the duration, the dimensionality, and/or the spatial reference identifier (SRID). For example, in the following table definition:
			<programlisting>
CREATE TABLE Flight(FlightNo integer, Route tgeogpoint(Sequence, PointZ, 4326));
			</programlisting>
		the type modifier for the type <varname>tgeogpoint</varname> is composed of three values, the first one indicating the duration as above, the second one the spatial type of the geographies composing the temporal point, and the last one the SRID of the composing geographies. For temporal points, the possible values for the first argument of the type modifier are as above, those for the second argument are either <varname>Point</varname> or <varname>PointZ</varname>, and those for the third argument are valid SRIDs. All the three arguments are optional and if any of them is not specified for a column, values of any duration, dimensionality, and/or SRID are allowed.</para>

		<para>Each temporal type is associated to another type, referred to as its <emphasis role="strong">bounding box</emphasis>, which represent its extent in the value and/or the time dimension. The bounding box of the various temporal types are as follows:
			<itemizedlist>
				<listitem>
					<para>The <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types, where only the temporal extent is considered.</para>
				</listitem>

				<listitem>
					<para>A <varname>tbox</varname> (temporal box) type for the <varname>tint</varname> and <varname>tfloat</varname> types, where the value extent is defined in the X dimension and the temporal extent in the T dimension.</para>
				</listitem>

				<listitem>
					<para>A <varname>stbox</varname> (spatiotemporal box) type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, where the spatial extent is defined in the X, Y, and Z dimensions, and the temporal extent in the T dimension.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>A rich set of functions and operators is available to perform various operations on temporal types. They are explained in <xref linkend="manipulating_temporal_types" />. Some of these operations, in particular those related to indexes, manipulate bounding boxes for efficiency reasons.</para>

		<sect1 id="examples_temporal_types">
			<title>Examples of Temporal Types</title>
			<para>Examples of usage of temporal alphanumeric types are given next.</para>
			<programlisting>
CREATE TABLE Department(DeptNo integer, DeptName varchar(25), NoEmps tint);
INSERT INTO Department VALUES
(10, 'Research', tint '[10@2012-01-01, 12@2012-04-01, 12@2012-08-01)'),
(20, 'Human Resources', tint '[4@2012-02-01, 6@2012-06-01, 6@2012-10-01)');
CREATE TABLE Temperature(RoomNo integer, Temp tfloat);
INSERT INTO Temperature VALUES
(1001, tfloat '{18.5@2012-01-01 08:00:00, 20.0@2012-01-01 08:10:00}'),
(2001, tfloat '{19.0@2012-01-01 08:00:00, 22.5@2012-01-01 08:10:00}');
-- Value at a timestamp
SELECT RoomNo, valueAtTimestamp(Temp, '2012-01-01 08:10:00')
FROM temperature;
-- 1001;
-- 2001;22.5
-- Restriction to a value
SELECT DeptNo, atValue(NoEmps, 10)
FROM Department;
-- 10;"[10@2012-01-01 00:00:00+00, 10@2012-04-01 00:00:00+00)"
-- 20; NULL
-- Restriction to a period
SELECT DeptNo, atPeriod(NoEmps, '[2012-01-01, 2012-04-01]')
FROM Department;
-- 10;"[10@2012-01-01 00:00:00+00, 12@2012-04-01 00:00:00+00]"
-- 20;"[4@2012-02-01 00:00:00+00, 4@2012-04-01 00:00:00+00]"
-- Temporal comparison
SELECT DeptNo, NoEmps #&lt;= 10
FROM Department;
-- 10;"[t@2012-01-01 00:00:00+00, f@2012-04-01 00:00:00+00, f@2012-08-01 00:00:00+00)"
-- 20;"[t@2012-04-02 00:00:00+00, t@2012-10-01 00:00:00+00)"
-- Temporal aggregation
SELECT tsum(NoEmps)
FROM Department;
-- "{[10@2012-01-01 00:00:00+00, 14@2012-02-01 00:00:00+00, 16@2012-04-01 00:00:00+00,
 18@2012-06-01 00:00:00+00, 6@2012-08-01 00:00:00+00, 6@2012-10-01 00:00:00+00)}"
			</programlisting>
			<para>Examples of usage of temporal point types are given next.</para>
			<programlisting>
CREATE TABLE Trips(CarId integer, TripId integer, Trip tgeompoint);
INSERT INTO Trips VALUES
(10, 1, tgeompoint '{[Point(0 0)@2012-01-01 08:00:00, Point(2 0)@2012-01-01 08:10:00,
	Point(2 1)@2012-01-01 08:15:00)}'),
(20, 1, tgeompoint '{[Point(0 0)@2012-01-01 08:05:00, Point(1 1)@2012-01-01 08:10:00,
	Point(3 3)@2012-01-01 08:20:00)}');
-- Value at a given timestamp
SELECT CarId, ST_AsText(valueAtTimestamp(Trip, timestamptz '2012-01-01 08:10:00'))
FROM Trips;
-- 10;"POINT(2 0)"
-- 20;"POINT(1 1)"
-- Restriction to a given value
SELECT CarId, asText(atValue(Trip, 'Point(2 0)'))
FROM Trips;
-- 10;"{"[POINT(2 0)@2012-01-01 08:10:00+00]"}"
-- 20; NULL
-- Restriction to a period
SELECT CarId, asText(atPeriod(Trip, '[2012-01-01 08:05:00,2012-01-01 08:10:00]'))
FROM Trips;
-- 10;"{[POINT(1 0)@2012-01-01 08:05:00+00, POINT(2 0)@2012-01-01 08:10:00+00]}"
-- 20;"{[POINT(0 0)@2012-01-01 08:05:00+00, POINT(1 1)@2012-01-01 08:10:00+00]}"
-- Temporal distance
SELECT T1.CarId, T2.CarId, T1.Trip &lt;-&gt; T2.Trip
FROM Trips T1, Trips T2
WHERE T1.CarId &lt; T2.CarId;
-- 10;20;"{[1@2012-01-01 08:05:00+00, 1.4142135623731@2012-01-01 08:10:00+00,
	1@2012-01-01 08:15:00+00)}"
			</programlisting>
		</sect1>
			
		<sect1 id="validity_temporal_types">
			<title>Validity of Temporal Types</title>

			<para>Values of temporal types must satisfy several constraints so that they are well defined. These constraints are given next.
			<itemizedlist>
				<listitem>
					<para>The constraints on the corresponding base type and <varname>timestamptz</varname> types must be satisfied.</para>
				</listitem>

				<listitem>
					<para>A temporal sequence value must be composed of at least one instant value.</para>
				</listitem>

				<listitem>
					<para>An instantaneous temporal sequence value must have inclusive lower and upper bounds.</para>
				</listitem>

				<listitem>
					<para>In a temporal sequence value, the timestamps of the composing instants must be distinct and ordered.</para>
				</listitem>

				<listitem>
					<para>In a temporal sequence value with stepwise interpolation, the last two values must be equal if upper bound is exclusive.</para>
				</listitem>

				<listitem>
					<para>A temporal set value must be composed of at least one temporal unit value.</para>
				</listitem>

				<listitem>
					<para>In a temporal instant set value, the composing instants must be distinct and ordered. This implies that the temporal extent of a temporal instant set value is an ordered set of <varname>timestamptz</varname> values without duplicates.</para>
				</listitem>

				<listitem>
					<para>In a temporal sequence set value, the composing sequence values must be non overlapping and ordered. This implies that the temporal extent of a temporal sequence set value is an ordered set of disjoint periods.</para>
				</listitem>
			</itemizedlist>
			An error is raised whenever one of these constraints are not satisfied. Examples of incorrect temporal values are as follows.
				<programlisting>
-- incorrect value for base type
SELECT tbool '1.5@2001-01-01 08:00:00';
-- base type is not a point
SELECT tgeompoint 'Linestring(0 0,1 1)@2001-01-01 08:05:00';
-- incorrect timestamp
SELECT tint '2@2001-02-31 08:00:00';
-- empty sequence
SELECT tint '';
-- incorrect bounds for instantaneous sequence
SELECT tint '[1@2001-01-01 09:00:00)';
-- duplicate timestamps
SELECT tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:00:00]';
-- unordered timestamps
SELECT tint '[1@2001-01-01 08:10:00, 2@2001-01-01 08:00:00]';
-- incorrect end value
SELECT tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:10:00)';
-- empty temporal sequence set value
SELECT tints(ARRAY[]);
-- duplicate timestamps
SELECT tinti(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:00:00']);
-- overlapping periods
SELECT tints(ARRAY[tint '[1@2001-01-01 08:00:00, 1@2001-01-01 10:00:00)',
	'[2@2001-01-01 09:00:00, 2@2001-01-01 11:00:00)']);
				</programlisting>
			</para>
		</sect1>
	</chapter>

	<chapter id="manipulating_box_types">
		<title>Manipulating Box Types</title>

		<sect1 id ="input_output_box_tyes">
			<title>Input/Output of Box Types</title>
			<para>A <varname>tbox</varname> is composed of value and/or time dimensions. For each dimension, minimum and maximum values are given. Examples of input of <varname>tbox</varname> values are as follows:
				<programlisting>
-- Both value and time dimensions
SELECT tbox 'TBOX((1.0, 2000-01-01), (2.0, 2000-01-02))'; 
-- Only value dimension
SELECT tbox 'TBOX((1.0,), (2.0,))'; 
-- Only time dimension
SELECT tbox 'TBOX((, 2000-01-01), (, 2000-01-02))'; 
				</programlisting>
			</para>

			<para>An <varname>stbox</varname> is composed of values and/or time dimensions, where the coordinates of the value dimension may be 2D or 3D. For each dimension, minimum and maximum values are given. The coordinates may be Cartesian (planar) or geodetic (spherical). The SRID of the coordinates may be specified; if it is not the case, a value of 0 (unknown) and 4326 (corresponding to WGS84) is assumed, respectively, for planar and geodetic boxes. Examples of input of <varname>stbox</varname> values are as follows:
				<programlisting>
-- Only value dimension with X and Y coordinates
SELECT stbox 'STBOX((1.0, 2.0), (1.0, 2.0))';
-- Only value dimension with X, Y, and Z coordinates
SELECT stbox 'STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))';
-- Both value (with X and Y coordinates) and time dimensions
SELECT stbox 'STBOX T((1.0, 2.0, 2001-01-03), (1.0, 2.0, 2001-01-03))';
-- Both value (with X, Y, and Z coordinates) and time dimensions
SELECT stbox 'STBOX ZT((1.0, 2.0, 3.0, 2001-01-04), (1.0, 2.0, 3.0, 2001-01-04))';
-- Only time dimension
SELECT stbox 'STBOX T(( , , 2001-01-03), ( , , 2001-01-03))';
-- Only value dimension with X, Y, and Z geodetic coordinates
SELECT stbox 'GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))';
-- Both value (with X, Y and Z geodetic coordinates) and time dimension
SELECT stbox 'GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-04), (1.0, 2.0, 3.0, 2001-01-04))';
-- Only time dimension for geodetic box
SELECT stbox 'GEODSTBOX T(( , , 2001-01-03), ( , , 2001-01-03))';
-- SRID is given
SELECT stbox 'SRID=5676;STBOX T((1.0, 2.0, 2001-01-04), (1.0, 2.0, 2001-01-04))';
SELECT stbox 'SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))';
				</programlisting>
			</para>
		</sect1>

		<sect1>
			<title>Constructor Functions</title>

			<para>Type <varname>tbox</varname> has several constructor functions depending on whether the value and/or the time dimensions are given. These functions have two arguments for the minimum and maximum <varname>float</varname> values and/or two arguments for the minimum and maximum <varname>timestamptz</varname> values.
			</para>

			<itemizedlist>
				<listitem>
					<para>Constructor for <varname>tbox</varname></para>
					<para><varname>tbox(float, float): tbox</varname></para>
					<para><varname>tboxt(timestamptz, timestamptz): tbox</varname></para>
					<para><varname>tbox(float, timestamptz, float, timestamptz): tbox</varname></para>
					<programlisting>
-- Both value and time dimensions
SELECT tbox(1.0, '2001-01-01', 2.0, '2001-01-02');
-- Only value dimension
SELECT tbox(1.0, 2.0);
-- Only time dimension
SELECT tboxt('2001-01-01', '2001-01-02');
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>Type <varname>stbox</varname> has several constructor functions depending on whether the coordinates and/or the time dimensions are given. Furthermore, the coordinates can be 2D or 3D and can be either Cartesian or geodetic. These functions have several arguments for the minimum and maximum coordinate values and/or two arguments for the minimum and maximum <varname>timestamptz</varname> values. The SRID can be specified in an optional last argument. If not given, a value 0 (respectively 4326) is assumed by default for planar (respectively geodetic) boxes.
			</para>

			<itemizedlist>
				<listitem>
					<para>Constructor for <varname>stbox</varname></para>
					<para><varname>stbox(float, float, float, float, integer): stbox</varname></para>
					<para><varname>stbox(float, float, float, float, float, float, integer): stbox</varname></para>
					<para><varname>stbox(float, float, float, timestamptz, float, float, float, timestamptz, integer): stbox</varname></para>
					<para><varname>stboxt(timestamptz, timestamptz, integer): stbox</varname></para>
					<para><varname>stbox(float, float, timestamptz, float, float, timestamptz, integer): stbox</varname></para>
					<programlisting>
-- Only value dimension with X and Y coordinates
SELECT stbox(1.0, 2.0, 1.0, 2.0);
-- Only value dimension with X, Y, and Z coordinates
SELECT stbox(1.0, 2.0, 3.0, 1.0, 2.0, 3.0);
-- Only value dimension with X, Y, and Z coordinates and SRID
SELECT stbox(1.0, 2.0, 3.0, 1.0, 2.0, 3.0);
-- Both value (with X and Y coordinates) and time dimensions
SELECT stboxt(1.0, 2.0, '2001-01-03', 1.0, 2.0, '2001-01-03');
-- Both value (with X, Y, and Z coordinates) and time dimensions
SELECT stbox(1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-04');
-- Only time dimension
SELECT stboxt('2001-01-03', '2001-01-03');
-- Only value dimension with X, Y, and Z geodetic coordinates
SELECT geodstbox(1.0, 2.0, 3.0, 1.0, 2.0, 3.0);
--  Both value (with X, Y, and Z geodetic coordinates) and time dimensions
SELECT geodstbox(1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-03');
-- Only time dimension for geodetic box
SELECT geodstboxt('2001-01-03', '2001-01-03');
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Casting</title>
	
			<itemizedlist>
				<listitem>
					<para>Converts a <varname>tbox</varname> to another type</para>
					<para><varname>tbox::floatrange</varname>, <varname>tbox::period</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2000-01-01),(2,2000-01-02))'::floatrange;
-- "[1,2]"
SELECT tbox 'TBOX((1,2000-01-01),(2,2000-01-02))'::period;
-- "[2000-01-01, 2000-01-02]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Converts another type to a <varname>tbox</varname></para>
					<para><varname>int::tbox</varname>, <varname>float::tbox</varname>, <varname>numeric::tbox</varname>, <varname>timestamptz::tbox</varname>, <varname>timestampset::tbox</varname>,</para>
					<para><varname>period::tbox</varname>, <varname>periodset::tbox</varname>, <varname>tint::tbox</varname>, <varname>tfloat::tbox</varname>, <varname>intrange::tbox</varname>, <varname>floatrange::tbox</varname></para>
					<programlisting>
SELECT floatrange '(1.0, 2.0)'::tbox;
-- "TBOX((1,),(2,))"
SELECT periodset '{(2001-01-01,2001-01-02), (2001-01-03,2001-01-04)}'::tbox;
-- "TBOX((,2001-01-01),(,2001-01-04))"
					</programlisting>
				</listitem>

				<listitem>
					<para>Converts an <varname>stbox</varname> to a another type</para>
					<para><varname>stbox::period</varname>, <varname>stbox::box2d</varname>, <varname>stbox::box3d</varname></para>
					<programlisting>
SELECT stbox 'STBOX T((1.0, 2.0, 2001-01-01), (3.0, 4.0, 2001-01-03))'::period;
-- "[2000-01-01, 2000-01-03]"
SELECT stbox 'STBOX Z((1 1 1),(3 3 3))'::box2d;
-- "BOX(1 1,3 3)"
SELECT stbox 'STBOX Z((1 1 1),(3 3 3))'::box3d;
-- "BOX3D(1 1 1,3 3 3)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Converts another type to an <varname>stbox</varname></para>
					<para><varname>geometry::stbox</varname>, <varname>geography::stbox</varname>, <varname>timestamptz::stbox</varname>, <varname>timestampset::stbox</varname>, <varname>period::stbox</varname>,</para>
					<para><varname>periodset::stbox</varname>, <varname>tgeompoint::stbox</varname>, <varname>tgeogpoint::stbox</varname></para>
					<programlisting>
select geometry 'Linestring(1 1,2 2)'::stbox;
-- "STBOX((1,1),(2,2))"
SELECT periodset '{(2001-01-01,2001-01-02), (2001-01-03,2001-01-04)}'::stbox;
-- "STBOX T((,,2001-01-01),(,,2001-01-04))"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Accessor Functions</title>

			<itemizedlist>
				<listitem>
					<para>Minimum X value</para>
					<para><varname>Xmin({tbox, stbox}): float</varname></para>
					<programlisting>
SELECT Xmin(tbox 'TBOX((1.0, 2000-01-01), (3.0, 2000-01-03))');
-- 1
SELECT Xmin(stbox 'STBOX((1.0, 2.0), (3.0, 4.0))');
-- 1
					</programlisting>
				</listitem>

				<listitem>
					<para>Maximum X value</para>
					<para><varname>Xmax({tbox, stbox}): float</varname></para>
					<programlisting>
SELECT Xmax(tbox 'TBOX((1.0, 2000-01-01), (3.0, 2000-01-03))');
-- 3
SELECT Xmax(stbox 'STBOX((1.0, 2.0), (3.0, 4.0))');
-- 3
					</programlisting>
				</listitem>

				<listitem>
					<para>Minimum Y value</para>
					<para><varname>Ymin(stbox): float</varname></para>
					<programlisting>
SELECT Ymin(stbox 'STBOX((1.0, 2.0), (3.0, 4.0))');
-- 2
					</programlisting>
				</listitem>

				<listitem>
					<para>Maximum Y value</para>
					<para><varname>Ymax(stbox): float</varname></para>
					<programlisting>
SELECT Ymax(stbox 'STBOX((1.0, 2.0), (3.0, 4.0))');
-- 4
					</programlisting>
				</listitem>

				<listitem>
					<para>Minimum Z value</para>
					<para><varname>Zmin(stbox): float</varname></para>
					<programlisting>
SELECT Zmin(stbox 'STBOX Z((1.0, 2.0, 3.0), (4.0, 5.0, 6.0))');
-- 3
					</programlisting>
				</listitem>

				<listitem>
					<para>Maximum Z value</para>
					<para><varname>Zmax(stbox): float</varname></para>
					<programlisting>
SELECT Zmax(stbox 'STBOX Z((1.0, 2.0, 3.0), (4.0, 5.0, 6.0))');
-- 6
					</programlisting>
				</listitem>

				<listitem>
					<para>Minimum timestamp</para>
					<para><varname>Tmin({tbox, stbox}): timestamptz</varname></para>
					<programlisting>
SELECT Tmin(stbox 'GEODSTBOX T(( , , 2001-01-01), ( , , 2001-01-03))');
-- "2001-01-01"
					</programlisting>
				</listitem>

				<listitem>
					<para>Maximum timestamp</para>
					<para><varname>Tmax({tbox, stbox}): timestamptz</varname></para>
					<programlisting>
SELECT Tmax(stbox 'GEODSTBOX T(( , , 2001-01-01), ( , , 2001-01-03))');
-- "2001-01-03"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id ="modification_box_tyes">
			<title>Modification of Box Types</title>

			<para>The functions given next expand the bounding boxes on the value and the time dimension or set the precision of the value dimension. These functions raise an error if the corresponding dimension is not present.
			</para>
			<itemizedlist>
				<listitem>
					<para>Expand the value dimension of the bounding box by a float value</para>
					<para><varname>expandValue(tbox, float): tbox</varname>, <varname>expandSpatial(stbox, float): stbox</varname></para>
					<programlisting>
SELECT expandValue(tbox 'TBOX((1,2012-01-01),(2,2012-01-03))', 1);
-- "TBOX((0,2012-01-01),(3,2012-01-03))"
SELECT expandSpatial(stbox 'STBOX ZT((1,1,1,2012-01-01),(2,2,2,2012-01-03))', 1);
-- "STBOX ZT((0,0,0,2012-01-01),(3,3,3,2012-01-03))"
SELECT expandValue(tbox 'TBOX((,2012-01-01),(,2012-01-03))', 1);
-- The box must have value dimension
					</programlisting>
				</listitem>

				<listitem>
					<para>Expand the temporal dimension of the bounding box by a time interval</para>
					<para><varname>expandTemporal({tbox, stbox}, interval): {tbox, stbox}</varname></para>
					<programlisting>
SELECT expandTemporal(tbox 'TBOX((1,2012-01-01),(2,2012-01-03))', interval '1 day');
-- "TBOX((1,2011-12-31),(2,2012-01-04))"
SELECT expandTemporal(stbox 'STBOX ZT((1,1,1,2012-01-01),(2,2,2,2012-01-03))',
	interval '1 day');
-- "STBOX ZT((1,1,1,2011-12-31),(2,2,2,2012-01-04))"
					</programlisting>
				</listitem>

				<listitem>
					<para>Round the value or the coordinates to a number of decimal places</para>
					<para><varname>setPrecision({tbox, stbox}, int): {tbox, stbox}</varname></para>
					<programlisting>
SELECT setPrecision(tbox 'TBOX((1.12345, 2000-01-01), (2.12345, 2000-01-02))', 2);
-- "TBOX((1.12,2000-01-01),(2.12,2000-01-02))"
SELECT setPrecision(stbox 'STBOX T((1.12345, 1.12345, 2000-01-01),
	(2.12345, 2.12345, 2000-01-02))', 2);
-- "STBOX T((1.12,1.12,2000-01-01),(2.12,2.12,2000-01-02))"
					</programlisting>
				</listitem>

			</itemizedlist>
		</sect1>

		<sect1 id ="srid_box_tyes">
			<title>Spatial Reference System Functions</title>

			<itemizedlist>
				<listitem>
					<para>SRID</para>
					<para><varname>SRID(stbox): int</varname></para>
					<programlisting>
SELECT SRID(stbox 'STBOX ZT((1.0, 2.0, 3.0, 2000-01-01), (4.0, 5.0, 6.0, 2000-01-02))');
-- 0
SELECT SRID(stbox 'SRID=5676;STBOX T((1.0, 2.0, 2000-01-01), (4.0, 5.0, 2000-01-02))');
-- 5676
SELECT SRID(geodstbox 'GEODSTBOX T((, , 2000-01-01), (, , 2000-01-02))');
-- 4326
					</programlisting>
				</listitem>

				<listitem>
					<para>Set the spatial reference identifier</para>
					<para><varname>setSRID(stbox): stbox</varname></para>
					<programlisting>
SELECT setSRID(stbox 'STBOX ZT((1.0, 2.0, 3.0, 2000-01-01),
	(4.0, 5.0, 6.0, 2000-01-02))', 5676);
-- "SRID=5676;STBOX ZT((1,2,3,2000-01-01),(4,5,6,2000-01-02))"
					</programlisting>
					</listitem>

				<listitem>
					<para>Transform to a different spatial reference</para>
					<para><varname>transform(stbox, integer): stbox</varname></para>
					<programlisting>
SELECT transform(stbox 'SRID=4326;STBOX T((2.340088, 49.400250, 2000-01-01),
	(6.575317, 51.553167, 2000-01-02))', 3812);
-- "SRID=3812;STBOX T((502773.429980817,511805.120401577,2000-01-01),
	(803028.908264815,751590.742628986,2000-01-02))"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Bounding Box Operators</title>
			<para>These operators test whether the bounding boxes satisfy the predicate and result in a Boolean value.</para>

			<para>A first set of operators consider the relative position of the bounding boxes. The operators <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname> consider the value dimension for the <varname>tbox</varname> type and the X coordinates for the <varname>stbox</varname> type, the operators <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, and <varname>|&amp;&gt;</varname> consider the Y coordinates for the <varname>stbox</varname> type, the operators <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, and <varname>/&amp;&gt;</varname> consider the Z coordinates for the <varname>stbox</varname> type, and the operators <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname>, and <varname>#&amp;&gt;</varname> consider the time dimension for both <varname>tbox</varname> and <varname>stbox</varname> types. The operators raise an error if the boxes do not have both the required dimension.</para>

			<para>The operators for the value dimension of the <varname>tbox</varname> type are given next.</para>

			<itemizedlist>
				<listitem>
					<para>Is the first bounding box always strictly less than the second one?</para>
					<para><varname>tbox &lt;&lt; tbox: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2012-01-01),(2,2012-01-02))' &lt;&lt;
	tbox 'TBOX((3,2012-01-03),(4,2012-01-04))';
-- true
SELECT tbox 'TBOX((1,2012-01-01),(2,2012-01-02))' &lt;&lt;
	tbox 'TBOX((,2012-01-03),(,2012-01-04))';
-- ERROR:  Boxes must have X dimension
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box always strictly greater than the second one?</para>
					<para><varname>tbox &gt;&gt; tbox: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((3,2012-01-03),(4,2012-01-04))' &gt;&gt;
	tbox 'TBOX((1,2012-01-01),(2,2012-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box never greater than the second one?</para>
					<para><varname>tbox &amp;&lt; tbox: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2012-01-01),(4,2012-01-04))' &amp;&lt;
	tbox 'TBOX((3,2012-01-03),(4,2012-01-04))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box never less than the second one?</para>
					<para><varname>tbox &amp;&gt; tbox: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2012-01-01),(2,2012-01-02))' &amp;&gt;
	tbox 'TBOX((1,2012-01-01),(4,2012-01-04))';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>
			<para>The operators for the value dimension of the <varname>stbox</varname> type are given next.</para>

			<itemizedlist>
				<listitem>
					<para>Is the first bounding box strictly to the left of the second one?</para>
					<para><varname>stbox &lt;&lt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(2,2,2))' &lt;&lt; stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly to the right of the second one?</para>
					<para><varname>stbox &gt;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' &gt;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend to the right of the second one?</para>
					<para><varname>stbox &amp;&lt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(4,4,4))' &amp;&lt; stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend to the left of the second one?</para>
					<para><varname>stbox &amp;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' &amp;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly below of the second one?</para>
					<para><varname>stbox &lt;&lt;| stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(2,2,2))' &lt;&lt;| stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly above of the second one?</para>
					<para><varname>stbox |&gt;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' |&gt;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend above of the second one?</para>
					<para><varname>stbox &amp;&lt;| stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(4,4,4))' &amp;&lt;| stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend below of the second one?</para>
					<para><varname>stbox |&amp;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' |&amp;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly in front of the second one?</para>
					<para><varname>stbox &lt;&lt;/ stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(2,2,2))' &lt;&lt;/ stbox 'STBOX Z((3,3,3),(4,4,4))';
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly back of the second one?</para>
					<para><varname>stbox /&gt;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' /&gt;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend in front of the second one?</para>
					<para><varname>stbox &amp;&lt;/ stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(4,4,4))' &amp;&lt;/ stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend back of the second one?</para>
					<para><varname>stbox /&amp;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' /&amp;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The operators for the time dimension of the <varname>tbox</varname> and <varname>stbox</varname> types are as follows.</para>
			<itemizedlist>
				<listitem>
					<para>Is the first bounding box always before of the second one?</para>
					<para><varname>{tbox, stbox} &lt;&lt;# {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2000-01-01),(2,2000-01-02))' &lt;&lt;#
	tbox 'TBOX((3,2000-01-03),(4,2000-01-04)))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box always after of the second one?</para>
					<para><varname>{tbox, stbox} #&gt;&gt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX T((3,3,2000-01-03),(4,4,2000-01-04))'  #&gt;&gt;
	stbox 'STBOX T((1,1,2000-01-01),(2,2,2000-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box never after of the second one?</para>
					<para><varname>{tbox, stbox} &amp;&lt;# {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2000-01-01),(4,2000-01-04))' &amp;&lt;#
	tbox 'TBOX((3,2000-01-03),(4,2000-01-04)))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box never before of the second one?</para>
					<para><varname>{tbox, stbox} #&amp;&gt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX T((1,1,2000-01-01),(3,3,2000-01-03))' #&amp;&gt;
	stbox 'STBOX T((3,3,2000-01-03),(4,4,2000-01-04))';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>Another set of operators consider the topological relationships between the bounding boxes. There are five topological operators: overlaps (<varname>&amp;&amp;</varname>), contains (<varname>@&gt;</varname>), contained (<varname>&lt;@</varname>), adjacent (<varname>-|-</varname>), and same (<varname>~=</varname>). The operators verify the topological relationship taking into account the value and/or the time dimension for as many dimensions that are present on both arguments.</para>

			<para>The topological operators for temporal alphanumeric types are given next.</para>

			<itemizedlist>
				<listitem>
					<para>Does the bounding boxes overlap?</para>
					<para><varname>{tbox, stbox} &amp;&amp; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(3,2001-01-03))' &amp;&amp;
	tbox 'TBOX((2,2001-01-02),(4,2001-01-04))';
-- true
SELECT stbox 'STBOX T((1,1,2001-01-01),(2,2,2001-01-02))'&amp;&amp;
	stbox 'STBOX T((,2001-01-02),(,2001-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Does the first bounding box contains the second one?</para>
					<para><varname>{tbox, stbox} @&gt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(4,2001-01-04))' @&gt;
	tbox 'TBOX((2,2001-01-01),(3,2001-01-02))';
-- true
SELECT stbox 'STBOX Z((1,1,1),(3,3,3))' @&gt;
	stbox 'STBOX T((1,1,2001-01-01),(2,2,2001-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box contained in the second one?</para>
					<para><varname>{tbox, stbox} &lt;@ {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(2,2001-01-02))' &lt;@
	tbox 'TBOX((1,2001-01-01),(2,2001-01-02))';
-- true
SELECT stbox 'STBOX T((1,1,2001-01-01),(2,2,2001-01-02))' &lt;@
	stbox 'STBOX ZT((1,1,1,2001-01-01),(2,2,2,2001-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Are the bounding boxes adjacent? Two boxes are adjacent if they share <emphasis>n</emphasis> dimensions and their intersection is at most of <emphasis>n</emphasis>-1 dimensions.</para>
					<para><varname>{tbox, stbox} -|- {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(2,2001-01-02))' -|-
	tbox 'TBOX((,2001-01-02),(,2001-01-03))';
-- true
SELECT stbox 'STBOX T((1,1,2001-01-01),(3,3,2001-01-03))' -|-
	stbox 'STBOX T((2,2,2001-01-03),(4,4,2001-01-04))';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Are the bounding boxes equal in common dimensions?</para>
					<para><varname>{tbox, stbox} ~= {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(2,2001-01-02))' ~=
	tbox 'TBOX((,2001-01-01),(,2001-01-02))';
-- true
SELECT stbox 'STBOX T((1,1,2001-01-01),(3,3,2001-01-03))' ~=
	stbox 'STBOX Z((1,1,1),(3,3,3))';
-- true
					</programlisting>
				</listitem>

			</itemizedlist>

			<para>Finally, the set operators for box types are union (<varname>+</varname>) and intersection (<varname>*</varname>). In the case of union, the operands must have exactly the same dimensions, otherwise an error is raided. Furthermore, if the operands do not overlap on all the dimensions and error is raised, since in this would result in a box with disjoint values, which cannot be represented.  The operator computes the union on all dimensions that are present in both arguments. In the case of intersection, the operands must have at least one common dimension, otherwise an error is raised. The operator computes the intersection on all dimensions that are present in both arguments.</para>

			<itemizedlist>
				<listitem>
					<para>Union</para>
					<para><varname>tbox + tbox: tbox</varname>, <varname>stbox + stbox: stbox</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(3,2001-01-03))' +
	tbox 'TBOX((2,2001-01-02),(4,2001-01-04))';
-- "TBOX((1,2001-01-01),(4,2001-01-04))"
SELECT stbox 'STBOX ZT((1,1,1,2001-01-01),(2,2,2,2001-01-02))' +
	stbox 'STBOX T((2,2,2001-01-01),(3,3,2001-01-03))';
-- ERROR:  Boxes must be of the same dimensionality
SELECT tbox 'TBOX((1,2001-01-01),(3,2001-01-02))' +
	tbox 'TBOX((2,2001-01-03),(4,2001-01-04))';
-- ERROR:  Result of box union would not be contiguous
					</programlisting>
				</listitem>

				<listitem>
					<para>Intersection</para>
					<para><varname>tbox * tbox: tbox</varname>, <varname>stbox * stbox: stbox</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(3,2001-01-03))' *
	tbox 'TBOX((,2001-01-02),(,2001-01-04))';
-- "TBOX((,2001-01-02),(,2001-01-03))"
SELECT stbox 'STBOX ZT((1,1,1,2001-01-01),(3,3,3,2001-01-02))' *
	stbox 'STBOX((2,2),(4,4))';
-- "STBOX((2,2),(3,3))"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>
	</chapter>

	<chapter id="manipulating_temporal_types">
		<title>Manipulating Temporal Types</title>
		<para>We present next the functions and operators for temporal types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this, we use the following notation:</para>

		<itemizedlist>
			<listitem>
				<para><varname>ttype</varname> represents any temporal type,</para>
			</listitem>

			<listitem>
				<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>tnumber</varname> represents any temporal numeric type, that is, <varname>tint</varname> or <varname>tfloat</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>torder</varname> represents any temporal type whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>tpoint</varname> represents a temporal point type, that is, <varname>tgeompoint</varname> or <varname>tgeogpoint</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>ttypeinst</varname> represents any temporal type with instant duration,</para>
			</listitem>

			<listitem>
				<para><varname>ttypei</varname> represents any temporal type with instant set duration,</para>
			</listitem>

			<listitem>
				<para><varname>ttypeseq</varname> represents any temporal type with sequence duration,</para>
			</listitem>

			<listitem>
				<para><varname>tdiscseq</varname> represents any temporal type with sequence duration and a discrete base type,</para>
			</listitem>

			<listitem>
				<para><varname>tcontseq</varname> represents any temporal type with sequence duration and a continuous base type,</para>
			</listitem>

			<listitem>
				<para><varname>ttypes</varname> represents any temporal type with sequence set duration,</para>
			</listitem>

			<listitem>
				<para><varname>base</varname> represents any base type of a temporal type, that is, <varname>bool</varname>, <varname>int</varname>, <varname>float</varname>, <varname>text</varname>, <varname>geometry</varname>, or <varname>geography</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>number</varname> represents any numeric base type, that is, <varname>int</varname> or <varname>float</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>numrange</varname> represents any numeric range of values, that is, either <varname>intrange</varname> or <varname>floatrange</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>geo</varname> represents either <varname>geometry</varname> or <varname>geography</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>point</varname> represents a <varname>geometry</varname> or a <varname>geography</varname> restricted to a point.</para>
			</listitem>

			<listitem>
				<para><varname>type[]</varname> represents an array of <varname>type</varname>.</para>
			</listitem>
		</itemizedlist>
				
		<para>A common way to generalize the traditional operations to the temporal types is to apply the operation at each instant, which yields a temporal value as result. In that case, the operation is only defined on the intersection of the emporal extents of the operands; if the temporal extents are disjoint, then the result is null. For example, the temporal comparison operators, such as <varname>#&lt;</varname>, test whether the values taken by their operands at each instant satisfy the condition and return a temporal Boolean. Examples of the various generalizations of the operators are given next.
			<programlisting>
-- Temporal comparison
SELECT tint '[2@2001-01-01, 2@2001-01-03)' #&lt; tfloat '[1@2001-01-01, 3@2001-01-03)';
-- "{[f@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}"
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt; tfloat '[3@2001-01-03, 1@2001-01-05)';
-- NULL
-- Temporal addition
SELECT tint '[1@2001-01-01, 1@2001-01-03)' + tint '[2@2001-01-02, 2@2001-01-05)';
-- "[3@2001-01-02, 3@2001-01-03)"
-- Temporal intersects
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
	geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))');
-- "{[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}"
-- Temporal distance
SELECT tgeompoint '[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-03 08:10:00)' &lt;-&gt;
	tgeompoint '[Point(0 0)@2001-01-02 08:05:00, Point(1 1)@2001-01-05 08:15:00)';
-- "[0.5@2001-01-02 08:05:00+00, 0.745184033794557@2001-01-03 08:10:00+00)"
			</programlisting>
		</para>
			
		<para>Another common requirement is to determine whether the operands ever or always satisfy a condition with respect to an operation. These can be obtained by applying the ever/always comparison operators. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Examples of ever and always comparison operators are given next.
			<programlisting>
-- Does the operands ever intersect?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
	geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))') ?= true;
-- true
-- Does the operands always intersect?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
	geometry 'Polygon((0 0,0 2,4 2,4 0,0 0))') %= true;
-- true
-- Is the left operand ever less than the right one ?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
	tfloat '[3@2001-01-01, 1@2001-01-03)') ?= true;
-- true
-- Is the left operand always less than the right one ?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
	tfloat '[2@2001-01-01, 4@2001-01-03)') %= true;
-- true
			</programlisting>
		For efficiency reasons, some common operations with the ever or the always semantics are natively provided. For example, the <varname>intersects</varname> function determines whether there is an instant at which the two arguments spatially intersect.</para>

		<para>We describe next the functions and operators for temporal types. For conciseness, in the examples we mostly use sequences composed of two instants.</para>

		<sect1 id ="input_output_temporal_tyes">
			<title>Input/Output of Temporal Types</title>
			<para>A temporal instant value is a couple of the form <varname>v@t</varname>, where <varname>v</varname> is a value of the base type and <varname>t</varname> is a <varname>timestamptz</varname> value. A temporal sequence value is a set of values <varname>v1@t1,...,vn@tn</varname> delimited by a lower and an upper bounds that can be inclusive (represented by &lsquo;<varname>[</varname>' and &lsquo;<varname>]</varname>') or exclusive (represented by &lsquo;<varname>(</varname>' and &lsquo;<varname>)</varname>'). Examples of input of temporal unit values are as follows:
				<programlisting>
SELECT tbool 'true@2001-01-01 08:00:00';
SELECT tint '1@2001-01-01 08:00:00';
SELECT tfloat '1.5@2001-01-01 08:00:00';
SELECT ttext 'AAA@2001-01-01 08:00:00';
SELECT tgeompoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tgeogpoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tbool '[true@2001-01-01 08:00:00, true@2001-01-03 08:00:00]';
SELECT tint '[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00]';
SELECT tfloat '[2.5@2001-01-01 08:00:00, 3@2001-01-03 08:00:00, 1@2001-01-04 08:00:00]';
SELECT tfloat '[1.5@2001-01-01 08:00:00]';  -- Instant sequence
SELECT ttext '[BBB@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00]';
SELECT tgeompoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 0)@2017-01-01 08:05:00)';
SELECT tgeogpoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00,
	Point(0 0)@2017-01-01 08:10:00)';
				</programlisting>
			</para>
			
			<para>The temporal extent of a temporal instant value is a single instant while the temporal extent of temporal sequence value is a period defined by the first and last instants as well as the upper and lower bounds.</para>

			<para>A temporal set value is a set <varname>{v1,...,vn}</varname> where every <varname>vi</varname> is a temporal unit value of the corresponding type. Examples of input of temporal set values are as follows:
				<programlisting>
SELECT tbool '{true@2001-01-01 08:00:00, false@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00}';
SELECT tfloat '{1.0@2001-01-01 08:00:00, 2.0@2001-01-03 08:00:00}';
SELECT ttext '{AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00}';
SELECT tgeompoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tgeogpoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tbool '{[false@2001-01-01 08:00:00, false@2001-01-03 08:00:00),
	[true@2001-01-03 08:00:00], (false@2001-01-04 08:00:00, false@2001-01-06 08:00:00]}';
SELECT tint '{[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00),
	[2@2001-01-04 08:00:00, 3@2001-01-05 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tfloat '{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00, 2@2001-01-04 08:00:00,
	3@2001-01-06 08:00:00]}';
SELECT ttext '{[AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00, BBB@2001-01-04 08:00:00),
	[CCC@2001-01-05 08:00:00, CCC@2001-01-06 08:00:00]}';
SELECT tgeompoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
	[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
	[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
				</programlisting>
			The temporal extent of a temporal instant set value is a set of instants while the temporal extent of temporal sequence set value is a set of periods.</para>

			<para>Temporal values of sequence or sequence set duration whose base type is continuous may specify that the interpolation is stepwise. If this is not specified, it is supposed that the interpolation is linear by default.
				<programlisting>
-- Linear interpolation by default				
SELECT tfloat '[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';
SELECT tgeompoint '{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],
	[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';
-- Stepwise interpolation
SELECT tfloat 'Interp=Stepwise;[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';
SELECT tgeompoint 'Interp=Stepwise;{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],
	[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';
				</programlisting>
			For temporal values of sequence set duration all component sequences are supposed to be in the same interpolation, either stepwise or linear, as in the examples above.
			</para>

			<para>For temporal points, it is possible to specify the spatial reference identifier (SRID) using the Extended Well-Known text (EWKT) representation as follows: 
				<programlisting>
SELECT tgeompoint 'SRID=5435;[Point(0 0)@2000-01-01,Point(0 1)@2000-01-02]'
				</programlisting>
			All components geometries will then be of the given SRID. Furthermore, each component geometry can specify its SRID with the EWKT format as in the following example
				<programlisting>
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=5435;Point(0 1)@2000-01-02]'
				</programlisting>
			An error is raised if the component geometries are not all in the same SRID or if the SRID of a component geometry is different from the one of the temporal point
				<programlisting>
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=4326;Point(0 1)@2000-01-02]';
ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
SELECT tgeompoint 'SRID=5435;[SRID=4326;Point(0 0)@2000-01-01,
	SRID=4326;Point(0 1)@2000-01-02]'
ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
				</programlisting>
			</para>
		</sect1>

		<sect1 id="casting_temporal_types">
			<title>Casting</title>

			<para>A temporal value can be converted into a temporal value of a compatible type. This can be done using the notation <varname>CAST(ttype1 AS ttype2)</varname> or <varname>ttype1::ttype2</varname>.</para>
			<itemizedlist>
				<listitem>
					<para>Temporal integer to temporal float</para>
					<para><varname>tint::tfloat</varname></para>
					<programlisting>
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tfloat;
-- "[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]"
SELECT tint '[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]'::tfloat;
-- "Interp=Stepwise;[1@2000-01-01 00:00:00+01, 2@2000-01-03 00:00:00+01, 3@2000-01-05 00:00:00+01]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal float to temporal integer</para>
					<para><varname>tfloat::tint</varname></para>
					<programlisting>
SELECT tfloat 'Interp=Stepwise;[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- "[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]"
SELECT tfloat '[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- ERROR:  Cannot cast temporal float with linear interpolation to temporal integer
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal geography point to temporal geometry point</para>
					<para><varname>tgeogpoint::tgeompoint</varname></para>
					<programlisting>
SELECT asText((tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02)')::tgeogpoint);
-- "{[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal geometry point to temporal geography point</para>
					<para><varname>tgeompoint::tgeogpoint</varname></para>
					<programlisting>
SELECT asText((tgeogpoint 'Point(0 0)@2001-01-01')::tgeompoint);
-- "{POINT(0 0)@2001-01-01}"
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>A common way to store temporal points in PostGIS is to represent them as geometries of type <varname>LINESTRING M</varname> and abuse the M dimension to encode timestamps as seconds since 1970-01-01 00:00:00. These time-enhanced geometries, called trajectories, can be validated with the function <varname>ST_IsValidTrajectory</varname> to verify that the M value is growing from each vertex to the next. Trajectories can be manipulated with the functions <varname>ST_ClosestPointOfApproach</varname>, <varname>ST_DistanceCPA</varname>, and <varname>ST_CPAWithin</varname>. Temporal point values can be converted to/from PostGIS trajectories.</para>

			<itemizedlist>
				<listitem>
				<para>Temporal point to trajectory</para>
				<para><varname>tgeompoint::geometry</varname>, <varname>tgeogpoint::geography</varname></para>
				<programlisting>
SELECT ST_AsText((tgeompoint 'Point(0 0)@2001-01-01')::geometry);
-- "POINT M (0 0 978307200)"
SELECT ST_AsText((tgeompoint '{Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
	Point(1 1)@2001-01-03}')::geometry);
-- "MULTIPOINT M (0 0 978307200,1 1 978393600,1 1 978480000)"
SELECT ST_AsText((tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)')::geometry);
-- "LINESTRING M (0 0 978307200,1 1 978393600)"
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
	[Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
	[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
-- "MULTILINESTRING M ((0 0 978307200,1 1 978393600),(1 1 978480000,1 1 978566400),
(1 1 978652800,0 0 978739200))"
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
	[Point(1 1)@2001-01-03],
	[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
-- "GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))"
					</programlisting>
				</listitem>

				<listitem>
					<para>Trajectory to temporal point</para>
					<para><varname>geometry::tgeompoint</varname>, <varname>geography::tgeogpoint</varname></para>
					<programlisting>
SELECT asText(geometry 'LINESTRING M (0 0 978307200,0 1 978393600,
	1 1 978480000)'::tgeompoint);
-- "[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02, POINT(1 1)@2001-01-03]";
SELECT asText(geometry 'GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
	POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))'::tgeompoint);
-- "{[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02], [POINT(1 1)@2001-01-03],
	[POINT(1 1)@2001-01-05, POINT(0 0)@2001-01-06]}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="transformation_functions">
			<title>Transformation Functions</title>
			<para>A temporal value can be transformed to another duration. An error is raised if the durations are incompatible.</para>
			<itemizedlist>
				<listitem>
					<para>Transform a temporal value to another duration</para>
					<para><varname>ttypeinst(ttype): ttypeinst</varname>, <varname>ttypei(ttype): ttypei</varname>,</para>
					<para><varname>ttypeseq(ttype): ttypeseq</varname>, <varname>ttypes(ttype): ttypes</varname></para>
					<programlisting>
SELECT tboolinst(tbool '{[true@2001-01-01]}');
-- "t@2001-01-01 00:00:00+00"
SELECT tboolinst(tbool '{[true@2001-01-01, true@2001-01-02]}');
-- ERROR: Cannot transform input to a temporal instant
SELECT tbooli(tbool 'true@2001-01-01');
-- "{t@2001-01-01}"
SELECT tintseq(tint '1@2001-01-01');
-- "[1@2001-01-01]"
SELECT tfloats(tfloat '2.5@2001-01-01');
-- "{[2.5@2001-01-01]}"
SELECT tfloats(tfloat '{2.5@2001-01-01, 1.5@2001-01-02, 3.5@2001-01-02}');
-- "{[2.5@2001-01-01],[1.5@2001-01-02],[3.5@2001-01-03]}"
					</programlisting>
				</listitem>

				<listitem>
					<para> Transform a temporal value with continuous base type from stepwise to linear interpolation</para>
					<para><varname>toLinear(ttype) : ttype</varname></para>
				<programlisting>
SELECT toLinear(tfloat 'Interp=Stepwise;[1@2000-01-01, 2@2000-01-02, 
	1@2000-01-03, 2@2000-01-04]');
-- "{[1@2000-01-01, 1@2000-01-02), [2@2000-01-02, 2@2000-01-03), 
	[1@2000-01-03, 1@2000-01-04), [2@2000-01-04]}"
SELECT asText(toLinear(tgeompoint 'Interp=Stepwise;{[Point(1 1)@2000-01-01, 
	Point(2 2)@2000-01-02], [Point(3 3)@2000-01-05, Point(4 4)@2000-01-06]}'));
-- "{[POINT(1 1)@2000-01-01, POINT(1 1)@2000-01-02), [POINT(2 2)@2000-01-02], 
	[POINT(3 3)@2000-01-05, POINT(3 3)@2000-01-06), [POINT(4 4)@2000-01-06]}"
				</programlisting>
				</listitem>

				<listitem>
					<para>Append a temporal instant to a temporal value</para>
					<para><varname>appendInstant(ttype, ttypeinst) : ttype</varname></para>
				<programlisting>
SELECT appendInstant(tint '1@2000-01-01', tint '1@2000-01-02');
-- "{1@2000-01-01, 1@2000-01-02}"
SELECT appendInstant(tintseq(tint '1@2000-01-01'), tint '1@2000-01-02');
-- "[1@2000-01-01, 1@2000-01-02]"
SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2000-01-01, 
	Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}', 
	tgeompoint 'Point(1 1 1)@2000-01-06'));
-- "{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02], 
	[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}"
				</programlisting>
				</listitem>

			</itemizedlist>
		</sect1>

		<sect1>
			<title>Constructor Functions</title>

			<para>Each temporal type has a constructor function with the same name as the type and with a suffix for the duration, where the suffix &lsquo;<varname>inst</varname>&rsquo;, &lsquo;<varname>i</varname>&rsquo;, &lsquo;<varname>seq</varname>&rsquo;, and &lsquo;<varname>s</varname>&rsquo; correspond, respectively, to the durations instant, instant set, sequence, and sequence set. Using the constructor function is frequently more convenient than writing a literal constant. 
			</para>

			<para>
			The constructor functions for temporal instant values have one argument for the base type value and one argument for the <varname>timestamptz</varname> value.
			</para>
			<itemizedlist>
				<listitem>
					<para>Constructor for temporal types of instant duration</para>
					<para><varname>ttypeinst(base, timestamptz): ttypeinst</varname></para>
					<programlisting>
SELECT tboolinst(true, '2001-01-01 08:00:00');
SELECT tintinst(2, '2001-01-01 08:00:00');
SELECT tfloatinst(2.0, '2001-01-01 08:00:00');
SELECT ttextinst('AAA', '2001-01-01 08:00:00');
SELECT tgeompointinst('Point(0 0)', '2001-01-01 08:00:00');
SELECT tgeogpointinst('Point(1 1)', '2001-01-01 08:05:00');
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The constructor functions for temporal instant set values have a single argument, which is an array of values of the corresponding instant values.
			</para>
			<itemizedlist>
				<listitem>
					<para>Constructor for temporal types of instant set duration</para>
					<para><varname>ttypei(ttypeinst[]]): ttypei</varname></para>
					<programlisting>
SELECT tbooli(ARRAY[tbool 'true@2001-01-01 08:00:00', 'false@2001-01-01 08:05:00']);
SELECT tinti(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:05:00']);
SELECT tfloati(ARRAY[tfloat '1.0@2001-01-01 08:00:00)', '2.0@2001-01-01 08:05:00']);
SELECT ttexti(ARRAY[ttext 'AAA@2001-01-01 08:00:00', 'BBB@2001-01-01 08:05:00']);
SELECT tgeompointi(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
	'Point(0 1)@2001-01-01 08:05:00', 'Point(1 1)@2001-01-01 08:10:00']);
SELECT tgeogpointi(ARRAY[tgeogpoint 'Point(1 1)@2001-01-01 08:00:00',
	'Point(2 2)@2001-01-01 08:05:00']);
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The constructor function for temporal sequence values depends on whether the base type is continuous or not. In both cases the constructor has one argument for the array of values of the corresponding instant duration and two optional Boolean arguments stating, respectively, whether the left and right bounds are inclusive or exclusive. It the these arguments are not specified they are assumed to be true by default. In addition, the constructor function for temporal sequence values with continuous base type has an additional Boolean argument stating whether the interpolation is linear or not. It this argument is not specified it is assumed to be true by default.
			</para>
			<itemizedlist>
				<listitem>
					<para>Constructor for temporal types of sequence duration</para>
					<para><varname>tdiscseq(ttypeinst[], left_inc = true, right_inc = true}): tdiscseq</varname></para>
					<para><varname>tcontseq(ttypeinst[], left_inc = true, right_inc = true, linear = true}): tcontseq</varname></para>
				</listitem>
				<programlisting>
SELECT tboolseq(ARRAY[tbool 'true@2001-01-01 08:00:00', 'true@2001-01-03 08:05:00'],
	true, true);
SELECT tintseq(ARRAY[tintinst(2,'2001-01-01 08:00:00'),
	tintinst(2,'2001-01-01 08:10:00')], true, false);
SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
	'1@2001-01-03 08:10:00'], true, false);
SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
	'1@2001-01-03 08:10:00'], true, true, false);
SELECT ttextseq(ARRAY[ttextinst('AAA', '2001-01-01 08:00:00'),
	ttextinst('BBB', '2001-01-03 08:05:00'), ttextinst('BBB', '2001-01-03 08:10:00')]);
SELECT tgeompointseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
	'Point(0 1)@2001-01-03 08:05:00', 'Point(1 1)@2001-01-03 08:10:00']);
SELECT tgeogpointseq(ARRAY[tgeogpoint 'Point(0 0)@2001-01-01 08:00:00',
	'Point(0 0)@2001-01-03 08:05:00']);
				</programlisting>
			</itemizedlist>

			<para>The constructor functions for temporal sequence set values have a single argument, which is an array of values of the corresponding sequence values.
			</para>
			<itemizedlist>
				<listitem>
					<para>Constructor for temporal types of sequence set duration</para>
					<para><varname>ttypes(ttypeseq[]): ttypes</varname></para>
					<programlisting>
SELECT tbools(ARRAY[tbool '[false@2001-01-01 08:00:00, false@2001-01-01 08:05:00)',
	'[true@2001-01-01 08:05:00]','(false@2001-01-01 08:05:00, false@2001-01-01 08:10:00)']);
SELECT tints(ARRAY[tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:05:00,
	2@2001-01-01 08:10:00, 2@2001-01-01 08:15:00)']);
SELECT tfloats(ARRAY[tfloat '[1.0@2001-01-01 08:00:00, 2.0@2001-01-01 08:05:00,
	2.0@2001-01-01 08:10:00]', '[2.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT ttexts(ARRAY[ttext '[AAA@2001-01-01 08:00:00, AAA@2001-01-01 08:05:00)',
	'[BBB@2001-01-01 08:10:00, BBB@2001-01-01 08:15:00)']);
SELECT tgeompoints(ARRAY[tgeompoint '[Point(0 0)@2001-01-01 08:00:00,
	Point(0 1)@2001-01-01 08:05:00, Point(0 1)@2001-01-01 08:10:00)',
	'[Point(0 1)@2001-01-01 08:15:00, Point(0 0)@2001-01-01 08:20:00)']);
SELECT tgeogpoints(ARRAY[tgeogpointseq
	'[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-01 08:05:00)',
	'[Point(0 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)']);
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Accessor Functions</title>
			<itemizedlist>

				<listitem>
					<para>Memory size in bytes</para>
					<para><varname>memSize(ttype): integer</varname></para>
					<programlisting>
SELECT memSize(tint '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');
-- 280
					</programlisting>
				</listitem>

				<listitem>
					<para>Duration</para>
					<para><varname>duration(ttype): {'Instant', 'InstantSet', 'Sequence', 'SequenceSet'}</varname></para>
					<programlisting>
SELECT duration(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Sequence"
					</programlisting>
				</listitem>

				<listitem>
					<para>Interpolation</para>
					<para><varname>interpolation(ttype): {'Discrete', 'Stepwise', 'Linear'}</varname></para>
					<programlisting>
SELECT interpolation(tfloat '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');
-- "Discrete"
SELECT interpolation(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Stepwise"
SELECT interpolation(tfloat '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Linear"
SELECT interpolation(tfloat 'Interp=Stepwise;[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Stepwise"
SELECT interpolation(tgeompoint 'Interp=Stepwise;[Point(1 1)@2012-01-01, Point(2 2)@2012-01-02, Point(3 3)@2012-01-03]');
-- "Stepwise"
					</programlisting>
				</listitem>

				<listitem>
					<para>Value</para>
					<para><varname>getValue(ttypeinst): base</varname></para>
					<programlisting>
SELECT getValue(tint '1@2012-01-01');
-- 1
SELECT ST_AsText(getValue(tgeompoint 'Point(0 0)@2012-01-01'));
-- "POINT(0 0)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Values</para>
					<para><varname>getValues(ttype): {base[], floatrange[], geo}</varname></para>
					<programlisting>
SELECT getValues(tint '[1@2012-01-01, 2@2012-01-03]');
-- "{1,2}"
SELECT getValues(tfloat '[1@2012-01-01, 2@2012-01-03)');
-- "{[1,2)}"
SELECT getValues(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 4@2012-01-05)}');
-- "{[1,2),[3,4)}"
SELECT getValues(tfloat 'Interp=Stepwise;{[1@2012-01-01, 2@2012-01-02], 
	[3@2012-01-03, 4@2012-01-05]}');
-- "{"[1,1]","[2,2]","[3,3]","[4,4]"}"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
	[Point(0 1)@2012-01-03, Point(1 1)@2012-01-04)}'));
-- "LINESTRING(0 0,0 1,1 1)"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
	[Point(1 1)@2012-01-03, Point(2 2)@2012-01-04)}'));
-- "MULTILINESTRING((0 0,0 1),(1 1,2 2)"
SELECT ST_AsText(getValues(tgeompoint 'Interp=Stepwise;{[Point(0 0)@2012-01-01, 
	Point(0 1)@2012-01-02], [Point(0 1)@2012-01-03, Point(1 1)@2012-01-04]}'));
-- "GEOMETRYCOLLECTION(MULTIPOINT(0 0,0 1),MULTIPOINT(0 1,1 1))"
SELECT ST_AsText(getValues(tgeompoint '{Point(0 0)@2012-01-01, Point(0 1)@2012-01-02}'));
-- "MULTIPOINT(0 0,0 1)"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
	[Point(1 1)@2012-01-03, Point(1 1)@2012-01-04), 
	[Point(2 1)@2012-01-05, Point(2 2)@2012-01-06)}'));
-- "GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1),LINESTRING(2 1,2 2))"
					</programlisting>
				</listitem>

				<listitem>
					<para>Start value</para>
					<para><varname>startValue(ttype): base</varname></para>
					<programlisting>
SELECT startValue(tfloat '(1@2012-01-01, 2@2012-01-03)');
-- 1
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>End value</para>
					<para><varname>endValue(ttype): base</varname></para>
					<programlisting>
SELECT endValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- 5
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>Minimum value</para>
					<para><varname>minValue(torder): base</varname></para>
					<programlisting>
SELECT minValue(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- 1
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>Maximum value</para>
					<para><varname>maxValue(torder): base</varname></para>
					<programlisting>
SELECT maxValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- 5
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>Value range</para>
					<para><varname>valueRange(tnumber): numrange</varname></para>
					<programlisting>
SELECT valueRange(tfloat '{[2@2012-01-01, 1@2012-01-03), [4@2012-01-03, 6@2012-01-05)}');
-- "[1,6]"
SELECT valueRange(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "[1,3])"
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>Time</para>
					<para><varname>getTimestamp(ttypeinst): timestamptz</varname></para>
					<programlisting>
SELECT getTimestamp(tint '1@2012-01-01');
-- "2012-01-01"
					</programlisting>
				</listitem>

				<listitem>
					<para>Time</para>
					<para><varname>getTime(ttype): periodset</varname></para>
					<programlisting>
SELECT getTime(tint '[1@2012-01-01, 1@2012-01-15)');
-- "{[2012-01-01, 2012-01-15)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Timespan</para>
					<para><varname>timespan(ttype): interval</varname></para>
					<programlisting>
SELECT timespan(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-05)}');
-- "3 days"
					</programlisting>
				</listitem>

				<listitem>
					<para>Period on which the temporal value is defined ignoring the potential time gaps</para>
					<para><varname>period(ttype): period</varname></para>
					<programlisting>
SELECT period(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "[2012-01-01, 2012-01-05]"
SELECT period(tfloat '{[1@2012-01-01, 1@2012-01-02), [2@2012-01-03, 3@2012-01-04)}');
-- "[2012-01-01, 2012-01-04)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Number of distinct instants</para>
					<para><varname>numInstants(ttype): int</varname></para>
					<programlisting>
SELECT numInstants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3
					</programlisting>
				</listitem>

				<listitem>
					<para>Start instant</para>
					<para><varname>startInstant(ttype): ttypeinst</varname></para>
					<programlisting>
SELECT startInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), 
	(2@2000-01-02, 3@2000-01-03)}');
-- "1@2000-01-01"
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>End instant</para>
					<para><varname>endInstant(ttype): ttypeinst</varname></para>
					<programlisting>
SELECT endInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- "3@2000-01-03"
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>N-th distinct instant</para>
					<para><varname>instantN(ttype, int): ttypeinst</varname></para>
					<programlisting>
SELECT instantN(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}', 3);
-- "3@2000-01-03"
					</programlisting>
				</listitem>

				<listitem>
					<para>Distinct instants</para>
					<para><varname>instants(ttype): ttypeinst[]</varname></para>
					<programlisting>
SELECT instants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- "{"1@2000-01-01","2@2000-01-02","3@2000-01-03"}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Number of distinct timestamps</para>
					<para><varname>numTimestamps(ttype): int</varname></para>
					<programlisting>
SELECT numTimestamps(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}');
-- 3
					</programlisting>
				</listitem>

				<listitem>
					<para>Start timestamp</para>
					<para><varname>startTimestamp(ttype): timestamptz</varname></para>
					<programlisting>
SELECT startTimestamp(tfloat '[1@2012-01-01, 2@2012-01-03)');
-- "2012-01-01"
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>End timestamp</para>
					<para><varname>endTimestamp(ttype): timestamptz</varname></para>
					<programlisting>
SELECT endTimestamp(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}');
-- "2012-01-05"
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>N-th distinct timestamp</para>
					<para><varname>timestampN(ttype, int): timestamptz</varname></para>
					<programlisting>
SELECT timestampN(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}', 3);
-- "2012-01-05"
					</programlisting>
				</listitem>

				<listitem>
					<para>Distinct timestamps</para>
					<para><varname>timestamps(ttype): timestamptz[]</varname></para>
					<programlisting>
SELECT timestamps(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "{"2012-01-01", "2012-01-03", "2012-01-05"}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Number of sequences</para>
					<para><varname>numSequences({ttypeseq,ttypes}): int</varname></para>
					<programlisting>
SELECT numSequences(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}');
-- 2
					</programlisting>
				</listitem>

				<listitem>
					<para>Start sequence</para>
					<para><varname>startSequence({ttypeseq,ttypes}): ttypeseq</varname></para>
					<programlisting>
SELECT startSequence(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}');
-- "[1@2012-01-01, 2@2012-01-03)"
					</programlisting>
				</listitem>

				<listitem>
					<para>End sequence</para>
					<para><varname>endSequence({ttypeseq,ttypes}): ttypeseq</varname></para>
					<programlisting>
SELECT endSequence(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "[3@2012-01-03, 5@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem>
					<para>N-th sequence</para>
					<para><varname>sequenceN({ttypeseq,ttypes}, int): ttypeseq</varname></para>
					<programlisting>
SELECT sequenceN(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}', 2);
-- "[3@2012-01-03, 5@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Sequences</para>
					<para><varname>sequences({ttypeseq,ttypes}): ttypeseq[]</varname></para>
					<programlisting>
SELECT sequences(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "{"[1@2012-01-01, 2@2012-01-03)", "[3@2012-01-03, 5@2012-01-05)"}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Shift</para>
					<para><varname>shift(ttype): ttype</varname></para>
					<programlisting>
SELECT shift(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day'::interval);
-- "{1@2001-01-02, 2@2001-01-04, 1@2001-01-06}"
SELECT shift(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day'::interval);
-- "[1@2001-01-02, 2@2001-01-04]"
SELECT asText(shift(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03], 
	[Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'::interval));
-- "{[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-04], [
	POINT(2 2)@2001-01-05, POINT(1 1)@2001-01-06]}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Intersects the timestamp?</para>
					<para><varname>intersectsTimestamp(ttype, timestamptz): boolean</varname></para>
					<programlisting>
SELECT intersectsTimestamp(tint '[1@2012-01-01, 1@2012-01-15)', timestamptz '2012-01-03');
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Intersects the timestamp set?</para>
					<para><varname>intersectsTimestampSet(ttype, timestampset): boolean</varname></para>
					<programlisting>
SELECT intersectsTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
	timestampset '{2012-01-01, 2012-01-03}');
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Intersects the period?</para>
					<para><varname>intersectsPeriod(ttype, period): boolean</varname></para>
					<programlisting>
SELECT intersectsPeriod(tint '[1@2012-01-01, 1@2012-01-04)',
	period '[2012-01-01,2012-01-05)');
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Intersects the period set?</para>
					<para><varname>intersectsPeriodSet(ttype, periodset): boolean</varname></para>
					<programlisting>
SELECT intersectsPeriodSet(tbool '[t@2012-01-01, f@2012-01-15]',
	periodset '{[2012-01-01, 2012-01-03), [2012-01-05, 2012-01-07)}');
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Time-weighted average</para>
					<para><varname>twAvg(tnumber): float</varname></para>
					<programlisting>
SELECT twAvg(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-06)}');
-- 1.75
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Spatial Functions</title>
			<para>In the following, we specify with the symbol &Z_support; that the function supports 3D points and with the symbol &geography_support; that the function is available for geographies.</para>

			<itemizedlist>
				<listitem>
					<para>Well-Known Text (WKT) representation &Z_support; &geography_support;</para>
					<para><varname>asText({tpoint, tpoint[], geo[]}): {text, text[]}</varname></para>
					<programlisting>
SELECT asText(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');
-- "[POINT Z (0 0 0)@2012-01-01 00:00:00+00, POINT Z (1 1 1)@2012-01-02 00:00:00+00)"
SELECT asText(ARRAY[geometry 'Point(0 0)', 'Point(1 1)']);
-- "{"POINT(0 0)","POINT(1 1)"}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Extended Well-Known Text (EWKT) representation &Z_support; &geography_support;</para>
					<para><varname>asEWKT({tpoint, tpoint[], geo[]}): {text, text[]}</varname></para>
					<programlisting>
SELECT asEWKT(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');
-- "SRID=4326;[POINT Z (0 0 0)@2012-01-01 00:00:00+00, 
	POINT Z (1 1 1)@2012-01-02 00:00:00+00)"
SELECT asEWKT(ARRAY[geometry 'SRID=5676;Point(0 0)', 'SRID=5676;Point(1 1)']);
-- "{"SRID=5676;POINT(0 0)","SRID=5676;POINT(1 1)"}"
					</programlisting>
				</listitem>

				<listitem>
					<para>OGC's Moving Features JSON representation. &Z_support; &geography_support;</para>
					<para><varname>asMFJSON(tpoint, maxdecdigits int4 DEFAULT 15, options int4 DEFAULT 0): bytea</varname></para>
					<para>The last <varname>options</varname> argument could be used to add BBOX and/or CRS in MFJSON output:</para>
					<itemizedlist>
						<listitem><para>0: means no option (default value)</para></listitem>
						<listitem><para>1: MFJSON BBOX</para></listitem>
						<listitem><para>2: MFJSON Short CRS (e.g EPSG:4326)</para></listitem>
						<listitem><para>4: MFJSON Long CRS (e.g urn:ogc:def:crs:EPSG::4326)</para></listitem>
					</itemizedlist>
					<programlisting>
SELECT asMFJSON(tgeompoint 'Point(1 2)@2019-01-01 18:00:00.15+02');
-- "{"type":"MovingPoint","coordinates":[1,2],"datetimes":"2019-01-01T17:00:00.15+01",
	"interpolations":["Discrete"]}"
SELECT asMFJSON(tgeompoint 'SRID=4326;
	Point(50.813810 4.384260)@2019-01-01 18:00:00.15+02', 2, 3);
-- "{"type":"MovingPoint","crs":{"type":"name","properties":{"name":"EPSG:4326"}},
	"stBoundedBy":{"bbox":[50.81,4.38,50.81,4.38],
	"period":{"begin":"2019-01-01 17:00:00.15+01","end":"2019-01-01 17:00:00.15+01"}},
	"coordinates":[50.81,4.38],"datetimes":"2019-01-01T17:00:00.15+01",
	"interpolations":["Discrete"]}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Well-Known Binary (WKB) representation using either little-endian (NDR) or big-endian (XDR) encoding. If no encoding is specified, then NDR is used. &Z_support; &geography_support;</para>
					<para><varname>asBinary(tpoint, text default 'NDR'): bytea</varname></para>
					<programlisting>
SELECT asBinary(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "\001\001\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000"
					</programlisting>
				</listitem>

				<listitem>
					<para>Extended Well-Known Binary (EWKB) representation using either little-endian (NDR) or big-endian (XDR) encoding. If no encoding is specified, then NDR is used. &Z_support; &geography_support;</para>
					<para><varname>asEWKB(tpoint, text default 'NDR'): bytea</varname></para>
					<programlisting>
SELECT asEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "\0011\346\020\000\000\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000"
					</programlisting>
				</listitem>

				<listitem>
					<para>Hexadecimal Extended Well-Known Binary (EWKB) representation (as text) using either little-endian (NDR) or big-endian (XDR) encoding. If no encoding is specified, then NDR is used. &Z_support; &geography_support;</para>
					<para><varname>asHexEWKB(tpoint, text default 'NDR'): text</varname></para>
					<programlisting>
SELECT asHexEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "0131E6100000000000000000F03F0000000000000040000000000000084000FCE0136A580100"					
					</programlisting>
				</listitem>

				<listitem>
					<para>Input temporal point from OGC's Moving Features JSON representation. &Z_support; &geography_support;</para>
					<para><varname>fromMFJSON(text): tpoint</varname></para>
					<programlisting>
SELECT asEWKT(fromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
"properties":{"name":"EPSG:4326"}},"coordinates":[50.81,4.38],
"datetimes":"2019-01-01T17:00:00.15+01","interpolations":["Discrete"]}'));
-- "SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01"
					</programlisting>
				</listitem>

				<listitem>
					<para>Input temporal point from Extended Well-Known Binary (EWKB) representation. &Z_support; &geography_support;</para>
					<para><varname>fromEWKB(bytea): tpoint</varname></para>
					<programlisting>
SELECT asEWKT(fromEWKB(bytea 
'\0011\346\020\000\000\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000'));
-- "SRID=4326;POINT Z (1 2 3)@2012-01-01 00:00:00+01"
					</programlisting>
				</listitem>

				<listitem>
					<para>Spatial reference identifier &Z_support; &geography_support;</para>
					<para><varname>SRID(tpoint): integer</varname></para>
					<programlisting>
SELECT SRID(tgeompoint 'Point(0 0)@2012-01-01');
-- 0
					</programlisting>
				</listitem>

				<listitem>
					<para>Set the spatial reference identifier &Z_support; &geography_support;</para>
					<para><varname>setSRID(tpoint): tpoint</varname></para>
					<programlisting>
SELECT asEWKT(setSRID(tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)', 4326));
-- "SRID=4326;[POINT(0 0)@2012-01-01 00:00:00+00, POINT(1 1)@2012-01-02 00:00:00+00)"
					</programlisting>
					</listitem>

				<listitem>
					<para>Transform to a different spatial reference &Z_support; &geography_support;</para>
					<para><varname>transform(tpoint, integer): tpoint</varname></para>
					<programlisting>
SELECT asEWKT(transform(tgeompoint 'SRID=4326;Point(4.35 50.85)@2012-01-01', 3812));
-- "SRID=3812;POINT(648679.018035303 671067.055638114)@2012-01-01 00:00:00+00"
					</programlisting>
				</listitem>

				<listitem>
					<para>Round the coordinate values to a number of decimal places &Z_support; &geography_support;</para>
					<para><varname>setPrecision(tpoint, int): tpoint</varname></para>
					<programlisting>
SELECT asText(setPrecision(tgeompoint '{Point(1.12345 1.12345 1.12345)@2000-01-01, 
	Point(2 2 2)@2000-01-02, Point(1.12345 1.12345 1.12345)@2000-01-03}', 2));
-- "{POINT Z (1.12 1.12 1.12)@2000-01-01, POINT Z (2 2 2)@2000-01-02, 
	POINT Z (1.12 1.12 1.12)@2000-01-03}"
SELECT asText(setPrecision(tgeogpoint 'Point(1.12345 1.12345)@2000-01-01', 2));
-- "POINT(1.12 1.12)@2000-01-01"
					</programlisting>
				</listitem>

				<listitem>
					<para>Length traversed by the temporal point &Z_support; &geography_support;</para>
					<para><varname>length(tpoint): float</varname></para>
					<programlisting>
SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02]');
-- 1.73205080756888
SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
	Point(0 0 0)@2000-01-03]');
-- 3.46410161513775
SELECT length(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
	Point(0 0 0)@2000-01-03]');
-- 0
					</programlisting>
				</listitem>

				<listitem>
					<para>Cumulative length traversed by the temporal point &Z_support; &geography_support;</para>
					<para><varname>cumulativeLength(tpoint): tfloatseq</varname></para>
					<programlisting>
SELECT cumulativeLength(tgeompoint
	'{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03],
	[Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}');
-- "{[0@2000-01-01, 1.4142135623731@2000-01-02, 2.41421356237309@2000-01-03],
	[2.41421356237309@2000-01-04, 3.41421356237309@2000-01-05]}"
SELECT cumulativeLength(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
	Point(0 0 0)@2000-01-03]');
-- "Interp=Stepwise;[0@2000-01-01, 0@2000-01-02, 0@2000-01-03]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Speed of the temporal point in units per second &Z_support; &geography_support;</para>
					<para><varname>speed(tpoint): tfloats</varname></para>
					<programlisting>
SELECT speed(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03],
	[Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}') * 3600 * 24;
-- "Interp=Stepwise;{[1.4142135623731@2000-01-01, 1@2000-01-02, 1@2000-01-03], [1@2000-01-04, 1@2000-01-05]}"
SELECT speed(tgeompoint 'Interp=Stepwise;[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03]') * 3600 * 24;
-- "Interp=Stepwise;[0@2000-01-01 00:00:00+01, 0@2000-01-03 00:00:00+01]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Construct the bounding box from a geometry/geography and a timestamp or a period &Z_support; &geography_support;</para>
					<para><varname>stbox(geo, {timestamp, period}): stbox</varname></para>
					<programlisting>
SELECT stbox(geometry 'Linestring(1 1 1,2 2 2)', period '[2012-01-03, 2012-01-05]');
-- "STBOX ZT((1,1,1,2012-01-03),(2,2,2,2012-01-05))"
SELECT stbox(geography 'Linestring(1 1 1,2 2 2)', period '[2012-01-03, 2012-01-05]');
-- "GEODSTBOX T((0.99878198,0.017449748,0.017452406,2012-01-03),
  (0.99969542,0.034878239,0.034899499,2012-01-05))"
  					</programlisting>
				</listitem>

				<listitem>
					<para>Expand the bounding box of the temporal point by a float value &Z_support; &geography_support;</para>
					<para><varname>expandSpatial(tpoint, float): stbox</varname></para>
					<programlisting>
SELECT expandSpatial(tgeompoint '{[Point(1 1 1)@2012-01-01, Point(2 2 2)@2012-01-03),
	[Point(1 1 1)@2012-01-03, Point(3 3 3)@2012-01-05)}', 1);
-- "STBOX ZT((0,0,0,2012-01-01),(4,4,4,2012-01-05))"
					</programlisting>
				</listitem>

				<listitem>
					<para>Expand the bounding box of the temporal point by a time interval &Z_support; &geography_support;</para>
					<para><varname>expandTemporal(tpoint, interval): stbox</varname></para>
					<programlisting>
SELECT expandTemporal(tgeompoint '{[Point(1 1 1)@2012-01-01, Point(2 2 2)@2012-01-03),
	[Point(1 1 1)@2012-01-03, Point(3 3 3)@2012-01-05)}', interval '1 day');
-- "STBOX ZT((1,1,1,2011-12-31),(3,3,3,2012-01-06))"
					</programlisting>
				</listitem>

				<listitem>
					<para>Time-weighted centroid &Z_support;</para>
					<para><varname>twCentroid(tgeompoint): point</varname></para>
					<programlisting>
SELECT ST_AsText(twCentroid(tgeompoint '{[Point(0 0 0)@2012-01-01, 
	Point(0 1 1)@2012-01-02, Point(0 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)}'));
-- "POINT Z (0 0.666666666666667 0.666666666666667)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal azimuth &Z_support; &geography_support;</para>
					<para><varname>azimuth(tpoint): tfloat</varname></para>
					<programlisting>
SELECT degrees(azimuth(tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02,
	Point(1 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)'));
-- "Interp=Stepwise;{[45@2012-01-01, 45@2012-01-02], [225@2012-01-03, 225@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Instant of the first temporal point at which the two arguments are at the nearest distance. The function will only return the first instant that it finds if there are more than one. The resulting instant may be at an exclusive bound. &Z_support; &geography_support;</para>
					<para><varname>nearestApproachInstant({geo, tpoint}, {geo, tpoint}): tpoint</varname></para>
					<programlisting>
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "POINT(2 1)@2000-01-02"
SELECT asText(NearestApproachInstant(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "POINT(1 1)@2000-01-01"
SELECT asText(nearestApproachInstant(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
	Point(0 0 0)@2012-01-05)', tgeompoint '[Point(2 0 0)@2012-01-02, 
	Point(1 1 1)@2012-01-04, Point(2 2 2)@2012-01-06)'));
-- "POINT Z (0.75 0.75 0.75)@2012-01-03 12:00:00+00"
					</programlisting>
					<para>Function <varname>nearestApproachInstant</varname> generalizes the PostGIS function <varname>ST_ClosestPointOfApproach</varname>. First, the latter function requires both arguments to be trajectories. Second, function <varname>nearestApproachInstant</varname> returns both the point and the timestamp of the nearest point of approach while the PostGIS function only provides the timestamp as shown next.</para>
					<programlisting>
SELECT to_timestamp(ST_ClosestPointOfApproach(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)'::geometry,
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)'::geometry));
-- "2012-01-03 12:00:00+00"
					</programlisting>
				</listitem>

				<listitem>
					<para>Smallest distance ever between the two arguments &Z_support; &geography_support;</para>
					<para><varname>nearestApproachDistance({geo, tpoint}, {geo, tpoint}): float</varname></para>
					<programlisting>

SELECT NearestApproachDistance(tgeompoint '(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');
-- 1
SELECT NearestApproachDistance(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');
-- 1.4142135623731
SELECT nearestApproachDistance(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)',
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)');
-- "0.5"
					</programlisting>
					<para>Function <varname>nearestApproachDistance</varname> has an associated operator <varname>|=|</varname> that can be used for doing nearest neightbor searches using a GiST index (see <xref linkend="operators_temporal_types" />). This function corresponds to the function <varname>ST_DistanceCPA</varname> provided by PostGIS, altough the latter requires both arguments to be a trajectory.</para>
					<programlisting>
SELECT ST_DistanceCPA(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)'::geometry,
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)'::geometry);
-- "0.5"
					</programlisting>
				</listitem>

				<listitem>
					<para>Line connecting the nearest approach point between the two arguments. The function will only return the first line that it finds if there are more than one. &Z_support; &geography_support;</para>
					<para><varname>shortestLine({geo, tpoint}, {geo, tpoint}): geo</varname></para>
					<programlisting>
SELECT ST_AsText(shortestLine(tgeompoint '(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "LINESTRING(2 1,2 2)"
SELECT ST_AsText(shortestLine(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "LINESTRING(1 1,2 2)"
SELECT ST_AsText(shortestLine(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)',
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)'));
-- "LINESTRING Z (0.75 0.75 0.75,1.25 0.75 0.75)"
					</programlisting>
					<para>Function <varname>shortestLine</varname> can be used to obtain the result provided by the PostGIS function <varname>ST_CPAWithin</varname> when both arguments are trajectories as shown next.</para>
					<programlisting>
SELECT ST_Length(shortestLine(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)',
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)')) &lt;= 0.5;
-- true
SELECT ST_CPAWithin(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)'::geometry,
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)'::geometry, 0.5);
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Construct a geometry/geography with M measure from a temporal point and a temporal float &Z_support; &geography_support;</para>
					<para><varname>geoMeasure(geo, tfloat, segmentize = false): geo</varname></para>
					<para>The last <varname>segmentize</varname> argument states whether a resulting Linestring M value is transformed into a MultiLinestring M, where each component is a segment of two points.</para>

					<programlisting>
SELECT st_astext(geoMeasure(tgeompoint '{Point(1 1 1)@2000-01-01,
	Point(2 2 2)@2000-01-02}', '{5@2000-01-01, 5@2000-01-02}'));
-- "MULTIPOINT ZM (1 1 1 5,2 2 2 5)"
SELECT st_astext(geoMeasure(tgeogpoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
	[Point(1 1)@2000-01-03, Point(1 1)@2000-01-04]}',
	'{[5@2000-01-01, 5@2000-01-02],[7@2000-01-03, 7@2000-01-04]}'));
-- "GEOMETRYCOLLECTION M (LINESTRING M (1 1 5,2 2 5),POINT M (1 1 7))"
SELECT st_astext(geoMeasure(tgeompoint '[Point(1 1)@2000-01-01,
	Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]', '[5@2000-01-01, 7@2000-01-02, 5@2000-01-03]', true));
-- "MULTILINESTRING M ((1 1 5,2 2 5),(2 2 7,1 1 7))"
					</programlisting>
					<para>A typical visualization for mobility data is to show on a map the trajectory of the moving object using different colors according to the speed. <xref linkend="speed" /> shows the result of the query below using a color ramp in QGIS.</para>
					<programlisting>
WITH Temp(t) AS (
	SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-05,
			Point(2 0)@2012-01-08, Point(3 1)@2012-01-10, Point(4 0)@2012-01-11]'
)
SELECT ST_AsText(geoMeasure(t,  round(speed(t) * 3600 * 24, 2), true))
FROM Temp;
-- "MULTILINESTRING M ((0 0 0.35,1 1 0.35),(1 1 0.47,2 0 0.47),(2 0 0.71,3 1 0.71),
	(3 1 1.41,4 0 1.41))"
					</programlisting>
					<para>The following expression is used in QGIS to achieve this. The <varname>scale_linear</varname> function transforms the M value of each composing segment to the range [0, 1]. This value is then passed to the <varname>ramp_color</varname> function.</para>
					<programlisting>
ramp_color(
	'RdYlBu',
	scale_linear(
		m(start_point(geometry_n($geometry,@geometry_part_num))),
		0, 2, 0, 1
	)
)
				</programlisting>
					<figure id="speed" float="start"><title>Visualizing the speed of a moving object using a color ramp in QGIS.</title>
						<mediaobject>
							<imageobject><imagedata scale='30' fileref='images/speed.png' /></imageobject>
						</mediaobject>
					</figure>
				</listitem>

			</itemizedlist>
		</sect1>

		<sect1>
			<title>Restriction Functions</title>
			<para>These functions restrict the temporal value with respect to a value extent or a time extent.</para>

			<itemizedlist>
				<listitem>
					<para>Restrict to value</para>
					<para><varname>atValue(ttype, base): ttype</varname></para>
					<programlisting>
SELECT atValue(tint '[1@2012-01-01, 1@2012-01-15)', 1);
-- "[1@2012-01-01, 1@2012-01-15)"
SELECT asText(atValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',
	'Point(1 1 1)'));
-- "{[POINT Z (1 1 1)@2012-01-02]}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Restrict to values</para>
					<para><varname>atValues(ttype, base[]): ttype</varname></para>
					<programlisting>
SELECT atValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[1, 3, 5]);
-- "{[1@2012-01-01], [3@2012-01-03]}"
SELECT asText(atValues(tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)',
	ARRAY[geometry 'Point(0 0)', 'Point(1 1)']));
-- "{[POINT(0 0)@2012-01-01 00:00:00+00], [POINT(1 1)@2012-01-02 00:00:00+00]}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Restrict to range</para>
					<para><varname>atRange(tnumber, numrange): ttype</varname></para>
					<programlisting>
SELECT atRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[1,3]');
-- "[1@2012-01-01, 3@2012-01-03]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Restrict to ranges</para>
					<para><varname>atRanges(tnumber, numrange[]): ttype</varname></para>
					<programlisting>
SELECT atRanges(tfloat '[1@2012-01-01, 5@2012-01-05)', 
	ARRAY[floatrange '[1,2]', '[3,4]']);
-- "{[1@2012-01-01, 2@2012-01-02],[3@2012-01-03, 4@2012-01-04]}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Restrict to minimum value</para>
					<para><varname>atMin(torder): torder</varname></para>
					<programlisting>
SELECT atMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');
-- "{1@2012-01-01, 1@2012-01-05}"
SELECT atMin(tfloat '(1@2012-01-01, 3@2012-01-03]');
-- "{[1@2012-01-01]}"
SELECT atMin(tfloat '{(1@2012-01-01, 1@2012-01-03), (1@2012-01-03, 3@2012-01-05)}');
-- "{(1@2012-01-01, 1@2012-01-03)}"
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>Restrict to maximum value</para>
					<para><varname>atMax(torder): torder</varname></para>
					<programlisting>
SELECT atMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "{3@2012-01-05}"
SELECT atMax(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- "{[3@2012-01-03]}"
SELECT atMax(tfloat '{[2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');
-- "{[2@2012-01-01], [2@2012-01-03, 2@2012-01-05]}"
SELECT atMax(tfloat '{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}');
-- "{[3@2012-01-03]}"
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>Restrict to geometry</para>
					<para><varname>atGeometry(tgeompoint, geometry): tgeompoint</varname></para>
					<programlisting>
SELECT asText(atGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
	geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- "{"[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]"}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Value at timestamp</para>
					<para><varname>valueAtTimestamp(ttype, timestamptz): base</varname></para>
					<programlisting>
SELECT valueAtTimestamp(tfloat '[1@2012-01-01, 4@2012-01-04)', '2012-01-02');
-- "2"
					</programlisting>
				</listitem>

				<listitem>
					<para>Restrict to timestamp</para>
					<para><varname>atTimestamp(ttype, timestamptz): ttypeinst</varname></para>
					<programlisting>
SELECT atTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');
-- "2@2012-01-02"
					</programlisting>
				</listitem>

				<listitem>
					<para>Restrict to timestamp set</para>
					<para><varname>atTimestampSet(ttype, timestampset): {ttypeinst, ttypei}</varname></para>
					<programlisting>
SELECT atTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
	timestampset '{2012-01-01, 2012-01-03}');
-- "{1@2012-01-01, 1@2012-01-03}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Restrict to period</para>
					<para><varname>atPeriod(ttype, period): ttype</varname></para>
					<programlisting>
SELECT atPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',
	'[2012-01-02,2012-01-05)');
-- "{[2@2012-01-02, 3@2012-01-03), [3@2012-01-04, 2@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Restrict to period set</para>
					<para><varname>atPeriodSet(ttype, periodset): ttype</varname></para>
					<programlisting>
SELECT atPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',
	periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "{[1@2012-01-01, 1@2012-01-03),[1@2012-01-04, 1@2012-01-05)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Difference Functions</title>
			<para>These functions restrict the temporal value with respect to the complement of a value/range or a time extent.</para>
			<itemizedlist>
				<listitem>
				<para>Difference with value</para>
				<para><varname>minusValue(ttype, base): ttype</varname></para>
				<programlisting>
SELECT minusValue(tint '[1@2012-01-01, 2@2012-01-02, 2@2012-01-03)', 1);
-- "{[2@2012-01-02, 2@2012-01-03)}"
SELECT asText(minusValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',
	'Point(1 1 1)'));
-- "{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),
(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with values</para>
					<para><varname>minusValues(ttype, base[]): ttype</varname></para>
					<programlisting>
SELECT minusValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[2, 3]);
-- "{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 3@2012-01-03), 
	(3@2012-01-03, 4@2012-01-04)}"
SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2012-01-01, Point(3 3 3)@2012-01-04)',
	ARRAY[geometry 'Point(1 1 1)', 'Point(2 2 2)']));
-- "{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),
	(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03),
	(POINT Z (2 2 2)@2012-01-03, POINT Z (3 3 3)@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with range</para>
					<para><varname>minusRange(tnumber, numrange): ttype</varname></para>
					<programlisting>
SELECT minusRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[2,3]');
-- "{[1@2012-01-01, 2@2012-01-02), (3@2012-01-03, 4@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with ranges</para>
					<para><varname>minusRanges(tnumber, numrange[]): ttype</varname></para>
					<programlisting>
SELECT minusRanges(tfloat '[1@2012-01-01, 5@2012-01-05)', 
	ARRAY[floatrange '[1,2]', '[3,4]']);
-- "{(2@2012-01-02, 3@2012-01-03), (4@2012-01-04, 5@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with minimum value</para>
					<para><varname>minusMin(torder): torder</varname></para>
					<programlisting>
SELECT minusMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');
-- "{2@2012-01-03}"
SELECT minusMin(tfloat '[1@2012-01-01, 3@2012-01-03]');
-- "{(1@2012-01-01, 3@2012-01-03]}"
SELECT minusMin(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- "{(1@2012-01-01, 3@2012-01-03)}"
SELECT minusMin(tint '{[1@2012-01-01, 1@2012-01-03), (1@2012-01-03, 1@2012-01-05)}');
-- NULL
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with maximum value</para>
					<para><varname>minusMax(torder): torder</varname></para>
					<programlisting>
SELECT minusMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "{1@2012-01-01, 2@2012-01-03}"
SELECT minusMax(tfloat '[1@2012-01-01, 3@2012-01-03]');
-- "{[1@2012-01-01, 3@2012-01-03)}"
SELECT minusMax(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- "{(1@2012-01-01, 3@2012-01-03)}"
SELECT minusMax(tfloat '{[2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');
-- "{(2@2012-01-01, 1@2012-01-03)}"
SELECT minusMax(tfloat '{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}');
-- "{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with geometry</para>
					<para><varname>minusGeometry(tgeompoint, geometry): tgeompoint</varname></para>
					<programlisting>
SELECT asText(minusGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
	geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
 -- "{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02), (POINT(2 2)@2012-01-03,
POINT(3 3)@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with timestamp</para>
					<para><varname>minusTimestamp(ttype, timestamptz): ttype</varname></para>
					<programlisting>
SELECT minusTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');
-- "{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 5@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with timestamp set</para>
					<para><varname>minusTimestampSet(ttype, timestampset): ttype</varname></para>
					<programlisting>
SELECT minusTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
	timestampset '{2012-01-02, 2012-01-03}');
-- "{[1@2012-01-01, 1@2012-01-02), (1@2012-01-02, 1@2012-01-03), 
	(1@2012-01-03, 1@2012-01-15)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with period</para>
					<para><varname>minusPeriod(ttype, period): ttype</varname></para>
					<programlisting>
SELECT minusPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',
	'[2012-01-02,2012-01-05)');
-- "{[1@2012-01-01, 2@2012-01-02), [2@2012-01-05, 1@2012-01-06)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Difference with period set</para>
					<para><varname>minusPeriodSet(ttype, periodset): ttype</varname></para>
					<programlisting>
SELECT minusPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',
	periodset '{[2012-01-02, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "{[1@2012-01-01, 1@2012-01-02), [1@2012-01-03, 1@2012-01-04), 
	[1@2012-01-05, 1@2012-01-15)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="operators_temporal_types">
			<title>Comparison Operators</title>

			<para>The traditional comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right operands be of the same base type. Excepted equality  and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on temporal types. These operators compare the bounding boxes and if those are equal, then the comparison depends on the duration. For temporal instant values, they compare first the values and if those are equal, compare the timestamps. For temporal instant set and sequence values, they compare the first N instants, where N is the minimum of the number of composing instants of both values. Finally, for temporal sequence set values, they compare the first N sequence values, where N is the minimum of the number of composing sequences of both values.</para>

			<para>The equality and inequality operators consider the normal forms of the temporal types and the equivalent representation for different durations as shown next.
				<programlisting>
SELECT tint '{[1@2001-01-01, 1@2001-01-03), [1@2001-01-03, 1@2001-01-05)}' =
	tint '{[1@2001-01-01, 1@2001-01-05)}';
-- true
SELECT tfloat '{[1@2001-01-01, 2@2001-01-03), [2@2001-01-03, 3@2001-01-05)}' &lt;&gt;
	tfloat '{[1@2001-01-01, 3@2001-01-05)}';
-- false
SELECT tgeompoint '{[Point(1 1)@2001-01-01, Point(1 1)@2001-01-03),
	[Point(1 1)@2001-01-03, Point(1 1)@2001-01-05)}' =
	tgeompoint '{[Point(1 1)@2001-01-01, Point(1 1)@2001-01-05)}';
-- true
SELECT tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03),
	[Point(2 2)@2001-01-03, Point(3 3)@2001-01-05)}' &lt;&gt;
	tgeompoint '{[Point(1 1)@2001-01-01, Point(3 3)@2001-01-05)}';
-- false
SELECT tgeompoint '{[Point(1 1)@2001-01-01]}' = tgeompoint 'Point(1 1)@2001-01-01';
-- false
SELECT tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}' = 
	tgeompoint '{Point(1 1)@2001-01-01,Point(2 2)@2001-01-02}';
-- true
				</programlisting>
			</para>

			<itemizedlist>
				<listitem>
				<para>Equal</para>
				<para><varname>ttype = ttype: boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' = tint '[2@2012-01-03, 2@2012-01-05)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Not equal</para>
					<para><varname>ttype &lt;&gt; ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&gt; tint '[2@2012-01-03, 2@2012-01-05)'
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Less than</para>
					<para><varname>ttype &lt; ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt; tint '[2@2012-01-03, 2@2012-01-05)'
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Greater than</para>
					<para><varname>ttype &gt; ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt; tint '[2@2012-01-03, 2@2012-01-05)'
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Less than or equal to</para>
					<para><varname>ttype &lt;= ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;= tint '[2@2012-01-03, 2@2012-01-05)'
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Greater than or equal to</para>
					<para><varname>ttype &gt;= ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt;= tint '[2@2012-01-03, 2@2012-01-05)'
-- false
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Ever and Always Comparison Operators</title>
			<para>A possible generalization of the traditional comparison operators (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>,  etc.) to temporal types, is to determine whether the comparison is ever or always true. In this case, the result is a Boolean value. MobilityDB provides operators to test whether the comparison of a temporal value and a value of the base type is ever or always true. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Some examples are <varname>?=</varname>, <varname>%&lt;&gt;</varname>, or <varname>?&lt;=</varname>. Ever/always equality and non-equality are available for all temporal types, while ever/always inequalities are only available for temporal types whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>. The ever and always comparisons are inverse operators: for example, <varname>?=</varname> is the inverse of <varname>%&lt;&gt;</varname>, and <varname>?&gt;</varname> is the inverse of <varname>%&lt;=</varname>.</para>
			<itemizedlist>
				<listitem>
					<para>Is ever equal to the value?</para>
					<para><varname>ttype ?= base: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 2;
-- true
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' ?= 
	geometry 'Point(1 1)';
-- true
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>Is ever different from the value?</para>
					<para><varname>ttype ?&lt;&gt; base: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?&lt;&gt; 2;
-- false
SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' ?&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' ?&lt;&gt; 
	geometry 'Point(1 1)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is ever less than the value?</para>
					<para><varname>tnumber ?&lt; number: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' ?&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' ?&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Is ever greater than the value?</para>
					<para><varname>tnumber ?&gt; number: bool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-03, 1@2012-01-05)' ?&gt; 1;
-- "[f@2012-01-03, f@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Is ever less than or equal to the value?</para>
					<para><varname>tnumber ?&lt;= number: bool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' ?&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Is ever greater than or equal to the value?</para>
					<para><varname>tnumber ?&gt;= number: bool</varname></para>
					<programlisting>
SELECT 'AAA'::text ?&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03), 
	[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Is always equal to the value?</para>
					<para><varname>ttype %= base: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 2;
-- true
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' %= 
	geometry 'Point(1 1)';
-- true
					</programlisting>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
				</listitem>

				<listitem>
					<para>Is always different to the value?</para>
					<para><varname>ttype @&lt;&gt; base: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %&lt;&gt; 2;
-- false
SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' %&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' %&lt;&gt;
	geometry 'Point(1 1)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is always less than the value?</para>
					<para><varname>tnumber %&lt; number: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' %&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' %&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Is always greater than the value?</para>
					<para><varname>tnumber %&gt; number: bool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-03, 1@2012-01-05)' %&gt; 1;
-- "[f@2012-01-03, f@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Is always less than or equal to the value?</para>
					<para><varname>tnumber %&lt;= number: bool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' %&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Is always greater than or equal to the value?</para>
					<para><varname>tnumber %&gt;= number: bool</varname></para>
					<programlisting>
SELECT 'AAA'::text %&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03), 
	[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Temporal Comparison Operators</title>
			<para>Another possible generalization of the traditional comparison operators (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>,  etc.) to temporal types, is to determine whether the comparison is true or false at each instant. In this case, the result is a temporal Boolean. The temporal comparison operators are denoted by prefixing the traditional comparison operators with <varname>#</varname>. Some examples are <varname>#=</varname>  or <varname>#&lt;=</varname>. Temporal equality and non-equality are available for all temporal types, while temporal inequalities are only available for temporal types whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>.</para>

			<itemizedlist>
				<listitem>
					<para>Temporal equal</para>
					<para><varname>{base, ttype} #= {base, ttype}: tbool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 2@2012-01-04)' #= 3;
-- "{[f@2012-01-01, f@2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tint '[1@2012-01-01, 1@2012-01-04)';
-- "{[t@2012-01-01], (f@2012-01-01, f@2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tfloat '[4@2012-01-02, 1@2012-01-05)';
-- "{[f@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #= 
	geometry 'Point(1 1)';
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03)}"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #=
	tgeompoint '[Point(0 2)@2012-01-01, Point(2 0)@2012-01-03)';
-- "{[f@2012-01-01], (t@2012-01-01, t@2012-01-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal not equal</para>
					<para><varname>{base, ttype} #&lt;&gt; {base, ttype}: tbool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; 2;
-- "{[t@2012-01-01, f@2012-01-02], (t@2012-01-02, 2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; tint '[2@2012-01-02, 2@2012-01-05)';
-- "{[f@2012-01-02], (t@2012-01-02, t@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal less than</para>
					<para><varname>{base, torder} #&lt; {base, torder}: tbool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' #&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal greater than</para>
					<para><varname>{base, torder} #&gt; {base, torder}: tbool</varname></para>
					<programlisting>
SELECT 1 #&gt; tint '[1@2012-01-03, 1@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal less than or equal to</para>
					<para><varname>{base, torder} #&lt;= {base, torder}: tbool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' #&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal greater than or equal to</para>
					<para><varname>{base, torder} #&gt;= {base, torder}: tbool</varname></para>
					<programlisting>
SELECT 'AAA'::text #&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03), 
	[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>
				
		<sect1>
			<title>Mathematical Functions and Operators</title>

			<itemizedlist>
				<listitem>
					<para>Addition</para>
					<para><varname>{number, tnumber} + {number, tnumber}: tnumber</varname></para>
					<programlisting>
SELECT tint '[2@2012-01-01, 2@2012-01-04)' + 1.5;
-- "[3.5@2012-01-01, 3.5@2012-01-04)"
SELECT tint '[2@2012-01-01, 2@2012-01-04)' + tfloat '[1@2012-01-01, 4@2012-01-04)';
-- "[3@2012-01-01, 6@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' +
	tfloat '{[1@2012-01-01, 2@2012-01-02), [1@2012-01-02, 2@2012-01-04)}';
-- "{[2@2012-01-01, 4@2012-01-04), [3@2012-01-02, 6@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Substraction</para>
					<para><varname>{number, tnumber} - {number, tnumber}: tnumber</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' - tint '[2@2012-01-03, 2@2012-01-05)';
-- "[-1@2012-01-03, -1@2012-01-04)"
SELECT tfloat '[3@2012-01-01, 6@2012-01-04)' - tint '[2@2012-01-01, 2@2012-01-04)';
-- "[1@2012-01-01, 4@2012-01-04)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Multiplication</para>
					<para><varname>{number, tnumber} * {number, tnumber}: tnumber</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * 2;
-- "[2@2012-01-01, 8@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * tint '[2@2012-01-01, 2@2012-01-04)';
-- "[2@2012-01-01, 8@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 3@2012-01-03)' * '[3@2012-01-01, 1@2012-01-03)'
-- "{[3@2012-01-01, 4@2012-01-02, 3@2012-01-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Division</para>
					<para><varname>{number, tnumber} / {number, tnumber}: tnumber</varname></para>
					<para>The function will raise an error if the denominator will ever be equal to zero during the common timespan of the arguments.</para>
					<programlisting>
SELECT 2 / tfloat '[1@2012-01-01, 3@2012-01-04)';
-- "[2@2012-01-01, 1@2012-01-02 12:00:00+00, 0.666666666666667@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 5@2012-01-05)' / '[5@2012-01-01, 1@2012-01-05)'
-- "{[0.2@2012-01-01, 1@2012-01-03,2012-01-03, 5@2012-01-03,2012-01-05)}"
select 2 / tfloat '[-1@2000-01-01, 1@2000-01-02]'
-- ERROR:  Division by zero
select tfloat '[-1@2000-01-04, 1@2000-01-05]' / tfloat '[-1@2000-01-01, 1@2000-01-05]'
-- "[-2@2000-01-04, 1@2000-01-05]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Round to n decimal places</para>
					<para><varname>round(tfloat, integer): tfloat</varname></para>
					<programlisting>
SELECT round(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]', 2);
-- "[0.79@2000-01-01, 2.36@2000-01-02]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Radians to degrees</para>
					<para><varname>degrees(tfloat): tfloat</varname></para>
					<programlisting>
SELECT degrees(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]');
-- "[45@2000-01-01, 135@2000-01-02]"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Boolean Operators</title>
			<itemizedlist>
				<listitem>
					<para>Boolean and</para>
					<para><varname>{bool, tbool} &amp; {bool, tbool}: tbool</varname></para>
					<programlisting>
SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp; 
	tbool '[false@2012-01-03, false@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp; 
	tbool '{[false@2012-01-03, false@2012-01-04), 
	[true@2012-01-04, true@2012-01-05)}';
-- "{[f@2012-01-03, t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Boolean or</para>
					<para><varname>{bool, tbool} | {bool, tbool}: tbool</varname></para>
					<programlisting>
SELECT tbool '[true@2012-01-03, true@2012-01-05)' | 
	tbool '[false@2012-01-03, false@2012-01-05)';
-- "[t@2012-01-03, t@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Boolean not</para>
					<para><varname>~ {bool, tbool}: tbool</varname></para>
					<programlisting>
SELECT ~ tbool '[true@2012-01-03, true@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Text Functions and Operators</title>

			<itemizedlist>
				<listitem>
					<para>Concatenation</para>
					<para><varname>{text, ttext} || {text, ttext}: ttext</varname></para>
					<programlisting>
SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || text 'B';
-- "["AAB"@2012-01-01, "AAB"@2012-01-04)"
SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || ttext '[BB@2012-01-02, BB@2012-01-05)';
-- "["AABB"@2012-01-02, "AABB"@2012-01-04)"
SELECT ttext '[A@2012-01-01, B@2012-01-03, C@2012-01-04]' ||
	ttext '{[D@2012-01-01, D@2012-01-02), [E@2012-01-02, E@2012-01-04)}';
-- "{["DA"@2012-01-01, "EA"@2012-01-02, "EB"@2012-01-03, "EB"@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Transform to uppercase</para>
					<para><varname>upper(ttext): ttext</varname></para>
					<programlisting>
SELECT upper(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- "["AA"@2000-01-01, "BB"@2000-01-02]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Transform to lowercase</para>
					<para><varname>lower(ttext): ttext</varname></para>
					<programlisting>
SELECT lower(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- "["aa"@2000-01-01, "bb"@2000-01-02]"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Bounding Box Operators</title>
			<para>These operators test whether the bounding boxes of their arguments satisfy the predicate and result in a Boolean value. As stated in <xref linkend="temporal_types" />, the bounding box associated to a temporal type depends on the base type: It is the <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types, the <varname>tbox</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types, and the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types.</para>

			<para>A first set of operators consider the relative position of the bounding boxes. The operators <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname> consider the value dimension for <varname>tint</varname> and <varname>tfloat</varname> types and the X coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, and <varname>|&amp;&gt;</varname> consider the Y coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, and <varname>/&amp;&gt;</varname> consider the Z coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, and the operators <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname>, and <varname>#&amp;&gt;</varname> consider the time dimension for all temporal types. The operators for the value dimension of the <varname>tint</varname> and <varname>tfloat</varname> types are given next.</para>

			<itemizedlist>
				<listitem>
					<para>Is the first bounding box always strictly less than the second one?</para>
					<para><varname>{base, numrange, ttype} &lt;&lt; {base, numrange, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&lt; 2;
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&lt; tint '[2@2012-01-03, 2@2012-01-05)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box always strictly greater than the second one?</para>
					<para><varname>{base, numrange, ttype} &gt;&gt; {base, numrange, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[4@2012-01-01, 4@2012-01-04)' &gt;&gt; intrange '[1,4)';
-- true
SELECT tint '[4@2012-01-01, 4@2012-01-04)' &gt;&gt; tfloat '[4@2012-01-01, 5@2012-01-04)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box never greater than the second one?</para>
					<para><varname>{base, numrange, ttype} &amp;&lt; {base, numrange, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &amp;&lt; tfloat '{2@2012-01-03, 3@2012-01-05}';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box never less than the second one?</para>
					<para><varname>{base, numrange, ttype} &amp;&gt; {base, numrange, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &amp;&gt;
	tfloat '{[2@2012-01-02, 3@2012-01-04), [3@2012-01-04, 2@2012-01-06)}';
-- false
					</programlisting>
				</listitem>
			</itemizedlist>
			<para>The operators for the value dimension of the temporal point types are given next.</para>

			<itemizedlist>
				<listitem>
					<para>Is the first bounding box strictly to the left of the second one?</para>
					<para><varname>{geo, tgeompoint} &lt;&lt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &lt;&lt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly to the right of the second one?</para>
					<para><varname>{geo, tgeompoint} &gt;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &gt;&gt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend to the right of the second one?</para>
					<para><varname>{geo, tgeompoint} &amp;&lt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &amp;&lt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend to the left of the second one?</para>
					<para><varname>{geo, tgeompoint} &amp;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &amp;&gt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly below of the second one?</para>
					<para><varname>{geo, tgeompoint} &lt;&lt;| {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &lt;&lt;|
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly above of the second one?</para>
					<para><varname>{geo, tgeompoint} |&gt;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' |&gt;&gt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend above of the second one?</para>
					<para><varname>{geo, tgeompoint} &amp;&lt;| {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' &amp;&lt;|
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend below of the second one?</para>
					<para><varname>{geo, tgeompoint} |&amp;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0)@2001-01-01' |&amp;&gt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly in front of the second one?</para>
					<para><varname>{geo, tgeompoint} &lt;&lt;/ {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0 0)@2001-01-01' &lt;&lt;/
	tgeompoint '[Point(1 1 1)@2001-01-01, Point(1 2 2)@2001-01-02)';
-- true
SELECT tgeompoint 'Point(0 0)@2001-01-01' &lt;&lt;/
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- NULL
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box strictly back of the second one?</para>
					<para><varname>{geo, tgeompoint} /&gt;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0 0)@2001-01-01' /&gt;&gt;
	tgeompoint '[Point(1 1 1)@2001-01-01, Point(1 2 2)@2001-01-02)';
-- false
SELECT tgeompoint 'Point(0 0)@2001-01-01' /&gt;&gt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- NULL
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend in front of the second one?</para>
					<para><varname>{geo, tgeompoint} &amp;&lt;/ {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0 0)@2001-01-01' &amp;&lt;/
	tgeompoint '[Point(1 1 1)@2001-01-01, Point(1 2 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>The first bounding box does not extend back of the second one?</para>
					<para><varname>{geo, tgeompoint} /&amp;&gt; {geo, tgeompoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(0 0 0)@2001-01-01' /&amp;&gt;
	tgeompoint '[Point(1 1 1)@2001-01-01, Point(1 2 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The operators for the time dimension of all the temporal types are as follows.</para>
			<itemizedlist>
				<listitem>
					<para>Is the first bounding box always before of the second one?</para>
					<para><varname>{time, ttype} &lt;&lt;# {time, ttype}: boolean</varname></para>
					<programlisting>
SELECT tbool '[t@2012-01-01, t@2012-01-04)' &lt;&lt;# timestamptz '2012-01-03';
-- false
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&lt;# tint '[2@2012-01-03, 2@2012-01-05)';
-- false
SELECT tgeompoint 'Point(0 0)@2001-01-01' &lt;&lt;#
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box always after of the second one?</para>
					<para><varname>{time, ttype} #&gt;&gt; {time, ttype}: boolean</varname></para>
					<programlisting>
SELECT tbool '[t@2012-01-03, t@2012-01-04)' #&gt;&gt; period '[2012-01-01, 2012-01-02)';
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' #&gt;&gt; tfloat '[2@2012-01-03, 2@2012-01-05)';
-- false
SELECT tgeompoint 'Point(0 0)@2001-01-01' #&gt;&gt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box never after of the second one?</para>
					<para><varname>{time, ttype} &amp;&lt;# {time, ttype}: boolean</varname></para>
					<programlisting>
SELECT tbool '[t@2012-01-01, t@2012-01-04)' &amp;&lt;# tbool '[f@2012-01-03, f@2012-01-05)';
-- true
SELECT tfloat '[1@2012-01-01, 1@2012-01-04)' &amp;&lt;# tfloat '[2@2012-01-03, 2@2012-01-05)';
-- true
SELECT tgeompoint 'Point(0 0)@2001-01-01' &amp;&lt;#
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box never before of the second one?</para>
					<para><varname>{time, ttype} #&amp;&gt; {time, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' #&amp;&gt; tfloat '{2@2012-01-03, 3@2012-01-05}';
-- false
SELECT tgeompoint 'Point(0 0)@2001-01-01' #&amp;&gt;
	tgeompoint '[Point(1 1)@2001-01-01, Point(1 2)@2001-01-02)';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>Another set of operators consider the topological relationships between the bounding boxes. There are five topological operators: overlaps (<varname>&amp;&amp;</varname>), contains (<varname>@&gt;</varname>), contained (<varname>&lt;@</varname>), adjacent (<varname>-|-</varname>), and same (<varname>~=</varname>). The arguments of these operators can be a base type, a box, or a temporal type and the operators verify the topological relationship taking into account the value and/or the time dimension depending on the type of the arguments.</para>

			<para>The topological operators for temporal alphanumeric types are given next.</para>

			<itemizedlist>
				<listitem>
					<para>Does the bounding boxes overlap?</para>
					<para><varname>{base, numrange, time, tbox, ttype} &amp;&amp;</varname></para>
					<para><varname>	{base, numrange, time, tbox, ttype}: boolean</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' &amp;&amp; 3;
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &amp;&amp; floatrange '[1,4)';
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &amp;&amp; tint '[2@2012-01-03, 2@2012-01-05)';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Does the first bounding box contains the second one?</para>
					<para><varname>{base, numrange, time, tbox, ttype} @&gt;</varname></para>
					<para><varname>	{base, numrange, time, tbox, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' @&gt; timestamptz '2012-01-03';
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' @&gt; period '[2012-01-03, 2012-01-05)';
-- false
SELECT ttext '[A@2012-01-01, B@2012-01-06]' @&gt; ttext '[C@2012-01-03, D@2012-01-05]';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box contained in the second one?</para>
					<para><varname>{base, numrange, time, tbox, ttype} &lt;@</varname></para>
					<para><varname>	{base, numrange, time, tbox, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;@
	tbox(floatrange '[1,4)', period '[2012-01-01, 2012-01-05)');
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;@ tint '[2@2012-01-03, 2@2012-01-05)';
-- false
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;@ tfloat '{2@2012-01-03, 3@2012-01-05}';
-- false
					</programlisting>
				</listitem>

				<listitem>
					<para>Are the bounding boxes adjacent?</para>
					<para><varname>{base, numrange, time, tbox, ttype} -|-</varname></para>
					<para><varname>	{base, numrange, time, tbox, ttype}: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 2@2012-01-04]' -|-
	tbox(floatrange '[2,4)', period '[2012-01-01, 2012-01-05)');
-- true
SELECT tint '[1@2012-01-01, 1@2012-01-04)' -|- tint '[2@2012-01-03, 2@2012-01-05)';
-- false
SELECT tint '[1@2012-01-01, 1@2012-01-04)' -|- tfloat '{1@2012-01-03, 3@2012-01-05}';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Are the bounding boxes equal?</para>
					<para><varname>{base, numrange, time, tbox, ttype} ~=</varname></para>
					<para><varname>	{base, numrange, time, tbox, ttype}: boolean</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' ~=  
	tint '{4@2012-01-01, 3@2012-01-03, 1@2012-01-04}';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The topological operators for temporal point types are given next.</para>

			<itemizedlist>
				<listitem>
					<para>Does the bounding boxes overlap?</para>
					<para><varname>{geo, time, stbox, tpoint} &amp;&amp; {geo, time, stbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(2 2)@2012-01-04)' &amp;&amp;
	tgeompoint '[Point(0 1)@2012-01-03, Point(2 0)@2012-01-05)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Does the first bounding box contains the second one?</para>
					<para><varname>{geo, time, stbox, tpoint} @&gt; {geo, time, stbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' &amp;&amp;
	tgeompoint '[Point(1 1)@2012-01-03, Point(2 0)@2012-01-05)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Is the first bounding box contained in the second one?</para>
					<para><varname>{geo, time, stbox, tpoint} &lt;@ {geo, time, stbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint 'Point(1 1)@2012-01-01' &lt;@
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Are the bounding boxes adjacent?</para>
					<para><varname>{geo, time, stbox, tpoint} -|- {geo, time, stbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(2 2)@2012-01-02]' -|-
	tgeompoint '[Point(2 2)@2012-01-01, Point(3 3)@2012-01-04)';
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Are the bounding boxes equal?</para>
					<para><varname>{geo, time, stbox, tpoint} ~= {geo, time, stbox, tpoint}: boolean</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' ~=
	tgeompoint '[Point(0 2)@2012-01-01, Point(2 0)@2012-01-04)';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Distance Operators</title>
			<para>There are two distance operators. The first one computes the distance between either a temporal point and a geometry or between two temporal points at their nearest point of approach, which is a float. This is the same as the function <varname>nearestApproachDistance</varname> discussed before but as an operator it can be used for doing nearest neightbor searches using a GiST index (see <xref linkend="indexing_temporal_types" />).</para>

			<para>On the other hand, the temporal distance operator computes the distance at each instant of the intersection of the temporal extents of their arguments and results in a temporal float. Computing temporal distance is useful in many mobility applications. For example, a moving cluster (also known as convoy or flock) is defined as a set of objects that move close to each other for a long time interval. This requires to compute temporal distance between two moving objects.</para>
		
			<para>The temporal distance operator accepts a geometry/geography restricted to a point or a temporal point as arguments. Notice that the temporal types only consider linear interpolation between values, while the distance is a root of a quadratic function. Therefore, the temporal distance operator gives a linear approximation of the actual distance value for temporal sequence points. In this case, the arguments are synchronized in the time dimension, and for each of the composing line segments of the arguments, the spatial distance between the start point, the end point, and the nearest point of approach is computed, as shown in the examples below.</para>

			<itemizedlist>
				<listitem>
					<para>Smallest distance ever between the two arguments</para>
					<para><varname>{geometry, tgeompoint} |=| {geometry, tgeompoint}: float</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-02, Point(1 1)@2012-01-04, Point(0 0)@2012-01-06)' 
	|=| geometry 'Linestring(2 2,2 1,3 1)';
-- "1"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03, Point(0 0)@2012-01-05)' 
	|=| tgeompoint '[Point(2 0)@2012-01-02, Point(1 1)@2012-01-04, Point(2 2)@2012-01-06)';
-- "0.5"
					</programlisting>
				</listitem>

				<listitem>
					<para>Distance &Z_support; &geography_support;</para>
					<para><varname>{point, tpoint} &lt;-&gt; {point, tpoint}: tfloat</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt; 
	geometry 'Point(0 1)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;
	tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 1)@2012-01-01, Point(0 0)@2012-01-03)' &lt;-&gt;
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)' &lt;-&gt;
	tgeompoint '[Point(0 1)@2012-01-01, Point(1 2)@2012-01-02)';
-- "[1@2012-01-01,1@2012-01-02)"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="topological_relationships_temporal_points">
			<title>Topological Relationships for Temporal Points</title>

			<para>The topological relationships such as <varname>ST_Intersects</varname> and <varname>ST_Relate</varname> can be generalized for temporal points. The arguments of these generalized functions are either a temporal point or a base type (that is, a geometry or a geography), but these functions do not allow a base type in both arguments. Furthermore, both arguments must be of the same base type, that is, these functions do not allow to have a temporal geometry point (or a geometry) and a temporal geography point (or a geography) as arguments.</para>

			<para>There are two versions of the temporal topological relationships:</para>
			<itemizedlist>
				<listitem>
					<para>The first version applies the traditional topological function to the union of all values taken by the temporal point (which is a <varname>geometry</varname> or <varname>geography</varname>) and returns a <varname>boolean</varname> or a <varname>text</varname>. Examples are the <varname>intersects</varname> and <varname>relate</varname> functions.</para>
				</listitem>

				<listitem>
					<para>The second version is defined with the temporal semantics, that is, the traditional topological function is computed at each instant and results in a <varname>tbool</varname> or a <varname>ttext</varname>. Examples are the <varname>tintersects</varname> and <varname>trelate</varname> functions.</para>
				</listitem>
			</itemizedlist>

			<para>All spatial relationships in the two versions are defined for temporal geometry points, while only four of them are defined for temporal geography points, namely, <varname>covers</varname>, <varname>coveredby</varname>, <varname>intersects</varname>, and <varname>dwithin</varname>, and the corresponding temporal versions.</para>

			<para>The semantics conveyed by the first version of the relationships varies depending on the relationship and the type of the arguments. For example, the following query
				<programlisting>
SELECT intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
			tests whether the temporal point ever intersected the geometry, since the query is conceptually equivalent to the following one.
				<programlisting>
SELECT ST_Intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', 
	geometry 'Linestring(0 1,1 1)');
				</programlisting>
			where the second geometry is obtained by applying the <varname>trajectory</varname> function to the temporal point. On the other hand, the query
				<programlisting>
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
				tests whether the geometry always contains the temporal point. Finally, the following query
				<programlisting>
SELECT intersects(tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
				tests whether the temporal points may intersect, since the query above is conceptually equivalent to the following one 
				<programlisting>
SELECT ST_Intersects('Linestring(0 1,1 0)', 'Linestring(0 0,1 1)');
				</programlisting>
			</para>
						
			<para>The first versions of the relationships are typically used in combination with a spatio-temporal index when computing the temporal relationships. For example, the following query
				<programlisting>
SELECT T.TripId, R.RegionId, tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
WHERE intersects(T.Trip, R.Geom)
				</programlisting>
			which verifies whether a trip <varname>T</varname> (which is a temporal point) intersects a region <varname>R</varname> (which is a geometry), will benefit rom a spatio-temporal index on the column <varname>T.Trip</varname> since the <varname>intersects</varname> function will automatically perform the bounding box comparison <varname>T.Trip &amp;&amp; R.Geom</varname>. This is further explained later in this document.
			</para>
			
			<para>Three topological relationships available in PostGIS are not provided in the temporal version.
				<itemizedlist>
					<listitem>
						<para><varname>tcontainsproperly</varname> since it would always be equal to <varname>tcontains</varname>: <varname>ST_Contains</varname> returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A. <varname>ST_ContainsProperly</varname> returns true if B intersects the interior of A but not the boundary (or exterior).</para>
					</listitem>

					<listitem>
						<para><varname>tcrosses</varname> since it would always returns false: <varname>ST_Crosses</varname> returns true if the supplied geometries have some, but not all, interior points in common.</para>
					</listitem>

					<listitem>
						<para><varname>toverlaps</varname> since it would always returns false: <varname>ST_Overlaps</varname> returns true if the geometries share space, are of the same dimension, but are not completely contained by each other.</para>
					</listitem>
				</itemizedlist>
				</para>

			<para>Similarly, only a few temporal topological relationships are meaningful when the two arguments are temporal points. Therefore, the relationships supported for two temporal geometry points are <varname>tdisjoint</varname>, <varname>tequals</varname>, <varname>tintersects</varname>, <varname>tdwithin</varname>, and <varname>trelate</varname> (with 2 and 3 arguments), while only <varname>tintersects</varname> and <varname>tdwithin</varname> are supported for two temporal geography points.</para>

		
			<para>The <varname>relate</varname> and the <varname>trelate</varname> functions have two forms with either two or three arguments. The two-argument forms consider the spatial relationship between the interior, the boundary, and the exterior of the arguments and return a <varname>text</varname> or a <varname>ttext</varname> value representing the maximum intersection matrix pattern. This pattern is defined using the Dimensionally Extended 9 Intersection Model or DE-9IM (see the PostGIS documentation for more details). The three-argument forms determine whether the first two arguments satisfy the intersection matrix pattern given as third argument (a <varname>text</varname> value) and return a Boolean or a temporal Boolean.</para>

			<sect2>
				<title>Possible Spatial Relationships</title>
				<itemizedlist>
					<listitem>
						<para>May contain</para>
						<para><varname>contains({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>May contain properly</para>
						<para><varname>containsproperly({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT containsproperly(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para>May cover</para>
						<para><varname>covers({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
SELECT covers(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>May be covered by</para>
						<para><varname>coveredby({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
SELECT coveredby(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para>May cross</para>
						<para><varname>crosses({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT crosses(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>May be disjoint</para>
						<para><varname>disjoint({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT disjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para>May be equal</para>
						<para><varname>equals({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT equals(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para>May intersect &Z_support;</para>
					<para><varname>intersects({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
SELECT intersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',
	tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
-- false
SELECT intersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
	tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>May overlap</para>
						<para><varname>overlaps({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT overlaps(geometry 'Linestring(1 1,3 3)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>May touch</para>
						<para><varname>touches({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT touches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(0 1)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>May be within</para>
						<para><varname>within({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT within(geometry 'LineString(1 1,2 2)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para>May be at distance within &Z_support;</para>
					<para><varname>dwithin({geo, tpoint}, {geo, tpoint}, double): boolean</varname></para>
						<programlisting>
SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
	tgeompoint 'Point(0 2 1)@2000-01-01,Point(2 2 1)@2000-01-02', 1)
-- true
SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
	tgeompoint 'Point(0 2 2)@2000-01-01,Point(2 2 2)@2000-01-02', 1)
--	false
						</programlisting>
					</listitem>

					<listitem>
						<para>May relate</para>
						<para><varname>relate({geo, tgeompoint}, {geo, tgeompoint}): text</varname></para>
						<programlisting>
SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- "1F2F01FF2"
						</programlisting>
					</listitem>

					<listitem>
						<para>May relate</para>
						<para><varname>relate({geo, tgeompoint}, {geo, tgeompoint}, text): boolean</varname></para>
						<programlisting>
SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)','1F2F01FF2');
-- true
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Temporal Spatial Relationships</title>
				<itemizedlist>
					<listitem>
						<para>Temporal contains</para>
						<para><varname>tcontains({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT tcontains(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, f@2012-01-02], (t@2012-01-02, f@2012-01-03, f@2012-01-04)}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal covers &geography_support;</para>
						<para><varname>tcovers({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
SELECT tcovers(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal covered by &geography_support;</para>
						<para><varname>tcoveredby({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
SELECT tcoveredby(geometry 'Point(1 1)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04)}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal disjoint</para>
						<para><varname>tdisjoint({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT tdisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-03], (t@2012-01-03, t@2012-01-04]}"
SELECT tdisjoint(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[t@2012-01-01, f@2012-01-03], (t@2012-01-03, t@2012-01-05)}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal equals</para>
						<para><varname>tequals({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT tequals(geometry 'Point(1 1)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04]}"
SELECT tequals(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal intersects &Z_support; &geography_support;</para>
					<para><varname>tintersects({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
SELECT tintersects(geometry 'MultiPoint(1 1,2 2)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, t@2012-01-03],
	(f@2012-01-03, f@2012-01-04]}"
SELECT tintersects(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal touches</para>
						<para><varname>ttouches({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT ttouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal within</para>
						<para><varname>twithin({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT twithin(geometry 'Point(1 1)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03]}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal distance within &Z_support; &geography_support;</para>
						<para><varname>tdwithin({geo, tpoint}, {geo, tpoint}, double): tbool</varname></para>
						<programlisting>
SELECT tdwithin(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 1);
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}"
SELECT tdwithin(tgeompoint '[Point(1 0)@2000-01-01, Point(1 4)@2000-01-05]', 
	tgeompoint 'Interp=Stepwise;[Point(1 2)@2000-01-01, Point(1 3)@2000-01-05]', 1);
-- "{[f@2000-01-01, t@2000-01-02, t@2000-01-04], (f@2000-01-04, t@2000-01-05]}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal relate</para>
						<para><varname>trelate({geo, tgeompoint}, {geo, tgeompoint}): ttext</varname></para>
						<programlisting>
SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
-- "{[FF2FF10F2@2012-01-01, FF20F1FF2@2012-01-02, FF20F1FF2@2012-01-03],
	(FF2FF10F2@2012-01-03, FF2FF10F2@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem>
						<para>Temporal relate</para>
						<para><varname>trelate({geo, tgeompoint}, {geo, tgeompoint}, text): tbool</varname></para>
						<programlisting>
SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 'FF20F1FF2');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
	2012-01-04)}"
						</programlisting>
					</listitem>
				</itemizedlist>
				</sect2>
		</sect1>

		<sect1>
			<title>Aggregate Functions for Temporal Types</title>

			<para>The temporal aggregate functions generalize the traditional aggregate functions. Their semantics is that they compute the value of the function at every instant t in the union of the temporal extents of the values to aggregate.</para>

			<para>For all temporal types, the function <varname>tcount</varname> generalize the traditional function <varname>count</varname>. The temporal count can be used to compute at each point in time the number of available or reporting objects (for example, number of cars in an area). For Boolean types, the functions <varname>tand</varname> and <varname>tor</varname> generalize the traditional functions <varname>and</varname> and <varname>or</varname>. For numeric types, two types of temporal aggregate functions are available. The functions <varname>tmin</varname>, <varname>tmax</varname>, <varname>tsum</varname>, and <varname>tavg</varname> generalize the traditional functions <varname>min</varname>, <varname>max</varname>, <varname>sum</varname>, and <varname>avg</varname>. Furthermore, the functions <varname>wmin</varname>, <varname>wmax</varname>, <varname>wcount</varname>, <varname>wsum</varname>, and <varname>wavg</varname> are window (or cumulative) versions of the traditional functions that, given a time interval w, compute the value of the function at an instant t by considering the values during the interval [t-w, t]. All window aggregate functions are available for temporal integers, while for temporal floats only window minimum and maximum are meaningful. For temporal text, the functions Finally, for temporal points the function <varname>tcentroid</varname>, generalizes the corresponding function <varname>ST_Centroid</varname> provided by PostGIS. For example, given set of objects that move together (that is, a convoy or a flock) the temporal centroid will produce a temporal point that represents at each instant the geometric center (or the center of mass) of all the moving objects.</para>
		
			<para>In addition to the above, function <varname>extent</varname> returns a bounding box that encloses a set of temporal values. Depending on the base type, the result of this function can be a <varname>period</varname>, a <varname>tbox</varname> or an <varname>stbox</varname>. This function is an &ldquo;aggregate&rdquo; function in SQL terminology since it operates on lists of data, in the same way the SUM() and AVG() functions do.</para>

			<para>In the examples that follow, we suppose the tables <varname>Department</varname> and <varname>Trip</varname> contain the two tuples introduced in <xref linkend="examples_temporal_types" />.</para>
			<itemizedlist>
				<listitem>
					<para>Temporal count</para>
					<para><varname>tcount(ttype): {tinti, tints}</varname></para>
					<programlisting>
SELECT tcount(NoEmps) FROM Department;
-- "{[1@2012-01-01, 2@2012-02-01, 1@2012-08-01, 1@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal and</para>
					<para><varname>tand(tbool): tbool</varname></para>
					<programlisting>
SELECT tand(NoEmps #&gt; 6) FROM Department;
-- "{[t@2012-01-01, f@2012-04-01, f@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal or</para>
					<para><varname>tor(tbool): tbool</varname></para>
					<programlisting>
SELECT tor(NoEmps #&gt; 6) FROM Department;
-- "{[t@2012-01-01, f@2012-08-01, f@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal minimum</para>
					<para><varname>tmin(ttype): {ttypei, ttypes}</varname></para>
					<programlisting>
SELECT tmin(NoEmps) FROM Department;
-- "{[10@2012-01-01, 4@2012-02-01, 6@2012-06-01, 6@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal maximum</para>
					<para><varname>tmax(ttype): {ttypei, ttypes}</varname></para>
					<programlisting>
SELECT tmax(NoEmps) FROM Department;
-- "{[10@2012-01-01, 12@2012-04-01, 6@2012-08-01, 6@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal sum</para>
					<para><varname>tsum(tnumber): {tnumi, tnums}</varname></para>
					<programlisting>
SELECT tsum(NoEmps) FROM Department;
-- "{[10@2012-01-01, 14@2012-02-01, 16@2012-04-01, 18@2012-06-01, 6@2012-08-01, 
	6@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal average</para>
					<para><varname>tavg(tnumber): {tfloati, tfloats}</varname></para>
					<programlisting>
SELECT tavg(NoEmps) FROM Department;
-- "{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01), 
	[8@2012-04-01, 8@2012-06-01), [9@2012-06-01, 9@2012-08-01), 
	[6@2012-08-01, 6@2012-10-01)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Window minimum</para>
					<para><varname>wmin(tnumber, interval): {tnumi, tnums}</varname></para>
					<programlisting>
SELECT wmin(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 4@2012-04-01, 6@2012-06-03, 6@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Window maximum</para>
					<para><varname>wmax(tnumber, interval): {tnumi, tnums}</varname></para>
					<programlisting>
SELECT wmax(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 12@2012-04-01, 6@2012-08-03, 6@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Window count</para>
					<para><varname>wcount(tnumber, interval): {tinti, tints}</varname></para>
					<programlisting>
SELECT wcount(NoEmps, interval '2 days') FROM Department;
-- "{[1@2012-01-01, 2@2012-02-01, 3@2012-04-01, 2@2012-04-03, 3@2012-06-01, 2@2012-06-03,
	1@2012-08-03, 1@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Window sum</para>
					<para><varname>wsum(tint, interval): {tinti, tints}</varname></para>
					<programlisting>
SELECT wsum(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 14@2012-02-01, 26@2012-04-01, 16@2012-04-03, 22@2012-06-01, 
	18@2012-06-03, 6@2012-08-03, 6@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Window average</para>
					<para><varname>wavg(tint, interval): {tfloati, tfloats}</varname></para>
					<programlisting>
SELECT wavg(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01),
	[8.66666666666667@2012-04-01, 8.66666666666667@2012-04-03), 
	[8@2012-04-03, 8@2012-06-01),
	[7.33333333333333@2012-06-01, 7.33333333333333@2012-06-03), 
	[9@2012-06-03, 9@2012-08-03), [6@2012-08-03, 6@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal centroid</para>
					<para><varname>tcentroid(tgeompoint): tgeompoint</varname></para>
					<programlisting>
SELECT tcentroid(Trip) FROM Trips;
-- "{[POINT(0 0)@2012-01-01 08:00:00+00, POINT(1 0)@2012-01-01 08:05:00+00),
	[POINT(0.5 0)@2012-01-01 08:05:00+00, POINT(1.5 0.5)@2012-01-01 08:10:00+00,
	POINT(2 1.5)@2012-01-01 08:15:00+00),
	[POINT(2 2)@2012-01-01 08:15:00+00, POINT(3 3)@2012-01-01 08:20:00+00)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Bounding box extent</para>
					<para><varname>extent(temp): {period, tbox, stbox}</varname></para>
					<programlisting>
SELECT extent(noEmps) FROM Department;
-- "TBOX((4,2012-01-01 00:00:00+01),(12,2012-10-01 00:00:00+02))"
SELECT extent(Trip) FROM Trips;
-- "STBOX T((0,0,2012-01-01 08:00:00+01),(3,3,2012-01-01 08:20:00+01))"
					</programlisting>
				</listitem>

			</itemizedlist>
		</sect1>

		<sect1>
			<title>Utility Functions</title>
			<itemizedlist>
				<listitem>
					<para>Version of the MobilityDB extension</para>
					<para><varname>mobdb_lib_version(): text</varname></para>
					<programlisting>
SELECT mobdb_lib_version();
-- "MobilityDB 1.0"
					</programlisting>
				</listitem>

				<listitem>
					<para>Versions of the MobilityDB extension and its dependencies</para>
					<para><varname>mobdb_full_version(): text</varname></para>
					<programlisting>
SELECT mobdb_full_version();
-- "MobilityDB 1.0 PostgreSQL 11.5 PostGIS 2.5"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>
	</chapter>

	<chapter id="indexing_temporal_types">
		<title>Indexing of Temporal Types</title>
		<para>GiST and SP-GiST indexes can be created for table columns of temporal types. The GiST index implements an R-tree for temporal alphanumeric types and a TB-tree for temporal point types. The SP-GiST index implements a Quad-tree for temporal alphanumeric types and an Oct-tree for temporal point types. Examples of index creation are as follows:
			<programlisting>
CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
			</programlisting>
		</para>

		<para>The GiST and SP-GiST indexes store the bounding box for the temporal types. As explained in <xref linkend="temporal_types" />, these are
			<itemizedlist>
				<listitem>
					<para>the period <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types,</para>
				</listitem>

				<listitem>
					<para>the <varname>tbox</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types,</para>
				</listitem>

				<listitem>
					<para>the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types.</para>
				</listitem>
			</itemizedlist>
		</para>
			
		<para>A GiST or SP-GiST index can accelerate queries involving the following operators (see <xref linkend="operators_temporal_types" /> for more information):
			<itemizedlist>
				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, which only consider the value dimension in temporal alphanumeric types,</para>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, and <varname>/&amp;&gt;</varname>, which only consider the spatial dimension in temporal point types,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, which only consider the time dimension for all temporal types,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, and <varname>~=</varname>, which consider as many dimensions as they are shared by the indexed column and the query argument. These operators work on bounding boxes (that is, <varname>period</varname>, <varname>tbox</varname>, or <varname>stbox</varname>), not the entire values.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>In addition, a GiST index can accelerate nearest neighbor queries involving the <varname>|=|</varname> operator.</para>
			
		<para>For example, given the index defined above on the <varname>Department</varname> table and a query that involves a condition with the <varname>&amp;&amp;</varname> (overlaps) operator, if the right argument is a temporal float then both the value and the time dimensions are considered for filtering the tuples of the relation, while if the right argument is a float value, a float range, or a time type, then either the value or the time dimension will be used for filtering the tuples of the relation. Furthermore, a bounding box can be constructed from a value/range and/or a timestamp/period, which can be used for filtering the tuples of the relation. Examples of queries using the index on the <varname>Department</varname> table defined above are given next.
			<programlisting>
SELECT * FROM Department WHERE NoEmps &amp;&amp; 5;
SELECT * FROM Department WHERE NoEmps &amp;&amp; intrange '[1, 5)';
SELECT * FROM Department WHERE NoEmps &amp;&amp; timestamptz '2012-04-01';
SELECT * FROM Department WHERE NoEmps &amp;&amp; period '[2012-04-01, 2012-05-01)';
SELECT * FROM Department WHERE NoEmps &amp;&amp;
	tbox(intrange '[1, 5)', period '[2012-04-01, 2012-05-01)');
SELECT * FROM Department WHERE NoEmps &amp;&amp;
	tfloat '{[1@2012-01-01, 1@2012-02-01), [5@2012-04-01, 5@2012-05-01)}';
			</programlisting>
		</para>

		<para>Similarly, examples of queries using the index on the <varname>Trips</varname> table defined above are given next.
			<programlisting>
SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';
SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';
SELECT * FROM Trips WHERE Trip &amp;&amp; period '[2001-01-01, 2001-01-05)';
SELECT * FROM Trips WHERE Trip &amp;&amp;
	stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', period '[2001-01-01, 2001-01-05]');
SELECT * FROM Trips WHERE Trip &amp;&amp;
	tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';
			</programlisting>
		</para>
				
		<para>Finally, B-tree indexes can be created for table columns of all temporal types. For this index type, the only useful operation is equality. There is a B-tree sort ordering defined for values of temporal types, with corresponding <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname>, <varname>&gt;=</varname> and operators, but the ordering is rather arbitrary and not usually useful in the real world. B-tree support for temporal types is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>

		<para>In order to speed up several of the functions in <xref linkend="manipulating_temporal_types" />, a bounding box comparison that make uses of the available indexes can be added in the <varname>WHERE</varname> clause of queries. For example, this would be typically the case for the functions that project the temporal types to the value/spatial and/or time dimensions. This will filter out the tuples with an index as shown in the following query.
			<programlisting>
SELECT atPeriod(T.Trip, period(2001-01-01, 2001-01-02))
FROM Trips T
-- Bouding box index filtering
WHERE T.Trip &amp;&amp; period(2001-01-01, 2001-01-02)
			</programlisting>
		</para>
				
		<para>In the case of temporal points, all spatial relationships with the &ldquo;ever&rdquo; semantics (see <xref linkend="topological_relationships_temporal_points" />), excepted <varname>disjoint</varname>and <varname>relate</varname>, will automatically include a bounding box comparison that will make use of any indexes that are available on the temporal points. For this reason, the first version of the relationships is typically used for filtering the tuples with the help of an index when computing the temporal relationships as shown in the following query.
			<programlisting>
SELECT tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
-- Bouding box index filtering
WHERE intersects(T.Trip, R.Geom);
			</programlisting>
		</para>
	</chapter>
		
	<chapter id="statistics_temporal_types">
		<title>Statistics and Selectivity for Temporal Types</title>
		<sect1>
			<title>Statistics Collection for Temporal Types</title>
			<para>The PostgreSQL planner relies on statistical information about the contents of tables in order to generate the most efficient execution plan for queries. These statistics include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. For large tables, a random sample of the table contents is taken, rather than examining every row. This enables large tables to be analyzed in a small amount of time. The statistical information is gathered by the <varname>ANALYZE</varname> command and stored in the <varname>pg_statistic</varname> catalog table. Since different kinds of statistics may be appropriate for different kinds of data, the table only stores very general statistics (such as number of null values) in dedicated columns. Everything else is stored in five &ldquo;slots&rdquo;, which are couples of array columns that store the statistics for a column of an arbitrary type.</para>

			<para>The statistics collected for time types and temporal types are based on those collected by PostgreSQL for scalar types and range types. For scalar types, like <varname>float</varname>, the following statistics are collected:
				<orderedlist numeration="arabic">
					<listitem>
						<para>fraction of null values,</para>
					</listitem>
					<listitem>
						<para>average width, in bytes, of non-null values,</para>
					</listitem>
					<listitem>
						<para>number of distinct non-null values,</para>
					</listitem>
					<listitem>
						<para>array of most common values and array of their frequencies,</para>
					</listitem>
					<listitem>
						<para>histogram of values, where the most common values are excluded,</para>
					</listitem>
					<listitem>
						<para>correlation between physical and logical row ordering.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>For range types, like <varname>tstzrange</varname>, three additional histograms are collected:
				<orderedlist continuation="continues" numeration="arabic">
					<listitem id="range_stat1">
						<para>length histogram of non-empty ranges,</para>
					</listitem>
					<listitem id="range_stat2">
						<para>histograms of lower and upper bounds.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>For geometries, in addition to (1)&#x2013;(3), the following statistics are collected:
					<orderedlist continuation="continues" numeration="arabic">
						<listitem id="geom_stat1">
							<para>number of dimensions of the values, N-dimensional bounding box, number of rows in the table, number of rows in the sample, number of non-null values,</para>
						</listitem>
						<listitem id="geom_stat2">
							<para>N-dimensional histogram that divides the bounding box into a number of cells and keeps the proportion of values that intersects with each cell.</para>
						</listitem>
					</orderedlist>
			</para>

			<para>The statistics collected for the new time types <varname>timestampset</varname>, <varname>period</varname>, and <varname>periodset</varname> replicate those collected by PostgreSQL for the <varname>tstzrange</varname>. This is clear for the <varname>period</varname> type, which is equivalent to <varname>tszrange</varname>, excepted that periods cannot be empty. For the <varname>timestampset</varname> and the <varname>periodset</varname> types, a value is converted into its bounding box which is a <varname>period</varname>, then the <varname>period</varname> statistics are collected.</para>

			<para>The statistics collected for temporal types depend on their duration and their base type. In addition to statistics (1)&#x2013;(3) that are collected for all temporal types, statistics are collected for the value dimension and the time dimension independently. More precisely, the following statistics are collected for the time dimension:
				<itemizedlist>
					<listitem>
						<para>For temporal instant values, the statistics (4)&#x2013;(6) are collected for the timestamps.</para>
					</listitem>

					<listitem>
						<para>For all other durations, the statistics (7)&#x2013;(8) are collected for the (bounding box) periods.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>The following statistics are collected for the value dimension:
				<itemizedlist>
					<listitem>
						<para>For temporal types with stepwise interpolation (that is, temporal types whose base type is <varname>tbool</varname>, <varname>ttext</varname>, or <varname>tint</varname>):
							<itemizedlist>
								<listitem>
									<para>For the instant duration, the statistics (4)&#x2013;(6) are collected for the values.</para>
								</listitem>
			
								<listitem>
									<para>For all other durations, the statistics (7)&#x2013;(8) are collected for the values.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>For temporal float types (that is, <varname>tfloat</varname>):
							<itemizedlist>
								<listitem>
									<para>For instant values, the statistics (4)&#x2013;(6) are collected for the values.</para>
								</listitem>
								<listitem>
									<para>For all other durations, the statistics (7)&#x2013;(8) are collected for the (bounding) value ranges.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>For temporal point types (that is, <varname>tgeompoint</varname> and <varname>tgeogpoint</varname>) the statistics (9)&#x2013;(10) are collected for the points.</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect1>

		<sect1>
			<title>Selectivity Estimation of Operators</title>
			<para>Boolean operators in PostgreSQL can be associated with two selectivity functions, which compute how likely a value of a given type will match a given criterion. These selectivity functions rely on the statistics collected. There are two types of selectivity functions. The restriction selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>column OP constant</varname>. The join selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>table1.column1 OP table2.column2</varname>.</para>

			<para>MobilityDB defines 23 classes of Boolean operators (such as <varname>=</varname>, <varname>&lt;</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), each of which can have as left or right arguments a built-in type (such as <varname>int</varname>, <varname>timestamptz</varname>, etc.) or a new type (such as <varname>period</varname>, <varname>tintseq</varname>, etc.). As a consequence, there is a very high number of operators with different arguments to be considered for the selectivity functions. The approach taken was to group these combinations into classes corresponding to the value and temporal features. The classes correspond to the type of statistics collected as explained in the previous section.</para>

			<para>Currently, only restriction selectivity functions are implemented for temporal types, while join selectivity functions give a default selectivity value depending on the operator. It is planned to implement joint selectivity functions in the future.</para>
		</sect1>
	</chapter>

	<chapter id="tutorial">
		<title>MobilityDB Tutorial</title>
		<para>To illustrate the capabilities of MobilityDB, we give an example use case that loads, explores, and query mobility data. The data used is based on the <ulink url="http://dna.fernuni-hagen.de/secondo/BerlinMOD/BerlinMOD.html">BerlinMOD</ulink> benchmark for moving object databases and is available as a <ulink url="https://docs.mobilitydb.com/data/berlinmod_data.zip">ZIP</ulink> file.</para>
		
		<sect1>
			<title>Installation</title>

			<para>For this tutorial we will use a Docker image containing MobilityDB and all its dependencies (including PostgreSQL and PostGIS). The container has a default database called <varname>mobilitydb</varname> with the MobilityDB extension installed where <varname>user = pw = docker</varname>. This presupposes that you have installed Docker into your computer. In that case, you can run the following command.
				<programlisting>
docker pull codewit/mobilitydb
docker volume create mobilitydb_data
docker run --name "mobilitydb" -d -p 25432:5432 -v mobilitydb_data:/var/lib/postgresql 
	codewit/mobilitydb
				</programlisting>
				In the above commands
				<itemizedlist>
					<listitem><para><varname>docker pull</varname> downloads the Docker image of <varname>mobilitydb</varname>. If the image has been downloaded before, this checks whether a more recent image has been published in the docker repository, and downloads it. It is better to call this command every time, to ensures that you have the latest most up-to-date version of this image.</para></listitem>

					<listitem><para><varname>docker volume create mobilitydb_data</varname> creates a volume container on the host, that we will use to persist the PostgreSQL database files outside of the MobilityDB container. You need to run this command only once, during the first use of the image</para>
					</listitem>

					<listitem><para><varname>docker run --name=mobilitydb</varname> tells Docker our new container will be named <varname>mobilitydb</varname>.</para></listitem>

					<listitem><para><varname>-d</varname> runs the container in the background (detached mode).</para></listitem>

					<listitem><para><varname>-p 25432:5432</varname> maps TCP port 5432 in the container to port 25432 on the Docker host (to prevent potential conflicts with any local database instance you may have). This is required because the PostgreSQL database server in the container listens for connections on port 5432 by default.</para>
					</listitem>

					<listitem><para><varname>-v mobilitydb_data:/var/lib/postgresql</varname> tells the container filesystem to mount the <varname>mobilitydb_data</varname> volume that we have just created to the path /var/lib/postgresql. This means that any database objects that the container saves or creates (by default in <varname>/var/lib/postgresql</varname>) will instead be persisted in the <varname>mobilitydb_data</varname> directory, which is stored in the host. This options ensures that your data will not be lost when the container is removed. </para>
					</listitem>

					<listitem><para><varname>codewit/mobilitydb</varname> tells Docker to pull the docker image with that name from Docker Hub.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>
			Now we can launch any PostgreSQL administrative front-end to start using MobilityDB. Two traditional ones are the command-line tool <varname>psql</varname> and the graphical tool <varname>pgAdmin</varname>. We can launch <varname>psql</varname> as follows.
				<programlisting>
docker exec -t -i mobilitydb psql -h localhost -p 5432 -d mobilitydb -U docker
				</programlisting>
				In the above command
				<itemizedlist>
					<listitem><para><varname>docker exec -t -i mobilitydb psql</varname> tells Docker to allocate a pseudo-TTY, to keep STDIN open, and to execute in the container <varname>mobilitydb</varname> the command <varname>psql</varname>.</para></listitem>

					<listitem><para><varname>-h localhost -p 5432 -d mobilitydb -U docker</varname> tells <varname>psql</varname>, respectively, the database server host, the server port, the database name, and the user name.</para></listitem>
				</itemizedlist>
				Note that you will be prompted to provide the password, which is also <varname>docker</varname>.
			</para>

			<para>
			In order to launch <varname>pgAdmin</varname>, there are two options to create a connection. The first option is to set the host to the localhost (127.0.0.1), and the port to the mapped one on the host, as per the <varname>docker run</varname> command. In this example the port is 25432. Now we can launch <varname>pgAdmin</varname> and establish a new connection to the docker container. This is done as shown in <xref linkend="pgAdmin" />. 
			</para>

			<figure id="pgAdmin" float="start"><title>Configuration of a connection to the docker image in pgAdmin.</title>
				<mediaobject>
					<imageobject><imagedata scale='50' fileref='images/pgAdmin.png' /></imageobject>
				</mediaobject>
			</figure>

			<para>
			The second option is to know the IP address used by docker container with the following command.
				<programlisting>
docker-machine ip
192.168.99.101
				</programlisting>
				Notice that the address obtained in your computer may be different from the one above. Now we can launch <varname>pgAdmin</varname> and establish a new connection to the docker container. This is done as shown in <xref linkend="pgAdmin" />. The second option is to set the host to the localhost (127.0.0.1), and the port to the mapped one on the host, as per the <varname>docker run</varname> command. In this example the port would be 25432.
			</para>

			<para>
			Now you can use pgAdmin to query the mobilitydb database, as will be further explained in the following sections. Here are few more docker commands that you will eventually need:
			<programlisting>
docker stop "mobilitydb"
docker start "mobilitydb"
docker rm "mobilitydb"
			</programlisting>
				The above commands
				<itemizedlist>
					<listitem>
						<para><varname>docker stop</varname> shuts down the docker container. You need to issue this command, for example, if you need to re-start the host.</para>
					</listitem>
					<listitem>
						<para><varname>docker start</varname> launches back the docker container. You need to issue this command, for example, after re-starting the host.</para>
					</listitem>

					<listitem>
						<para><varname>docker rm</varname> removes/deletes docker container. You need to issue this command, for example, if you need to <varname>docker pull</varname> a more recent MobilityDB image. If the databases are stored in a <varname>docker volume</varname> as explained above, it will still be available after downloading and running the new image.</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect1>

		<sect1>
			<title>Loading the Data</title>

			<para>The ZIP file with the data for this tutorial contains a set of CSV files as follows:
				<itemizedlist>
					<listitem>
						<para><varname>datamcar.csv</varname> with fields <varname>Moid</varname>, <varname>Licence</varname>, <varname>Type</varname>, and <varname>Model</varname> contains the vehicle descriptions (without position history).</para>
					</listitem>
					
					<listitem>
						<para><varname>trips.csv</varname> with fields <varname>Moid</varname>, <varname>Tripid</varname>, <varname>Pos_x</varname>, <varname>Pos_y</varname>, and <varname>Instant</varname> contains vehicles movements and pauses.</para>
					</listitem>

					<listitem>
						<para><varname>queryinstants.csv</varname> with fields <varname>Id</varname> and <varname>Instant</varname> contains timestamps used for queries.</para>
					</listitem>
					
					<listitem>
						<para><varname>queryperiods.csv</varname> with fields <varname>Id</varname>, <varname>Begin</varname>, and <varname>End</varname> contains periods used for the queries.</para>
					</listitem>
					
					<listitem>
						<para><varname>querypoints.csv</varname> with fields <varname>Id</varname>, <varname>Pos_x</varname>, and <varname>Pos_y</varname> contains points used for queries.</para>
					</listitem>
					
					<listitem>
						<para><varname>queryregions.csv</varname> with fields <varname>Id</varname>, <varname>SegNo</varname>, <varname>Xstart</varname>, <varname>Ystart</varname>, <varname>Xend</varname>, and <varname>Yend</varname> contains the polygons used for queries.</para>
					</listitem>
					
				</itemizedlist>
			</para>

			<para>
			We decompress the file with the data into a directory. This can be done using the command. 
				<programlisting>
unzip berlinmod_data.zip
				</programlisting>
			We suppose in the following that the directory used is as follows <varname>/home/mobilitydb/data/</varname>.
			</para>

			<para>
			In the following, we can use the <varname>mobilitydb</varname> database provided in the container. This database has already installed the MobilityDB extension. Alternatively, you may use another database. In that case, you can install the MobilityDB extension in your database by using the following command.
				<programlisting>
CREATE EXTENSION MobilityDB CASCADE;
				</programlisting>
			By using <varname>CASCADE</varname> we load the required PostGIS extension prior to loading MobilityDB.
			</para>

			<para>We create the tables to be loaded with the data in the CSV files as follows.
				<programlisting>
CREATE TABLE Cars (
	CarId integer PRIMARY KEY,
	Licence varchar(32),
	Type varchar(32),
	Model varchar(32)
);
CREATE TABLE TripsInput (
	CarId integer REFERENCES Cars,
	TripId integer,
	Lon float,
	Lat float,
	T timestamptz,
	PRIMARY KEY (CarId, TripId, T)
);
CREATE TABLE Instants (
	InstantId integer PRIMARY KEY,
	Instant timestamptz
);
CREATE TABLE Periods (
	PeriodId integer PRIMARY KEY,
	Tstart TimestampTz,
	Tend TimestampTz,
	Period period
);
CREATE TABLE Points (
	PointId integer PRIMARY KEY,
	PosX double precision,
	PosY double precision,
	Geom Geometry(Point)
);
CREATE TABLE RegionsInput
(
	RegionId integer,
	SegNo integer,
	XStart double precision,
	YStart double precision,
	XEnd double precision,
	YEnd double precision,
	PRIMARY KEY (RegionId, SegNo)
);
CREATE TABLE Regions (
	RegionId integer PRIMARY KEY,
	Geom Geometry(Polygon)
);
CREATE TABLE Trips
(
	CarId integer NOT NULL,
	TripId integer NOT NULL,
	Trip tgeompoint,
	PRIMARY KEY (CarId, TripId),
	FOREIGN KEY (CarId) REFERENCES Cars (CarId) 
);
				</programlisting>
			We created one table for each CSV file renaming attributes for better readability. In addition, we created a table <varname>Regions</varname> in order to assemble all segments composing a region into a single geometry and a table <varname>Trips</varname> in order to assemble all points composing a trip into a single temporal point.
			</para>

			<para>
			We can load the CSV files into the corresponding tables as follows.
				<programlisting>
COPY Cars(CarId, Licence, Type, Model) FROM '/home/mobilitydb/data/datamcar.csv' 
	DELIMITER  ',' CSV HEADER;
COPY TripsInput(CarId, TripId, Lon, Lat, T) FROM '/home/mobilitydb/data/trips.csv' 
	DELIMITER  ',' CSV HEADER;
COPY Instants(InstantId, Instant) FROM '/home/mobilitydb/data/queryinstants.csv' 
	DELIMITER  ',' CSV HEADER;
COPY Periods(PeriodId, Tstart, Tend) FROM '/home/mobilitydb/data/queryperiods.csv' 
	DELIMITER  ',' CSV HEADER;
UPDATE Periods
SET Period = period(Tstart, Tend);
COPY Points(PointId, PosX, PosY) FROM '/home/mobilitydb/data/querypoints.csv' 
	DELIMITER  ',' CSV HEADER;
UPDATE Points
SET Geom = ST_Transform(ST_SetSRID(ST_MakePoint(PosX, PosY), 4326), 5676);
COPY RegionsInput(RegionId, SegNo, XStart, YStart, XEnd, YEnd) FROM 
	'/home/mobilitydb/data/queryregions.csv' DELIMITER  ',' CSV HEADER;
				</programlisting>
			</para>

			<para>The following query is used to load table <varname>Regions</varname> from the data in table <varname>RegionsInput</varname>.
				<programlisting>
INSERT INTO Regions (RegionId, Geom)
WITH RegionsSegs AS
(
	SELECT RegionId, SegNo,
		ST_Transform(ST_SetSRID(St_MakeLine(ST_MakePoint(XStart, YStart), 
		ST_MakePoint(XEnd, YEnd)), 4326), 5676) AS Geom
	FROM RegionsInput
)
SELECT RegionId, ST_Polygon(ST_LineMerge(ST_Union(Geom ORDER BY SegNo)), 5676) AS Geom
FROM RegionsSegs
GROUP BY RegionId;
				</programlisting>
			</para>

			<para>The following query is used to load table <varname>Trips</varname> from the data in table <varname>TripsInput</varname>.
				<programlisting>
INSERT INTO Trips
SELECT CarId, TripId, tgeompointseq(array_agg(tgeompointinst(
	ST_Transform(ST_SetSRID(ST_MakePoint(Lon,Lat), 4326), 5676), T) ORDER BY T))
FROM TripsInput
GROUP BY CarId, TripId;
				</programlisting>
			There are a lot of nested functions, so reading from the innermost:
				<itemizedlist>
					<listitem>
						<para>Function <varname>ST_MakePoint</varname> construct a point from the <varname>Lon</varname> and <varname>Lat</varname> values.</para>
					</listitem>

					<listitem>
						<para>Function <varname>ST_SetSRID</varname> sets the SRID of the point to 4326, that is, to the standard WGS 84 GPS coordinates.</para>
					</listitem>

					<listitem>
						<para>Function <varname>ST_Transform</varname> transforms the spherical GPS coordinates to plannar coordinates fitted for Germany.</para>
					</listitem>

					<listitem>
						<para>Function <varname>tgeompointinst</varname> gets the point and the time values to create a temporal point of instant duration.</para>
					</listitem>

					<listitem>
						<para>Function <varname>array_agg</varname> collects in an array all temporal points of a given car and a given trip (as specified by the <varname>GROUP BY</varname> clause) and sort them by time (as specified by the <varname>ORDER BY</varname> clause)</para>
					</listitem>

					<listitem>
						<para>Function <varname>tgeompointseq</varname> gets the array of temporal points and construct a temporal point of sequence duration.</para>
					</listitem>

				</itemizedlist>
			</para>

			<para>Finally, we create indexes on traditional, spatial, temporal or spatiotemporal attributes as well as views to select a subset of the rows from the corresponding tables. This can be done as follows.
				<programlisting>
CREATE UNIQUE INDEX Cars_CarId_Idx ON Cars USING btree(CarId);
CREATE INDEX Instants_Instant_Idx ON Instants USING btree(Instant);
CREATE INDEX Periods_Period_Idx ON Periods USING gist(Period);
CREATE INDEX Points_Geom_Idx ON Points USING gist(Geom);
CREATE INDEX Regions_Geom_Idx ON Regions USING gist(Geom);
CREATE INDEX Trips_CarId_idx ON Trips USING btree(CarId);
CREATE UNIQUE INDEX Trips_pkey_idx ON Trips USING btree(CarId, TripId);
CREATE INDEX Trips_gist_idx ON Trips USING gist(trip);

CREATE VIEW Instants1 AS SELECT * FROM Instants LIMIT 10;
CREATE VIEW Periods1 AS SELECT * FROM Periods LIMIT 10;
CREATE VIEW Points1 AS SELECT * FROM Points LIMIT 10;
CREATE VIEW Regions1 AS SELECT * FROM Regions LIMIT 10;
CREATE VIEW Trips1 AS SELECT * FROM Trips LIMIT 100;
				</programlisting>
			</para>
		</sect1>

		<sect1>
			<title>Loading the Data in Partitioned Tables</title>
			<para>
			PostgreSQL provides partitioning mechanisms so that large tables can be split in smaller physical tables. This may result in increased performance when querying and manipulating large tables. We will split the <varname>Trips</varname> table given in the previous section using list partitioning, where each partitition will contain all the trips that start at a particular date. For doing this, we use the procedure given next for automatically creating the partitions according to a date range.
			</para>
			<programlisting>
CREATE OR REPLACE FUNCTION create_partitions_by_date(TableName TEXT, StartDate DATE,
	EndDate DATE)
RETURNS void AS $$
DECLARE
	d DATE;
	PartitionName TEXT;
BEGIN
	IF NOT EXISTS
		(SELECT 1
		 FROM information_schema.tables 
		 WHERE table_name = lower(TableName)) 
	THEN
		RAISE EXCEPTION 'Table % does not exist', TableName;
	END IF;
	IF StartDate &gt;= EndDate THEN
		RAISE EXCEPTION 'The start date % must be before the end date %', StartDate, EndDate;
	END IF;
	d = StartDate;
	WHILE d &lt;= EndDate 
	LOOP
		PartitionName = TableName || '_' || to_char(d, 'YYYY_MM_DD');
		IF NOT EXISTS
			(SELECT 1
			 FROM information_schema.tables 
			 WHERE  table_name = lower(PartitionName))
		THEN
			EXECUTE format('CREATE TABLE %s PARTITION OF %s FOR VALUES IN (''%s'');', 
				PartitionName, TableName, to_char(d, 'YYYY-MM-DD'));
			RAISE NOTICE 'Partition % has been created', PartitionName;
		END IF;
		d = d + '1 day'::interval;
	END LOOP;
	RETURN;
END
$$ LANGUAGE plpgsql;
			</programlisting>

			<para>In order to partition table <varname>Trips</varname> by date we need to add an addition column <varname>TripDate</varname> to table <varname>TripsInput</varname>.
				<programlisting>
ALTER TABLE TripsInput ADD COLUMN TripDate DATE;
UPDATE TripsInput T1 
SET TripDate = T2.TripDate
FROM (SELECT DISTINCT TripId, date_trunc('day', MIN(T) OVER (PARTITION BY TripId))
	AS TripDate FROM TripsInput) T2
WHERE T1.TripId = T2.TripId;
				</programlisting>
			Notice that the <varname>UPDATE</varname> statement above takes into account the fact that a trip may finish at a day later than the starting day.
			</para>

			<para>
			The following statements create table <varname>Trips</varname> partitioned by date and the associated partitions.
				<programlisting>
CREATE TABLE Trips
(
	CarId integer NOT NULL,
	TripId integer NOT NULL,
	TripDate date,
	Trip tgeompoint,
	Traj geometry,
	PRIMARY KEY (CarId, TripId, TripDate),
	FOREIGN KEY (CarId) REFERENCES Cars (CarId) 
) PARTITION BY LIST(TripDate);

SELECT create_partitions_by_date('Trips', (SELECT MIN(TripDate) FROM TripsInput), 
	(SELECT MAX(TripDate) FROM TripsInput));
				</programlisting>
			</para>

			<para>
			To see the partitions that have been created automatically we can use the following statement.
				<programlisting>
SELECT I.inhrelid::regclass AS child
FROM   pg_inherits I
WHERE  i.inhparent = 'trips'::regclass;
				</programlisting>
			In our case this would result in the following output.
				<programlisting>
"trips_2007_05_27"
"trips_2007_05_28"
"trips_2007_05_29"
"trips_2007_05_30"
				</programlisting>
			</para>

			<para>We modify the query that loads table <varname>Trips</varname> from the data in table <varname>TripsInput</varname> as follows.
				<programlisting>
INSERT INTO Trips
SELECT CarId, TripId, TripDate, tgeompointseq(array_agg(tgeompointinst(
	ST_Transform(ST_SetSRID(ST_MakePoint(Lon,Lat), 4326), 5676), T) ORDER BY T))
FROM TripsInput
GROUP BY CarId, TripId, TripDate;
				</programlisting>
			Then, we can define the indexes and the views on the table <varname>Trips</varname> as shown in the previous section.
			</para>

			<para>
			An important advantange of the partitioning mechanism in PostgreSQL is that the constraints and the indexes defined on the <varname>Trips</varname> table are propagated to the partitions as shown next.
			</para>
			<programlisting>
INSERT INTO Trips VALUES (1, 10, '2007-05-30', NULL);

ERROR:  duplicate key value violates unique constraint "trips_2007_05_30_pkey"
DETAIL:  Key (carid, TripId, tripdate)=(1, 10, 2007-05-30) already exists.

EXPLAIN SELECT COUNT(*) from Trips where Trip &amp;&amp; period '[2007-05-28, 2007-05-29]';

"Aggregate  (cost=59.95..59.96 rows=1 width=8)"
"  ->  Append  (cost=0.14..59.93 rows=8 width=0)"
"        ->  Index Scan using trips_2007_05_27_trip_idx on trips_2007_05_27  (cost=0.14..8.16 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
"        ->  Index Scan using trips_2007_05_28_trip_idx on trips_2007_05_28  (cost=0.27..8.29 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
"        ->  Index Scan using trips_2007_05_29_trip_idx on trips_2007_05_29  (cost=0.27..8.29 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
[...]
			</programlisting>

		</sect1>

		<sect1>
			<title>Exploring the Data</title>
			<para>In order to visualize the data with traditional tools such as <ulink url="https://qgis.org/">QGIS</ulink> we add to table <varname>Trip</varname> a column <varname>Traj</varname> of type <varname>geometry</varname> containing the trajectory of the trips.
				<programlisting>
ALTER TABLE Trips ADD COLUMN traj geometry;
UPDATE Trips
SET Traj = trajectory(Trip);
				</programlisting>
			The visualization of the trajectories in QGIS is given in <xref linkend="berlinmod_trips" />. In the figure red lines correspond to the trajectories of moving cars, while yellow points correspond to the position of stationary cars. In order to know the total number of trips as well as the number of moving and stationary trips we can issue the following queries.
				<programlisting>
SELECT count(*) FROM Trips;
-- 1797
SELECT count(*) FROM Trips WHERE GeometryType(Traj) = 'POINT';
-- 969
SELECT count(*) FROM Trips WHERE GeometryType(Traj) = 'LINESTRING';
-- 828
				</programlisting>
			We can also determine the spatiotemporal extent of the data using the following query.
				<programlisting>
SELECT extent(Trip) from Trips
-- "STBOX T((2983189.5, 5831006.5,2007-05-27 00:00:00+02),
	(3021179.8, 5860883,2007-05-31 00:00:00+02))"
				</programlisting>
			</para>

			<figure id="berlinmod_trips" float="start"><title>Visualization of the trajectories of the trips in QGIS.</title>
				<mediaobject>
					<imageobject><imagedata scalefit="1" fileref='images/berlinmod_trips.png' /></imageobject>
				</mediaobject>
			</figure>

			<para>
			We continue investigating the data set by computing the maximum number of concurrent trips over the whole period
				<programlisting>
SELECT maxValue(tcount(Trip)) FROM Trips;
-- 141
				</programlisting>
			the average sampling rate
				<programlisting>
SELECT AVG(timespan(Trip)/numInstants(Trip)) FROM Trips;
-- "03:43:01.695539"
				</programlisting>
				and the total travelled distance in kilometers of all trips:
				<programlisting>
SELECT SUM(length(Trip)) / 1e3 as TotalLengthKm FROM Trips;
-- 10074.8123345527
				</programlisting>
			</para>

			<para>
			Now we want to know the average duration of a trip.
				<programlisting>
SELECT AVG(timespan(Trip)) FROM Trips;
--"07:31:57.195325"
				</programlisting>
			This average duration is too long. To investigate more we use the following query
				<programlisting>
SELECT length(Trip) / 1e3, timespan(Trip) FROM Trips ORDER BY duration;
				</programlisting>
			The query shows very many trips with zero length and a duration of more than one day. That would imply that there are stationary trips, representing parking overnight and even over the weekend. The previous query can hence be refined as follows:
				<programlisting>
SELECT AVG(timespan(Trip)/numInstants(Trip)) FROM Trips WHERE length(Trip) > 0;
-- "00:00:01.861784"
				</programlisting>
			</para>

			<para>
			The following query produces a histogram of trip length.
				<programlisting>
WITH buckets (bucketNo, bucketRange) AS (
	SELECT 1, floatrange '[0, 0]' UNION
	SELECT 2, floatrange '(0, 100)' UNION
	SELECT 3, floatrange '[100, 1000)' UNION
	SELECT 4, floatrange '[1000, 5000)' UNION
	SELECT 5, floatrange '[5000, 10000)' UNION
	SELECT 6, floatrange '[10000, 50000)' UNION
	SELECT 7, floatrange '[50000, 100000)' ),
histogram AS (
	SELECT bucketNo, bucketRange, count(TripId) as freq
	FROM buckets left outer join trips on length(trip) &lt;@ bucketRange
	GROUP BY bucketNo, bucketRange
	ORDER BY bucketNo, bucketRange
)
SELECT bucketNo, bucketRange, freq,
	repeat('&#9632;', ( freq::float / max(freq) OVER () * 30 )::int ) AS bar
FROM histogram;
				</programlisting>
				The result of the above query is given in <xref linkend="histogram_length" />. 
			</para>

			<figure id="histogram_length" float="start"><title>Result of the query building an histogram of trip lengths.</title>
				<mediaobject>
					<imageobject><imagedata scale='80' fileref='images/histogram_length.png' /></imageobject>
				</mediaobject>
			</figure>

		</sect1>

		<sect1>
			<title>Querying the Data</title>
			<para>We discuss next four categories of queries: range queries, distance queries, temporal aggregate queries, and nearest-neighbor queries<footnote><para>A web interface to explore the temporal types on a database containing the BerlinMOD benchmark data generated at scale 0.005 is available at the address <ulink url="http://demo.mobilitydb.eu/">here</ulink>.</para></footnote>.</para>

			<sect2>
				<title>Range Queries</title>
				<para>The queries in this category restrict Trips with respect to a spatial, temporal, or spatio-temporal point or range. In the examples, the spatial points and ranges are given, respectively, in tables <varname>Points</varname> and <varname>Regions</varname>, while temporal points and ranges are given, respectively, in tables <varname>Instants</varname> and <varname>Periods</varname>.</para>

				<orderedlist>
					<listitem id="qa_range_spatial">
						<para>List the cars that have passed at a region from <varname>Regions</varname>.</para>
						<programlisting>
SELECT DISTINCT R.RegionId, T.CarId
FROM Trips T, Regions R
WHERE ST_Intersects(trajectory(T.Trip), R.Geom)
ORDER BY R.RegionId, T.CarId;
						</programlisting>
						<para>This is a spatial range query. The query verifies that the trajectory of the car intersects the region. PostGIS performs an implicit bounding box comparison <varname>trajectory(T.Trip) &amp;&amp; R.Geom</varname> using the spatial index on table <varname>Regions</varname> when executing the predicate <varname>ST_Intersects</varname>.</para>
					</listitem>

					<listitem id="qa_range_spatiotemporal">
						<para>List the cars that were within a region from <varname>Regions</varname> during a period from <varname>Periods</varname>.</para>
						<programlisting>
SELECT R.RegionId, P.PeriodId, T.CarId
FROM Trips T, Regions R, Periods P
WHERE T.Trip &amp;&amp; stbox(R.Geom, P.Period) AND 
	_intersects(atPeriod(T.Trip, P.Period), R.Geom)
ORDER BY R.RegionId, P.PeriodId, T.CarId;
						</programlisting>
						<para>This is a spatio-temporal range query. The query performs a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on table <varname>Trips</varname>. After that, the query verifies that the location of the car during the period intersects the region. Notice that the predicate <varname>_intersects</varname> is used instead of <varname>intersects</varname> to avoid an implicit index test with the bounding box comparison <varname>atPeriod(Trip, P.Period) &amp;&amp; R.Geom</varname> is performed using the spatio-temporal index.</para>
					</listitem>

					<listitem id="qa_range_spatiotemporal_join">
						<para>List the pairs of cars that were both located within a region from <varname>Regions</varname> during a period from <varname>Periods</varname>.</para>
						<programlisting>
SELECT DISTINCT T1.CarId AS CarId1, T2.CarId AS CarId2, R.RegionId, P.PeriodId
FROM Trips T1, Trips T2, Regions R, Periods P
WHERE T1.CarId &lt; T2.CarId AND T1.Trip &amp;&amp; stbox(R.Geom, P.Period) AND
	T2.Trip &amp;&amp; stbox(R.Geom, P.Period) AND 
	_intersects(atPeriod(T1.Trip, P.Period), R.Geom) AND
	_intersects(atPeriod(T2.Trip, P.Period), R.Geom)
ORDER BY T1.CarId, T2.CarId, R.RegionId, P.PeriodId;
						</programlisting>
						<para>This is a spatio-temporal range join query. The query selects two trips of different cars and performs bounding box comparisons of each trip with a region and a period using the spatio-temporal index of the <varname>Trips</varname> table. The query then verifies that both cars were located within the region during the period.</para>
					</listitem>

					<listitem id="qa_range_entering">
						<para>List the first time at which a car visited a point in <varname>Points</varname>.</para>
						<programlisting>
SELECT T.CarId, P.PointId, MIN(startTimestamp(atValue(T.Trip,P.Geom))) AS Instant
FROM Trips T, Points P
WHERE ST_Contains(trajectory(T.Trip), P.Geom)
GROUP BY T.CarId, P.PointId;
						</programlisting>
						<para>The query selects a trip and a point and verifies that the car passed by the point by testing that the trajectory of the trip contains the point. Notice that PostGIS will perform the bounding box containment <varname>trajectory(T.Trip) ~ P.Geom</varname> using the spatial index on table <varname>Points</varname> before executing <varname>ST_Contains</varname>. Then, the query projects the trip to the point with the <varname>atValue</varname> function, get the first timestamp of the projected trip with the <varname>startTimestamp</varname> function, and applies the traditional <varname>MIN</varname> aggregate function for all trips of the car and the point.</para>
					</listitem>
				</orderedlist>
			</sect2>

			<sect2>
				<title>Temporal Aggregate Queries</title>
				<para>There are three common types of temporal aggregate queries.
					<itemizedlist>
						<listitem>
							<para>Instant temporal aggregate queries in which, from a conceptual perspective, the traditional aggregate function is applied at each instant.</para>
						</listitem>

						<listitem>
							<para>Window temporal aggregate queries (also known as cumulative queries), which, given a time interval w, compute the value of the aggregate at a time instant t from the values during the time period [t-w, t].</para>
						</listitem>

						<listitem>
							<para>Span temporal aggregate queries, which, first, split the time line into predefined intervals independently of the target data, and then, for each of these intervals, aggregate the data that overlap the interval.</para>
						</listitem>
					</itemizedlist>
				</para>

				<orderedlist continuation="continues">
					<listitem id="qa_aggregate_instant">
						<para>Compute how many cars were active at each period in <varname>Periods</varname>.</para>
						<programlisting>
SELECT P.PeriodID, COUNT(*), TCOUNT(atPeriod(T.Trip, P.Period))
FROM Trips T, Periods P
WHERE T.Trip &amp;&amp; P.Period
GROUP BY P.PeriodID
ORDER BY P.PeriodID;
						</programlisting>
						<para>This an instant temporal aggregate query. For each period, the query projects the trips to the given period and applies the temporal count to the projected trips. The condition in the <varname>WHERE</varname> clause is used for filtering the trips with the spatio-temporal index on table <varname>Trips</varname>.</para>
					</listitem>

					<listitem id="qa_aggregate_window">
						<para>For each region in <varname>Regions</varname>, give the window temporal count of trips with a 10-minute interval.</para>
						<programlisting>
SELECT R.RegionID, WCOUNT(atGeometry(T.Trip, R.Geom), interval '10 min')
FROM Trips T, Regions R
WHERE T.Trip &amp;&amp; R.Geom
GROUP BY R.RegionID
HAVING WCOUNT(atGeometry(T.Trip, R.Geom), interval '10 min') IS NOT NULL
ORDER BY R.RegionID;
						</programlisting>
						<para>This is a window temporal aggregate query. Suppose that we are computing pollution levels by region. Since the effect of a car passing at a location lasts some time interval, this is a typical case for window aggregates. For each region, the query computes the spatial projection of the trips to the given region and apply the window temporal count to the projected trips. The condition in the <varname>WHERE</varname> clause is used for filtering the trips with the spatio-temporal index. The condition in the <varname>HAVING</varname> clause is used for removing regions that do not intersect with any trip.</para>
					</listitem>

					<listitem id="qa_aggregate_span">
						<para>Count the number of trips that were active during each hour in May 29, 2007.</para>
						<programlisting>
WITH TimeSplit(Period) AS (
	SELECT period(H, H + interval '1 hour')
	FROM generate_series(timestamptz '2007-05-29 00:00:00', 
		timestamptz '2007-05-29 23:00:00', interval '1 hour') AS H )
SELECT Period, COUNT(*)
FROM TimeSplit S, Trips T
WHERE S.Period &amp;&amp; T.Trip AND atPeriod(Trip, Period) IS NOT NULL
GROUP BY S.Period
ORDER BY S.Period;
						</programlisting>
						<para>This is a span temporal aggregate query. The query defines the intervals to consider in the <varname>TimeSplit</varname> temporary table. For each of these intervals, the main query applies the traditional count function for counting the trips that overlap the interval.</para>
					</listitem>
				</orderedlist>
			</sect2>

			<sect2>
				<title>Distance queries</title>
				<para>The queries in this category deal with either the distance travelled by a single object or the distance between two objects. The complexity of the latter queries depend, on the one hand, on whether the reference objects are static or moving, and on the other, on whether the operation required is either the minimum distance ever or the temporal distance computed at each instant.</para>

				<orderedlist continuation="continues">
					<listitem id="qa_distance_overall">
						<para>List the overall traveled distances of the cars during the periods from <varname>Periods</varname>.</para>
						<programlisting>
SELECT T.CarId, P.PeriodId, P.Period, 
	SUM(length(atPeriod(T.Trip, P.Period))) AS Distance
FROM Trips T, Periods P
WHERE T.Trip &amp;&amp; P.Period
GROUP BY T.CarId, P.PeriodId, P.Period
ORDER BY T.CarId, P.PeriodId;
						</programlisting>
						<para>The query performs a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on the <varname>Trips</varname> table. It then projects the trip to the period, computes the length of the projected trip, and sum the lengths of all the trips of the same car during the period.</para>
					</listitem>

					<listitem id="qa_distance_static">
						<para>List the minimum distance ever between each car and each point from <varname>Points</varname>.</para>
						<programlisting>
SELECT T.CarId, P.PointId, MIN(trajectory(T.Trip) &lt;-&gt; P.Geom) AS MinDistance
FROM Trips T, Points P
GROUP BY T.CarId, P.PointId
ORDER BY T.CarId, P.PointId;
						</programlisting>
						<para>The query projects the trip to the spatial dimension with the <varname>trajectory</varname> function and computes the traditional distance between the trajectory of the trip and the point. The traditional minimum function is then applied for computing the minimum distance between all trips of the car and the point.</para>
					</listitem>

					<listitem id="qa_distance_moving">
						<para>List the minimum temporal distance between each pair of cars.</para>
						<programlisting>
SELECT T1.CarId AS Car1Id, T2.CarId AS Car2Id, MIN(T1.Trip &lt;-&gt; T2.Trip) AS MinDistance
FROM Trips T1, Trips T
WHERE T1.CarId &lt; T2.CarId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
GROUP BY T1.CarId, T2.CarId
ORDER BY T1.CarId, T2.CarId;
						</programlisting>
						<para>The query selects two trips <varname>T1</varname> and <varname>T2</varname> from distinct cars that were both traveling during a common period of time, computes the temporal distance between the trips, and then computes the temporal minimum distance between all trips of the two cars. The query uses the spatio-temporal index to filter the pairs of trips that were both traveling during a common period of time.</para>
					</listitem>

					<listitem id="qa_nearest_approach">
						<para>List the nearest approach time, distance, and shortest line between each pair of trips.</para>
						<programlisting>
SELECT T1.CarId AS Car1Id, T1.TripId AS Trip1Id, T2.CarId AS Car2Id, 
	T2.TripId AS Trip2Id, period(NearestApproachInstant(T1.Trip, T2.Trip)) AS Time,
	NearestApproachDistance(T1.Trip, T2.Trip) AS Distance, 
	ShortestLine(T1.Trip, T2.Trip) AS Line
FROM Trips1 T1, Trips1 T
WHERE T1.CarId &lt; T2.CarId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
ORDER BY T1.CarId, T1.TripId, T2.CarId, T2.TripId;
						</programlisting>
						<para>This query shows similar functionality as that provided by the PostGIS functions <varname>ST_ClosestPointOfApproach</varname> and <varname>ST_DistanceCPA</varname>. The query selects two trips <varname>T1</varname> and <varname>T2</varname> from distinct cars that were both traveling during a common period of time and computes the required results.</para>
					</listitem>

					<listitem id="qa_distance_tdwithin">
						<para>List when and where a pairs of cars have been at 10 m or less from each other.</para>
						<programlisting>
SELECT T1.CarId AS CarId1, T2.CarId AS CarId2, atPeriodSet(T1.Trip,
	period(atValue(tdwithin(T1.Trip, T2.Trip, 10.0), TRUE))) AS Position
FROM Trips T1, Trips T
WHERE T1.CarId &lt; T2.CarId AND T1.Trip &amp;&amp; expandSpatial(T2.Trip, 10) AND
	atPeriodSet(T1.Trip, period(atValue(tdwithin(T1.Trip, T2.Trip, 10.0), TRUE))) 
	IS NOT NULL
ORDER BY T1.CarId, T2.CarId, Position;
						</programlisting>
						<para>The query performs for each pair of trips <varname>T1</varname> and <varname>T2</varname> of distinct cars a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on the <varname>Trips</varname> table, where the bounding box of <varname>T2</varname> is expanded by 10 m. Then, the <varname>period</varname> expression computes the periods during which the cars were within 10 m. from each other and the <varname>atPeriodSet</varname> function projects the trips to those periods. Notice that the expression <varname>tdwithin(T1.Trip, T2.Trip, 10.0)</varname> is conceptually equivalent to <varname>dwithin(T1.Trip, T2.Trip) #&lt;= 10.0</varname>. However, in this case the spatio-temporal index cannot be used for filtering values.</para>
					</listitem>
				</orderedlist>
			</sect2>

			<sect2>
				<title>Nearest-Neighbor Queries</title>
				<para>There are three common types of nearest-neighbor queries in spatial databases.
					<itemizedlist>
						<listitem>
							<para>k-nearest-neighbor (kNN) queries find the k nearest points to a given point.</para>
						</listitem>

						<listitem>
							<para>Reverse k-nearest-neighbor (RkNN) queries find the points that have a given point among their k nearest-neighbors.</para>
						</listitem>

						<listitem>
							<para>Given two sets of points P and Q, aggregate nearest-neighbor (ANN) queries find the points from P that have minimum aggregated distance to all points from Q.</para>
						</listitem>
					</itemizedlist>
				</para>

				<para>The above types of queries are generalized to temporal points. However, the complexity of these queries depend on whether the reference object and the candidate objects are static or moving. In the examples that follow we only consider the nontemporal version of the nearest-neighbor queries, that is, the one in which the calculation is performed on the projection of temporal points on the spatial dimension. The temporal version of the nearest-neighbor queries remains to be done.</para>

				<orderedlist continuation="continues">
					<listitem id="qa_knn_static">
						<para>For each trip from <varname>Trips</varname>, list the three points from <varname>Points</varname> that have been closest to that car.</para>
						<programlisting>
WITH TripsTraj AS (
	SELECT *, trajectory(Trip) AS Trajectory FROM Trips )
SELECT T.CarId, P1.PointId, P1.Distance
FROM TripsTraj T CROSS JOIN LATERAL (
SELECT P.PointId, T.Trajectory &lt;-&gt; P.Geom AS Distance
FROM Points P
ORDER BY Distance LIMIT 3 ) AS P1
ORDER BY T.TripId, T.CarId, P1.Distance;
						</programlisting>
						<para>This is a nearest-neighbor query with moving reference objects and static candidate objects. The query above uses PostgreSQL's lateral join, which intuitively iterates over each row in a result set and evaluates a subquery using that row as a parameter. The query starts by computing the trajectory of the trips in the temporary table <varname>TripsTraj</varname>. Then, given a trip <varname>T</varname> in the outer query, the subquery computes the traditional distance between the trajectory of <varname>T</varname> and each point <varname>P</varname>. The <varname>ORDER BY</varname> and <varname>LIMIT</varname> clauses in the inner query select the three closest points. PostGIS will use the spatial index on the <varname>Points</varname> table for selecting the three closest points.</para>
					</listitem>

					<listitem id="qa_knn_moving">
						<para>For each trip from <varname>Trips</varname>, list the three cars that are closest to that car</para>
						<programlisting>
SELECT T1.CarId AS CarId1, C2.CarId AS CarId2, C2.Distance
FROM Trips T1 CROSS JOIN LATERAL (
SELECT T2.CarId, minValue(T1.Trip &lt;-&gt; T2.Trip) AS Distance
FROM Trips T2
WHERE T1.CarId &lt; T2.CarId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
ORDER BY Distance LIMIT 3 ) AS C2
ORDER BY T1.CarId, C2.CarId;
						</programlisting>
						<para>This is a nearest-neighbor query where both the reference and the candidate objects are moving. Therefore, it is not possible to proceed as in the previous query to first project the moving points to the spatial dimension and then compute the traditional distance. Given a trip <varname>T1</varname> in the outer query, the subquery computes the temporal distance between <varname>T1</varname> and a trip <varname>T2</varname> of another car distinct from the car from <varname>T1</varname> and then computes the minimum value in the temporal distance. Finally, the <varname>ORDER BY</varname> and <varname>LIMIT</varname> clauses in the inner query select the three closest cars.</para>
					</listitem>

					<listitem id="qa_rknn_static">
						<para>For each trip from <varname>Trips</varname>, list the points from <varname>Points</varname> that have that car among their three nearest neighbors.</para>
						<programlisting>
WITH TripsTraj AS (
	SELECT *, trajectory(Trip) AS Trajectory FROM Trips ),
PointTrips AS (
	SELECT P.PointId, T2.CarId, T2.TripId, T2.Distance
	FROM Points P CROSS JOIN LATERAL (
	SELECT T1.CarId, T1.TripId, P.Geom &lt;-&gt; T1.Trajectory AS Distance
	FROM TripsTraj T
	ORDER BY Distance LIMIT 3 ) AS T2 )
SELECT T.CarId, T.TripId, P.PointId, PT.Distance
FROM Trips T CROSS JOIN Points P JOIN PointTrips PT
ON T.CarId = PT.CarId AND T.TripId = PT.TripId AND P.PointId = PT.PointId
ORDER BY T.CarId, T.TripId, P.PointId;
						</programlisting>
						<para>This is a reverse nearest-neighbor query with moving reference objects and static candidate objects. The query starts by computing the corresponding nearest-neighbor query in the temporary table <varname>PointTrips</varname> as it is done in Query 13. Then, in the main query it verifies for each trip <varname>T</varname> and point <varname>P</varname> that both belong to the <varname>PointTrips</varname> table.</para>
					</listitem>

					<listitem id="qa_rknn_moving">
						<para>For each trip from <varname>Trips</varname>, list the cars having the car of the trip among the three nearest neighbors.</para>
						<programlisting>
WITH TripDistances AS (
	SELECT T1.CarId AS CarId1, T1.TripId AS TripId1, T3.CarId AS CarId2, 
		T3.TripId AS TripId2, T3.Distance
	FROM Trips T1 CROSS JOIN LATERAL (
	SELECT T2.CarId, T2.TripId, minValue(T1.Trip &lt;-&gt; T2.Trip) AS Distance
	FROM Trips T
	WHERE T1.CarId &lt; T2.CarId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
	ORDER BY Distance LIMIT 3 ) AS T3 )
SELECT T1.CarId, T1.TripId, T2.CarId, T2.TripId, TD.Distance
FROM Trips T1 JOIN Trips T2 ON T1.CarId &lt; T2.CarId
	JOIN TripDistances TD ON T1.CarId = TD.CarId1 AND T1.TripId = TD.TripId1 AND
	T2.CarId = TD.CarId2 AND T2.TripId = TD.TripId
ORDER BY T1.CarId, T1.TripId, T2.CarId, T2.TripId;
						</programlisting>
						<para>This is a reverse nearest-neighbor query where both the reference and the candidate objects are moving. The query starts by computing the corresponding nearest-neighbor query in the temporary table <varname>TripDistances</varname> as it is done in Query 14. Then, in the main query it verifies for each pair of trips <varname>T1</varname> and <varname>T2</varname> that both belong to the <varname>TripDistances</varname> table.</para>
					</listitem>

					<listitem id="qa_ann">
						<para>For each group of ten disjoint cars, list the point(s) from <varname>Points</varname>, having the minimum aggregated distance from the given group of ten cars during the given period.</para>
						<programlisting>
WITH Groups AS (
	SELECT ((ROW_NUMBER() OVER (ORDER BY C.CarId))-1)/10 + 1 AS GroupId, C.CarId
	FROM Cars C ),
SumDistances AS (
	SELECT G.GroupId, P.PointId,
		SUM(ST_Distance(trajectory(T.Trip), P.Geom)) AS SumDist
	FROM Groups G, Points P, Trips T
	WHERE T.CarId = G.CarId
	GROUP BY G.GroupId, P.PointId )
SELECT S1.GroupId, S1.PointId, S1.SumDist
FROM SumDistances S
WHERE S1.SumDist &lt;= ALL (
	SELECT SumDist
	FROM SumDistances S
	WHERE S1.GroupId = S2.GroupId )
	ORDER BY S1.GroupId, S1.PointId;
						</programlisting>
						<para>This is an aggregate nearest-neighbor query. The temporary table <varname>Groups</varname> splits the cars in groups where the <varname>GroupId</varname> column takes the values from 1 to total number of groups. The temporary table <varname>SumDistances</varname> computes for each group <varname>G</varname> and point <varname>P</varname> the sum of the distances between a trip of a car in the group and the point. The main query then selects for each group in table <varname>SumDistances</varname> the points(s) that have the minimum aggregated distance.</para>
					</listitem>
				</orderedlist>
			</sect2>
		</sect1>
	</chapter>

	<chapter id="temporal_network_point">
		<title>Temporal Network Points</title>
		<para>
			The temporal points that we have considered so far represent the movement of objects that can move freely on space since it is assumed that they can change their position from one location to the next one without any motion restriction. This is the case for animals and for flying objects such as planes or drones. However, in many cases, objects do not move freely in space but rather within spatially embedded networks such as routes or railways. In this case, it is necessary to take the embedded networks into account while describing the movements of these moving objects. Temporal network points account for these requirements. Compared with the free-space temporal points, network-based points have the following advantages:
			<itemizedlist>
				<listitem>
					<para>Network points provide road constraints that reflect the real movements of moving objects.</para>
				</listitem>

				<listitem>
					<para>The geometric information is not stored with the moving point, but once and for all in the fixed networks. In this way, the location representations and interpolations are more precise.</para>
				</listitem>

				<listitem>
					<para>Network points are more efficient in terms of data storage, location update, formulation of query, as well as indexing. These are discussed later in this document.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>
			Temporal network points are based on <ulink url="https://pgrouting.org/">pgRouting</ulink>, a PostgreSQL extension for developing network routing applications and doing graph analysis. Therefore, temporal network points asume that the underlying network is defined in a table named <varname>ways</varname>, which has at least three columns: <varname>gid</varname> containing the unique route identifier, <varname>length</varname> containing the route length, and <varname>the_geom</varname> containing the route geometry.
		</para>

		<para>
			There are two static network types, <varname>npoint</varname> (short for network point) and <varname>nsegment</varname> (short for network segment), which represent, respectively, a point and a segment of a route. An <varname>npoint</varname> value is composed of a route identifier and a float number in the range [0,1] determining a relative position of the route, where 0 corresponds to the begining of the route and 1 to the end of the route. A <varname>nsegment</varname> value is composed of a route identifier and two float numbers in the range [0,1] determining the start and end relative positions. A <varname>nsegment</varname> value whose start and end positions are equal corresponds to a <varname>npoint</varname> value.
		</para>

		<para>
			The <varname>npoint</varname> type serves as base type for defining the temporal network point type <varname>tnpoint</varname>. The <varname>tnpoint</varname> type has similar functionality as the temporal point type <varname>tgeompoint</varname> with the exception that it only considers two dimensions. Thus, all functions and operators described before for the <varname>tgeompoint</varname> type are also applicable for the <varname>tnpoint</varname> type. In addition, there are specific functions defined for the <varname>tnpoint</varname> type.
		</para>

		<sect1>
			<title>Static Network Types</title>
			<para>
				An <varname>npoint</varname> value is a couple of the form <varname>(rid, position)</varname> where <varname>rid</varname> is a <varname>bigint</varname> value representing a route identifier and <varname>position</varname> is a <varname>float</varname> value in the range [0,1] indicating its relative position. The value <varname>position = 0</varname> denotes the starting position of route and the value <varname>position = 1</varname> denotes the ending position of route. The road distance between an <varname>npoint</varname> value and the starting position of route with identifier <varname>rid</varname> is computed by <varname>position x length</varname>, where <varname>length</varname> is the route length. Examples of input of network point values are as follows:
				<programlisting>
SELECT npoint 'Npoint(76, 0.3)';
SELECT npoint 'Npoint(64, 1.0)';
				</programlisting>		
				The constructor function for network points has one argument for the route identifier and one argument for the relative position. An example of a network point value defined with the constructor function is as follows: 
				<programlisting>
SELECT npoint(76, 0.3);
				</programlisting>		
			</para>

			<para>
				An <varname>nsegment</varname> value is a triple of the form <varname>(rid, startPosition, endPosition)</varname> where <varname>rid</varname> is a <varname>bigint</varname> value representing a route identifier and <varname>startPosition</varname> and <varname>endPosition</varname> are <varname>float</varname> values in the range [0,1] such that <varname>startPosition</varname> &#8804; <varname>endPosition</varname>.  Semantically, a network segment represents a set of network points <varname>(rid,position)</varname> with <varname>startPosition</varname> &#8804; <varname>position</varname> &#8804; <varname>endPosition</varname>. In case of <varname>startPosition = 0</varname> and <varname>endPosition = 1</varname>, the network segment is equivalent to the entire route. In case of <varname>startPosition = endPosition</varname>, the network segment represents into a single network point. Examples of input of network point values are as follows:
				<programlisting>
SELECT nsegment 'Nsegment(76, 0.3, 0.5)';
SELECT nsegment 'Nsegment(64, 0.5, 0.5)';
SELECT nsegment 'Nsegment(64, 0.0, 1.0)';
SELECT nsegment 'Nsegment(64, 1.0, 0.0)'; 
-- converted to nsegment 'Nsegment(64, 0.0, 1.0)';
				</programlisting>
				As can be seen in the last example, the <varname>startPosition</varname> and <varname>endPosition</varname> values will be inverted to ensure that <varname>startPosition</varname> &#8804; <varname>endPosition</varname>. The constructor function for network segments has one argument for the route identifier and two optional arguments for the start and end positions. Examples of network segment values defined with the constructor function are as follows: 
				<programlisting>
SELECT nsegment(76, 0.3, 0.3);
SELECT nsegment(76); -- start and end position assumed to be 0 and 1 respectively
SELECT nsegment(76, 0.5); -- end position assumed to be 1
				</programlisting>
				Values of the <varname>npoint</varname> type can be converted to the <varname>nsegment</varname> type using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation as shown next.
				<programlisting>
SELECT npoint(76, 0.33)::nsegment;
				</programlisting>
			</para>

			<para>
				Values of static network types must satisfy several constraints so that they are well defined. These constraints are given next.
				<itemizedlist>
					<listitem>
						<para>The route identifier <varname>rid</varname> must be found in column <varname>gid</varname> of table <varname>ways</varname>.</para>
					</listitem>

					<listitem>
						<para>The <varname>position</varname>, <varname>startPosition</varname>, and <varname>endPosition</varname> values must be in the range [0,1].</para>
					</listitem>
				</itemizedlist>
				An error is raised whenever one of these constraints are not satisfied. Examples of incorrect static network type values are as follows.
				<programlisting>
-- incorrect rid value
SELECT npoint 'Npoint(87.5, 1.0)';
-- incorrect position value
SELECT npoint 'Npoint(87.5, 2.0)';
-- rid value not found in the ways table
SELECT npoint 'Npoint(99999999, 1.0)';
				</programlisting>
			</para>

			<para>
				We give next the functions and operators for the static network types.
			</para>

			<sect2>
				<title>Casting for Static Network Types</title>
				<para>
					Values of the <varname>npoint</varname> and <varname>nsegment</varname> types can be converted to the <varname>geometry</varname> type using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation as shown next.
				</para>
				<itemizedlist>
					<listitem>
						<para>Network point and network segment to geometry</para>
						<para>Cast: <varname>{npoint, nsegment}::geometry</varname></para>
						<programlisting>
SELECT st_astext(npoint(76, 0.33)::geometry);
-- "POINT(21.6338731332283 50.0545869554067)"
SELECT st_astext(nsegment(76, 0.33, 0.66)::geometry);
-- "LINESTRING(21.6338731332283 50.0545869554067,30.7475989651999 53.9185062927473)"
SELECT st_astext(nsegment(76, 0.33, 0.33)::geometry);
-- "POINT(21.6338731332283 50.0545869554067)"
						</programlisting>
					</listitem>
				</itemizedlist>

				<para>
					Similarly, <varname>geometry</varname> values of type point or linestring (restricted to two points) can be converted, respectively, to <varname>npoint</varname> and <varname>nsegment</varname> values using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation. For this, the route that intersects the given points must be found, where a tolerance of 0.00001 units (depending on the coordinate system) is assumed so a point and a route that are close are considered to intersect. If no such route is found, a null value is returned.
				</para>
				<itemizedlist>
					<listitem>
						<para>Geometry to network point and network segment</para>
						<para>Cast: <varname>geometry::{npoint, nsegment}</varname></para>
						<programlisting>
SELECT geometry 'Point(279.269156511873 811.497076880187)'::npoint;
-- "NPoint(3,0.781413)"
SELECT geometry 'LINESTRING(406.729536784738 702.58583437902,
	383.570801314823 845.137059419277)'::nsegment;
-- "NSegment(3,0.6,0.9)"
SELECT geometry 'Point(279.3 811.5)'::npoint;
-- NULL
SELECT geometry 'LINESTRING(406.7 702.6,383.6 845.1)'::nsegment;
-- NULL
						</programlisting>
					</listitem>
				</itemizedlist>

				<para>
					Finally, <varname>npoint</varname> and <varname>nsegment</varname>  values can be converted to an <varname>stbox</varname>
				</para>
				<itemizedlist>
					<listitem>
						<para>Network point and network segment to stbox</para>
						<para>Cast: <varname>{npoint, nsegment}::stbox</varname></para>
						<programlisting>
SELECT npoint 'NPoint(1, 0.2)'::stbox;
-- "SRID=5676;STBOX((69.7903671264648,81.4520950317383),
	(69.7903747558594,81.4521026611328))"
SELECT nsegment 'NSegment(1, 0.2, 0.5)'::stbox;
-- "SRID=5676;STBOX((48.7186622619629,77.7640686035156),
	(69.7903747558594,81.4521026611328))"
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Accessor Functions</title>
				<itemizedlist>
					<listitem>
						<para><varname>route</varname>: Route</para>
						<para>Signature: <varname>route({npoint, nsegment}): bigint</varname></para>
						<programlisting>
SELECT route(npoint 'Npoint(63, 0.3)');
-- 63
SELECT route(nsegment 'Nsegment(76, 0.3, 0.3)');
-- 76
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>getPosition</varname>: Position</para>
						<para>Signature: <varname>getPosition(npoint): float</varname></para>
						<programlisting>
SELECT getPosition(npoint 'Npoint(63, 0.3)');
-- 0.3
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>startPosition</varname>: Start position</para>
						<para>Signature: <varname>startPosition(nsegment): float</varname></para>
						<programlisting>
SELECT startPosition(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 0.3
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>endPosition</varname>: End position</para>
						<para>Signature: <varname>endPosition(nsegment): float</varname></para>
						<programlisting>
SELECT endPosition(nsegment 'Nsegment(76, 0.3, 0.5)');
-- 0.5
						</programlisting>
					</listitem>

					<listitem>
						<para>Spatial reference identifier</para>
						<para><varname>SRID({npoint, nsegment}): integer</varname></para>
						<programlisting>
SELECT SRID(npoint 'Npoint(1, 0.5)@2012-01-01');
-- 5676
SELECT SRID(nsegment 'Nsegment(1, 0.5, 0.7)@2012-01-01');
-- 5676
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Operators</title>

				<para>The comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) for static network types require that the left and right arguments be of the same type. Excepted the equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on static network types.</para>

				<itemizedlist>
					<listitem>
						<para><varname>=</varname>: Equal</para>
						<para>Signature: <varname>{npoint, nsegment} = {npoint, nsegment}</varname></para>
						<programlisting>
SELECT npoint 'Npoint(3, 0.5)' = npoint 'Npoint(3, 0.5)';
-- true
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' = nsegment 'Nsegment(3, 0.5, 0.6)';
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>&lt;&gt;</varname>: Not equal</para>
						<para>Signature: <varname>{npoint, nsegment} &lt;&gt; {npoint, nsegment}</varname></para>
						<programlisting>
SELECT npoint 'Npoint(3, 0.5)' &lt;&gt; npoint 'Npoint(3, 0.6);
-- true
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &lt;&gt; nsegment 'Nsegment(3, 0.5, 0.5)';
-- false
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>&lt;</varname>: Less than</para>
						<para>Signature: <varname>{npoint, nsegment} &lt; {npoint, nsegment}</varname></para>
						<programlisting>
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &lt; nsegment 'Nsegment(3, 0.5, 0.6)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>&gt;</varname>: Greater than</para>
						<para>Signature: <varname>{npoint, nsegment} &gt; {npoint, nsegment}</varname></para>
						<programlisting>
SELECT nsegment 'Nsegment(3, 0.5, 0.5)' &gt; nsegment 'Nsegment(2, 0.5, 0.5)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>&lt;=</varname>: Less than or equal to</para>
						<para>Signature: <varname>{npoint, nsegment} &lt;= {npoint, nsegment}</varname></para>
						<programlisting>
SELECT npoint 'Npoint(1, 0.5)' &lt;= npoint 'Npoint(2, 0.5)';
-- true
						</programlisting>
					</listitem>

					<listitem>
						<para><varname>&gt;=</varname>: Greater than or equal to</para>
						<para>Signature: <varname>{npoint, nsegment} &gt;= {npoint, nsegment}</varname></para>
						<programlisting>
SELECT npoint 'Npoint(1, 0.6)' &lt;= npoint 'Npoint(1, 0.5)';
-- true
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>
		</sect1>

		<sect1>
			<title>Temporal Network Points</title>
			<para>
				The temporal network point type <varname>tnpoint</varname> allows to represent the movement of objects over a network. It corresponds to the  temporal point type <varname>tgeompoint</varname> restricted to two-dimensional coordinates. As all the other temporal types it comes in four durations, namely, instant, instant set, sequence and sequence set. Examples of <varname>tnpoint</varname> values in these durations are given next.
					<programlisting>
SELECT tnpoint 'Npoint(1, 0.5)@2000-01-01';
SELECT tnpoint '{Npoint(1, 0.3)@2000-01-01, Npoint(1, 0.5)@2000-01-02, 
	Npoint(1, 0.5)@2000-01-03}';
SELECT tnpoint '[Npoint(1, 0.2)@2000-01-01, Npoint(1, 0.4)@2000-01-02, 
	Npoint(1, 0.5)@2000-01-03]';
SELECT tnpoint '{[Npoint(1, 0.2)@2000-01-01, Npoint(1, 0.4)@2000-01-02, 
	Npoint(1, 0.5)@2000-01-03], [Npoint(2, 0.6)@2000-01-04, Npoint(2, 0.6)@2000-01-05]}';
					</programlisting>
			</para>

			<para>
				The temporal network point type support type modifiers (or typmod in PostgreSQL terminology). The possible values for the type modifier are <varname>Instant</varname>, <varname>InstantSet</varname>, <varname>Sequence</varname>, and <varname>SequenceSet</varname>. If no type modifier is specified for a column, values of any duration are allowed.
					<programlisting>
SELECT tnpoint(Sequence) '[Npoint(1, 0.2)@2000-01-01, Npoint(1, 0.4)@2000-01-02, 
	Npoint(1, 0.5)@2000-01-03]';
SELECT tnpoint(Sequence) 'Npoint(1, 0.2)@2000-01-01';
-- ERROR:  Temporal type (Instant) does not match column type (Sequence)
					</programlisting>
			</para>

			<para>Temporal network point values of sequence duration must be defined on a single route. Therefore, a value of sequence set duration is needed for representing the movement of an object that traverses several routes, even if there is no temporal gap. For example, in the following value
				<programlisting>
SELECT tnpoint '{[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.5)@2001-01-03),
[NPoint(2, 0.4)@2001-01-03, NPoint(2, 0.6)@2001-01-04)}';
				</programlisting>
			the network point changes its route at 2001-01-03.
			</para>

			<para>Temporal network point values of sequence or sequence set duration are converted into a <emphasis role="strong">normal</emphasis> form so that equivalent values have identical representations. For this, consecutive instant values are merged when possible. Three consecutive instant values can be merged into two if the linear functions defining the evolution of values are the same. Examples of transformation into a normal form are as follows.
			Examples of transformation into a normal form are as follows.
				<programlisting>
SELECT tnpoint '[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.4)@2001-01-02, 
	NPoint(1, 0.6)@2001-01-03)';
-- "[NPoint(1,0.2)@2001-01-01, NPoint(1,0.6)@2001-01-03)"
SELECT tnpoint '{[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.3)@2001-01-02, 
	NPoint(1, 0.5)@2001-01-03), [NPoint(1, 0.5)@2001-01-03, NPoint(1, 0.7)@2001-01-04)}';
-- "{[NPoint(1,0.2)@2001-01-01, NPoint(1,0.3)@2001-01-02, NPoint(1,0.7)@2001-01-04)}"
				</programlisting>
			</para>
		</sect1>

		<sect1 id="validity_network_points">
			<title>Validity of Temporal Network Points</title>

			<para>Temporal network point values must satisfy the constraints specified in Section <xref linkend="validity_temporal_types"/> so that they are well defined. An error is raised whenever one of these constraints are not satisfied. Examples of incorrect values are as follows.
				<programlisting>
-- null values are not allowed
SELECT tnpoint 'NULL@2001-01-01 08:05:00';
SELECT tnpoint 'Point(0 0)@NULL';
-- base type is not a network point
SELECT tnpoint 'Point(0 0)@2001-01-01 08:05:00';
-- multiple routes in a sequence
SELECT tnpoint '[Npoint(1, 0.2)@2001-01-01 09:00:00, Npoint(2, 0.2)@2001-01-01 09:05:00)';
				</programlisting>
			</para>
		</sect1>

		<sect1 id="casting_temporal_network_points">
			<title>Casting for Temporal Network Points</title>

			<para>A temporal network point value can be converted to and from a temporal geometry point. This can be done using the notation <varname>CAST(ttype1 AS ttype2)</varname> or <varname>ttype1::ttype2</varname>. A null value is returned if any of the composing <varname>geometry</varname> point values cannot be converted into a <varname>npoint</varname> value. Furthermore, a temporal network point value can be converted to an <varname>stbox</varname>.</para>
			<itemizedlist>
				<listitem>
					<para>Temporal network point to temporal geometry point</para>
					<para>Cast: <varname>tnpoint::tgeompoint</varname></para>
					<programlisting>
SELECT astext((tnpoint '[NPoint(1, 0.2)@2001-01-01, 
	NPoint(1, 0.3)@2001-01-02)')::tgeompoint);
-- "[POINT(23.057077727326 28.7666335767956)@2001-01-01, 
	POINT(48.7117553116406 20.9256801894708)@2001-01-02)"
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal geometry point to temporal network point</para>
					<para>Casts: <varname>tgeompoint::tnpoint</varname></para>
					<programlisting>
SELECT tgeompoint '[POINT(23.057077727326 28.7666335767956)@2001-01-01, 
	POINT(48.7117553116406 20.9256801894708)@2001-01-02)'::tnpoint
-- "[NPoint(1,0.2)@2001-01-01 00:00:00+01, NPoint(1,0.3)@2001-01-02 00:00:00+01)"
SELECT tgeompoint '[POINT(23.057077727326 28.7666335767956)@2001-01-01, 
	POINT(48.7117553116406 20.9)@2001-01-02)'::tnpoint
-- NULL
					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal network point to stbox</para>
					<para>Cast: <varname>tnpoint::stbox</varname></para>
					<programlisting>
SELECT tnpoint '[NPoint(1, 0.2)@2001-01-01, NPoint(1, 0.3)@2001-01-02)'::stbox;
-- "SRID=5676;STBOX T((62.7866325378418,80.1435546875,2001-01-01),
	(69.7903747558594,81.4521026611328,2001-01-02))"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="manipulating_temporal_network_points">
			<title>Functions and Operators for Temporal Network Points</title>
			<para>All functions for temporal types described in <xref linkend="manipulating_temporal_types"/> can be applied for temporal point types. Therefore, in the signatures of the functions, the notation <varname>base</varname> also represents an <varname>npoint</varname> and the notations <varname>ttype</varname>,  <varname>tpoint</varname>, and <varname>tgeompoint</varname> also represent a <varname>tnpoint</varname>. Furthermore, the functions that have an argument of type <varname>geometry</varname> accept in addition an argument of type <varname>npoint</varname>. We present next some examples of these functions and operators for the temporal network points.</para>

			<itemizedlist>
				<listitem>
				<para>Transform a temporal value to another duration</para>
				<programlisting>
SELECT tnpoints(tnpoint 'NPoint(1, 0.5)@2001-01-01');
-- "{[NPoint(1,0.5)@2001-01-01]}"
				</programlisting>
				</listitem>

				<listitem>
					<para><varname>getValues</varname>: Values</para>
					<programlisting>
SELECT getValues(tnpoint '{[NPoint(1, 0.3)@2012-01-01, NPoint(1, 0.5)@2012-01-02)}');
-- "{"NPoint(1,0.3)","NPoint(1,0.5)"}"
SELECT getValues(tnpoint '{[NPoint(1, 0.3)@2012-01-01, NPoint(1, 0.3)@2012-01-02)}');
-- "{"NPoint(1,0.3)"}"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>valueAtTimestamp</varname>: Value at timestamp</para>
					<programlisting>
SELECT valueAtTimestamp(tnpoint '[NPoint(1, 0.3)@2012-01-01, NPoint(1, 0.5)@2012-01-03)',
	'2012-01-02');
-- "NPoint(1,0.4)"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>length</varname>: Length traversed by the temporal network point</para>
					<programlisting>
SELECT length(tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]');
-- 54.3757408468784
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>cumulativeLength</varname>: Cumulative length traversed by the temporal point</para>
					<programlisting>
SELECT cumulativeLength(tnpoint '{[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02, 
	NPoint(1, 0.5)@2000-01-03], [NPoint(1, 0.6)@2000-01-04, NPoint(1, 0.7)@2000-01-05]}');
-- "{[0@2000-01-01, 54.3757408468784@2000-01-02, 54.3757408468784@2000-01-03], 
	[54.3757408468784@2000-01-04, 81.5636112703177@2000-01-05]}"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>speed</varname>: Speed of the temporal point in units per second</para>
					<para>Signature: <varname>speed({tpointseq, tpoints}): tfloats</varname></para>
					<programlisting>
SELECT speed(tnpoint '[NPoint(1, 0.1)@2000-01-01, NPoint(1, 0.4)@2000-01-02, 
	NPoint(1, 0.6)@2000-01-03]') * 3600 * 24;
-- "Interp=Stepwise;[21.4016800272077@2000-01-01, 14.2677866848051@2000-01-02, 
	14.2677866848051@2000-01-03]"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>stbox</varname>: Construct the bounding box from a npoint</para>
					<programlisting>
SELECT stbox(npoint 'NPoint(1,0.3)');
-- "STBOX((48.711754,20.92568),(48.711758,20.925682))"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>stbox</varname>: Construct the bounding box from a npoint and a timestamp or period</para>
					<programlisting>
SELECT stbox(npoint 'NPoint(1,0.3)', timestamptz '2000-01-01');
-- "STBOX T((62.786633,80.143555,2000-01-01),(62.786636,80.143562,2000-01-01))"
SELECT stbox(npoint 'NPoint(1,0.3)', period '[2000-01-01,2000-01-02]');
-- "STBOX T((62.786633,80.143555,2000-01-01),(62.786636,80.143562,2000-01-02))"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>twCentroid</varname>: Time-weighted centroid </para>
					<programlisting>
SELECT st_astext(twCentroid(tnpoint '{[NPoint(1, 0.3)@2012-01-01, 
	NPoint(1, 0.5)@2012-01-02, NPoint(1, 0.5)@2012-01-03, NPoint(1, 0.7)@2012-01-04)}'));
-- "POINT(79.9787466444847 46.2385558051041)"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>azimuth</varname>: Temporal azimuth</para>
					<programlisting>
SELECT azimuth(tnpoint '[NPoint(2, 0.3)@2012-01-01, NPoint(2, 0.7)@2012-01-02]');
-- "{[0.974681063778863@2012-01-01 00:00:00+01, 
	0.974681063778863@2012-01-01 23:54:36.721091+01), 
	[3.68970843029227@2012-01-01 23:54:36.721091+01, 
	3.68970843029227@2012-01-02 00:00:00+01)}"
					</programlisting>
					<para>Since the underlying geometry associated to a route may have several vertices, the azimuth value may change between instants of the input temporal network point, as shown in the example above. </para>
				</listitem>

				<listitem>
					<para><varname>nearestApproachInstant</varname>: Instant of the first temporal point at which the two arguments are at the nearest distance.</para>
					<para>Signature: <varname>nearestApproachInstant({geo, npoint, tpoint}, {geo, npoint, tpoint}): tpoint</varname></para>
					<programlisting>
SELECT nearestApproachInstant(tnpoint '[NPoint(2, 0.3)@2012-01-01, 
	NPoint(2, 0.7)@2012-01-02]', geometry 'Linestring(50 50,55 55)');
-- "NPoint(2,0.349928)@2012-01-01 02:59:44.402905+01"
SELECT nearestApproachInstant(tnpoint '[NPoint(2, 0.3)@2012-01-01, 
	NPoint(2, 0.7)@2012-01-02]', npoint 'NPoint(1, 0.5)');
-- "NPoint(2,0.592181)@2012-01-01 17:31:51.080405+01"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>nearestApproachDistance</varname>: Smallest distance ever between the two arguments</para>
					<programlisting>
SELECT nearestApproachDistance(tnpoint '[NPoint(2, 0.3)@2012-01-01, 
	NPoint(2, 0.7)@2012-01-02]', geometry 'Linestring(50 50,55 55)');
-- 1.41793220500979
SELECT nearestApproachDistance(tnpoint '[NPoint(2, 0.3)@2012-01-01, 
	NPoint(2, 0.7)@2012-01-02]',  npoint 'NPoint(1, 0.5)');
-- "NPoint(2,0.592181)@2012-01-01 17:31:51.080405+01"
					</programlisting>
					<para>Function <varname>nearestApproachDistance</varname> has an associated operator <varname>|=|</varname> that can be used for doing nearest neightbor searches using a GiST index (see <xref linkend="operators_temporal_types" />).</para>
				</listitem>

				<listitem>
					<para><varname>shortestLine</varname>: Line connecting the nearest approach point between the two arguments. The function will only return the first line that it finds if there are more than one.</para>
					<programlisting>
SELECT st_astext(shortestLine(tnpoint '[NPoint(2, 0.3)@2012-01-01, 
	NPoint(2, 0.7)@2012-01-02]', geometry 'Linestring(50 50,55 55)'));
-- "LINESTRING(50.7960725266492 48.8266286733015,50 50)"
SELECT st_astext(shortestLine(tnpoint '[NPoint(2, 0.3)@2012-01-01, 
	NPoint(2, 0.7)@2012-01-02]', npoint 'NPoint(1, 0.5)'));
-- "LINESTRING(77.0902838115125 66.6659083092593,90.8134936900394 46.4385792121146)"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>atValue</varname>: Restrict to value</para>
					<programlisting>
SELECT atValue(tnpoint '[NPoint(2, 0.3)@2012-01-01, NPoint(2, 0.7)@2012-01-03]', 
	'NPoint(2, 0.5)');
-- "{[NPoint(2,0.5)@2012-01-02]}"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>atGeometry</varname>: Restrict to geometry</para>
					<programlisting>
SELECT atGeometry(tnpoint '[NPoint(2, 0.3)@2012-01-01, NPoint(2, 0.7)@2012-01-03]', 
	'Polygon((40 40,40 50,50 50,50 40,40 40))');
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>minusValue</varname>: Difference with value</para>
					<para>Signature: <varname>minusValue(ttype, base): ttype</varname></para>
					<programlisting>
SELECT minusValue(tnpoint '[NPoint(2, 0.3)@2012-01-01, NPoint(2, 0.7)@2012-01-03]', 
	'NPoint(2, 0.5)');
-- "{[NPoint(2,0.3)@2012-01-01, NPoint(2,0.5)@2012-01-02), 
	(NPoint(2,0.5)@2012-01-02, NPoint(2,0.7)@2012-01-03]}"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>minusGeometry</varname>: Difference with geometry</para>
					<programlisting>
SELECT minusGeometry(tnpoint '[NPoint(2, 0.3)@2012-01-01, NPoint(2, 0.7)@2012-01-03]', 
	'Polygon((40 40,40 50,50 50,50 40,40 40))');
-- "{(NPoint(2,0.342593)@2012-01-01 05:06:40.364673+01, 
	NPoint(2,0.7)@2012-01-03 00:00:00+01]}"
					</programlisting>
				</listitem>

				<listitem>
				<para>Traditional comparison operators</para>
				<programlisting>
SELECT tnpoint '{[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.3)@2001-01-02), 
	[NPoint(1, 0.3)@2001-01-02, NPoint(1, 0.5)@2001-01-03]}' = 
	tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.5)@2001-01-03]';
-- true
SELECT tnpoint '{[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.5)@2001-01-03]}' &lt;&gt; 
	tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.5)@2001-01-03]';
-- false
SELECT tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.5)@2001-01-03]' &lt;
	tnpoint '[NPoint(1, 0.1)@2001-01-01, NPoint(1, 0.6)@2001-01-03]';
-- true
					</programlisting>
				</listitem>

				<listitem>
				<para>Temporal comparison operators</para>
				<programlisting>
SELECT tnpoint '[NPoint(1, 0.2)@2012-01-01, NPoint(1, 0.4)@2012-01-03)' #= 
	npoint 'NPoint(1, 0.3)';
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03)}"
SELECT tnpoint '[NPoint(1, 0.2)@2012-01-01, NPoint(1, 0.8)@2012-01-03)' #&lt;&gt; 
	tnpoint '[NPoint(1, 0.3)@2012-01-01, NPoint(1, 0.7)@2012-01-03)';
-- "{[t@2012-01-01, f@2012-01-02], (t@2012-01-02, t@2012-01-03)}"
					</programlisting>
				</listitem>

				<listitem>
					<para>Ever and always equal operators</para>
					<programlisting>
SELECT tnpoint '[Npoint(1, 0.2)@2012-01-01, Npoint(1, 0.4)@2012-01-04)' &amp;= Npoint(1, 0.3);
-- true
SELECT tnpoint '[Npoint(1, 0.2)@2012-01-01, Npoint(1, 0.2)@2012-01-04)' @= Npoint(1, 0.2);
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Relative position bounding box operators</para>
					<programlisting>
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &lt;&lt;
	npoint 'NPoint(1, 0.2)'
-- false
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &lt;&lt;|
	stbox(npoint 'NPoint(1, 0.5)')
-- false
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &amp;&gt;
	npoint 'NPoint(1, 0.3)'::geometry
-- true
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &lt;&lt;#
	tnpoint '[NPoint(1, 0.3)@2000-01-03, NPoint(1, 0.5)@2000-01-05]'
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para>Topological bounding box operators</para>
					<programlisting>
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' &amp;&amp;
	npoint 'NPoint(1, 0.5)'
-- true
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' @&gt;
	stbox(npoint 'NPoint(1, 0.5)')
-- true
SELECT npoint 'NPoint(1, 0.5)'::geometry &lt;@
	tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-02]' 
-- true
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' ~=
	tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.35)@2000-01-02, 
	NPoint(1, 0.5)@2000-01-03]'
-- true
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>|=|</varname>: Smallest distance ever between the two arguments</para>
					<programlisting>
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' |=|
	npoint 'NPoint(1, 0.2)';
-- 2.34988300875063
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' |=|
	geometry 'Linestring(2 2,2 1,3 1)';
-- 82.2059262761477
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>&lt;-&gt;</varname>: Distance</para>
					<programlisting>
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' &lt;-&gt;
	npoint 'NPoint(1, 0.2)';
-- "[2.34988300875063@2000-01-02 00:00:00+01, 2.34988300875063@2000-01-03 00:00:00+01]"
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' &lt;-&gt;
	geometry 'Point(50 50)';
-- "[25.0496666945044@2000-01-01 00:00:00+01, 26.4085688426232@2000-01-03 00:00:00+01]"
SELECT tnpoint '[NPoint(1, 0.3)@2000-01-01, NPoint(1, 0.5)@2000-01-03]' &lt;-&gt;
	tnpoint '[NPoint(1, 0.3)@2000-01-02, NPoint(1, 0.5)@2000-01-04]'
-- "[2.34988300875063@2000-01-02 00:00:00+01, 2.34988300875063@2000-01-03 00:00:00+01]"
					</programlisting>
				</listitem>

				<listitem>
					<para>Possible spatial relationships</para>
					<programlisting>
SELECT contains(geometry 'Polygon((0 0,0 50,50 50,50 0,0 0))',
	tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)');
-- false
SELECT disjoint(npoint 'NPoint(2, 0.0)',
	tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)');
-- true
SELECT intersects(tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)',
	tnpoint '[NPoint(2, 0.0)@2012-01-01, NPoint(2, 1)@2012-01-03)');
-- false

					</programlisting>
				</listitem>

				<listitem>
					<para>Temporal spatial relationships</para>
					<programlisting>
SELECT tdisjoint(geometry 'Polygon((0 0,0 50,50 50,50 0,0 0))',
	tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)');
-- "{[t@2012-01-01 00:00:00+01, t@2012-01-03 00:00:00+01)}"
SELECT tdwithin(tnpoint '[NPoint(1, 0.3)@2012-01-01, NPoint(1, 0.5)@2012-01-03)',
	tnpoint '[NPoint(1, 0.5)@2012-01-01, NPoint(1, 0.3)@2012-01-03)', 1);
-- "{[t@2012-01-01 00:00:00+01, t@2012-01-01 22:35:55.379053+01], 
	(f@2012-01-01 22:35:55.379053+01,  t@2012-01-02 01:24:04.620946+01, 
	t@2012-01-03 00:00:00+01)}"
SELECT trelate(tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)',
	npoint 'NPoint(1, 0.2)');
-- "{["FF0FFF0F2"@2012-01-01 00:00:00+01, "FF0FFF0F2"@2012-01-03 00:00:00+01)}"
SELECT trelate(tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)',
	tnpoint '[NPoint(1, 0.3)@2012-01-01, NPoint(1, 0.1)@2012-01-03)', '0FFFFFFF2');
-- "{[f@2012-01-01 00:00:00+01, t@2012-01-02 00:00:00+01, t@2012-01-03 00:00:00+01)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Aggregate Functions for Temporal Network Points</title>
			<para>The three aggregate functions for temporal network points are illustrated next.</para>
		
			<itemizedlist>
				<listitem>
					<para><varname>tcount</varname>: Temporal count</para>
					<programlisting>
WITH Temp(temp) AS (
	SELECT tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)' UNION
	SELECT tnpoint '[NPoint(1, 0.2)@2012-01-02, NPoint(1, 0.4)@2012-01-04)' UNION
	SELECT tnpoint '[NPoint(1, 0.3)@2012-01-03, NPoint(1, 0.5)@2012-01-05)' )
SELECT tcount(Temp)
FROM Temp
-- "{[1@2012-01-01, 2@2012-01-02, 1@2012-01-04, 1@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>wcount</varname>: Window count</para>
					<programlisting>
WITH Temp(temp) AS (
	SELECT tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)' UNION
	SELECT tnpoint '[NPoint(1, 0.2)@2012-01-02, NPoint(1, 0.4)@2012-01-04)' UNION
	SELECT tnpoint '[NPoint(1, 0.3)@2012-01-03, NPoint(1, 0.5)@2012-01-05)' )
SELECT wcount(Temp, '1 day')
FROM Temp
-- "{[1@2012-01-01, 2@2012-01-02, 3@2012-01-03, 2@2012-01-04, 1@2012-01-05, 
	1@2012-01-06)}"
					</programlisting>
				</listitem>

				<listitem>
					<para><varname>tcentroid</varname>: Temporal centroid</para>
					<para>Signature: <varname>tcentroid(tgeompoint): tgeompoint</varname></para>
					<programlisting>
WITH Temp(temp) AS (
	SELECT tnpoint '[NPoint(1, 0.1)@2012-01-01, NPoint(1, 0.3)@2012-01-03)' UNION
	SELECT tnpoint '[NPoint(1, 0.2)@2012-01-01, NPoint(1, 0.4)@2012-01-03)' UNION
	SELECT tnpoint '[NPoint(1, 0.3)@2012-01-01, NPoint(1, 0.5)@2012-01-03)' )
SELECT astext(tcentroid(Temp))
FROM Temp
-- "{[POINT(72.451531682218 76.5231414472853)@2012-01-01, 
	POINT(55.7001249027598 72.9552602410653)@2012-01-03)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Indexing of Temporal Network Points</title>
			<para>GiST and SP-GiST indexes can be created for table columns of temporal networks points. An example of index creation is follows:
				<programlisting>
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
				</programlisting>
			</para>

			<para>The GiST and SP-GiST indexes store the bounding box for the temporal network points, which is an <varname>stbox</varname> and thus stores the absolute coordinates of the underlying space.</para>
			
			<para>A GiST or SP-GiST index can accelerate queries involving the following operators:
				<itemizedlist>
					<listitem>
						<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, which only consider the spatial dimension in temporal network points,</para>
					</listitem>

					<listitem>
						<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, which only consider the time dimension in temporal network points,</para>
					</listitem>

					<listitem>
						<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname>, and <varname>-|-</varname>, which consider as many dimensions as they are shared by the indexed column and the query argument. These operators work on bounding boxes, not the entire values.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>In addition, a GiST index can accelerate nearest neighbor queries involving the <varname>|=|</varname> operator.</para>
			
		</sect1>
	</chapter>

	<appendix id ="berlinmod">
		<title>BerlinMOD Benchmark on MobilityDB</title>

		<para><ulink url="http://dna.fernuni-hagen.de/secondo/BerlinMOD/BerlinMOD.html">BerlinMOD</ulink> is a standard benchmark for moving object DBMSs. It provides a data generator, pregenerated benchmark data for different scale factors, and set of queries of two types: 17 range-style queries (called BerlinMOD/R), and 9 nearest-neighbours queries (called BerlinMOD/NN). The MobilityDB tutorial presented in <xref linkend="tutorial" /> and its associated data were based on BerlinMOD. However, its purpose was to show the capabilities of MobilityDB. In this appendix, we show how to load pregenerated BerlinMOD data on MobilityDB and how to express the 17 queries in BerlinMOD/R. Some of these queries were already presented in <xref linkend="tutorial" />.</para>

		<sect1>
			<title>Loading the Data</title>
			<para>
			The script for loading pregenerated data is available <ulink url="https://docs.mobilitydb.com/data/berlinmod_load.sql">here</ulink>.
				<programlisting>
-------------------------------------------------------------------------------
-- Loads the BerlinMOD data in projected (2D) coordinates with SRID 5676
-- https://epsg.io/5676
-------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS berlinmod_load();
CREATE OR REPLACE FUNCTION berlinmod_load(scale_factor text DEFAULT '0.005',
	path text DEFAULT '/usr/local/BerlinMOD/') 
RETURNS text AS $$
DECLARE
	fullpath text;
BEGIN
	fullpath = path || scale_factor || '/';
	DROP TABLE IF EXISTS streets;
	CREATE TABLE streets
	(
		StreetId integer,
		vmax integer,
		x1 double precision,
		y1 double precision,
		x2 double precision,
		y2 double precision,
		Geom geometry(LineString, 5676)
	);
	EXECUTE format('COPY streets(StreetId, vmax, x1, y1, x2, y2) FROM ''%sstreets.csv'' 
		DELIMITER '','' CSV HEADER', fullpath);
	UPDATE streets
	SET Geom = ST_Transform(ST_SetSRID(ST_MakeLine(ARRAY[ST_MakePoint(x1, y1),
		ST_MakePoint(x2, y2)]), 4326), 5676);

	DROP TABLE IF EXISTS Points CASCADE;
	CREATE TABLE Points
	(
		PointId integer,
		PosX double precision,
		PosY double precision,
		Geom geometry(Point, 5676)
	);
	EXECUTE format('COPY Points(PointId, PosX, PosY) FROM ''%squerypoints.csv'' 
		DELIMITER  '','' CSV HEADER', fullpath);
	UPDATE Points
	SET Geom = ST_Transform(ST_SetSRID(ST_MakePoint(PosX, PosY), 4326), 5676);

	CREATE INDEX Points_geom_idx ON Points USING gist(Geom);
		
	CREATE VIEW Points1(PointId, PosX, PosY, Geom) AS
	SELECT PointId, PosX, PosY, Geom
	FROM Points
	LIMIT 10;

	DROP TABLE IF EXISTS RegionsInput CASCADE;
	CREATE TABLE RegionsInput
	(
		RegionId integer,
		SegNo integer,
		XStart double precision,
		YStart double precision,
		XEnd double precision,
		YEnd double precision
	);
	EXECUTE format('COPY RegionsInput(RegionId, SegNo, XStart, YStart, XEnd, YEnd) 
		FROM ''%squeryregions.csv'' DELIMITER  '','' CSV HEADER', fullpath);
	
	DROP TABLE IF EXISTS Regions CASCADE;
	CREATE TABLE Regions
	(
		RegionId integer,
		Geom Geometry(Polygon, 5676)
	);
	INSERT INTO Regions (RegionId, Geom)
	WITH RegionsSegs AS
	(
		SELECT RegionId, SegNo, ST_Transform(ST_SetSRID(St_MakeLine(
			ST_MakePoint(XStart, YStart), ST_MakePoint(XEnd, YEnd)), 4326), 5676) AS Geom
		FROM RegionsInput
	)
	SELECT RegionId, ST_Polygon(ST_LineMerge(ST_Union(Geom ORDER BY SegNo)), 5676) AS Geom
	FROM RegionsSegs
	GROUP BY RegionId;	

	CREATE INDEX Regions_geom_idx ON Regions USING gist(Geom);

	CREATE VIEW Regions1(RegionId, Geom) AS
	SELECT RegionId, Geom
	FROM Regions
	LIMIT 10;
	
	DROP TABLE IF EXISTS Instants CASCADE;
	CREATE TABLE Instants
	(
		InstantId integer,
		Instant timestamptz
	);
	EXECUTE format('COPY Instants(InstantId, Instant) FROM ''%squeryinstants.csv''
		DELIMITER  '','' CSV HEADER', fullpath);

	CREATE INDEX Instants_instant_btree_idx ON Instants USING btree(instant);
  
	CREATE VIEW Instants1(InstantId, Instant) AS
	SELECT InstantId, Instant 
	FROM Instants
	LIMIT 10;
	
	DROP TABLE IF EXISTS Periods CASCADE;
	CREATE TABLE Periods
	(
		PeriodId integer,
		BeginP timestamp,
		EndP timestamp,
		Period period
	);
	EXECUTE format('COPY Periods(PeriodId, BeginP, EndP) FROM ''%squeryperiods.csv'' 
		DELIMITER  '','' CSV HEADER', fullpath);
	UPDATE Periods
	SET Period = period(BeginP,EndP);

	CREATE INDEX Periods_Period_gist_idx ON Periods USING gist(Period);
	
	CREATE VIEW Periods1(PeriodId, BeginP, EndP, Period) AS
	SELECT PeriodId, BeginP, EndP, Period
	FROM Periods
	LIMIT 10;
	
	DROP TABLE IF EXISTS Cars CASCADE;
	CREATE TABLE Cars
	(
		CarId integer primary key,
		Licence varchar(32),
		Type varchar(32),
		Model varchar(32)
	);
	EXECUTE format('COPY Cars(CarId, Licence, Type, Model) FROM ''%sdatamcar.csv'' 
		DELIMITER  '','' CSV HEADER', fullpath);
	
	CREATE UNIQUE INDEX Cars_CarId_idx ON Cars USING btree(CarId);
	
	DROP TABLE IF EXISTS Licences CASCADE;
	CREATE TABLE Licences
	(
		LicenceId integer,
		Licence varchar(8),
		CarId integer
	);
	EXECUTE format('COPY Licences(Licence, LicenceId) FROM ''%squerylicences.csv'' 
		DELIMITER  '','' CSV HEADER', fullpath);
	UPDATE Licences Q
	SET CarId = ( SELECT C.CarId FROM Cars C WHERE C.Licence = Q.Licence );

	CREATE INDEX Licences_CarId_idx ON Licences USING btree(CarId);
  
	CREATE VIEW Licences1(LicenceId, Licence, CarId) AS
	SELECT LicenceId, Licence, CarId
	FROM Licences
	LIMIT 10;
	
	CREATE VIEW Licences2(LicenceId, Licence, CarId) AS
	SELECT LicenceId, Licence, CarId
	FROM Licences
	LIMIT 10 OFFSET 10;

	DROP TABLE IF EXISTS TripsInput CASCADE;
	CREATE TABLE TripsInput	(
		CarId integer,
		TripId integer,
		TStart timestamp without time zone,
		TEnd timestamp without time zone,
		XStart double precision,
		YStart double precision,
		XEnd double precision,
		YEnd double precision,
		Geom geometry(LineString)
	);
	EXECUTE format('COPY TripsInput(CarId, TripId, TStart, TEnd, XStart, YStart, XEnd, YEnd) 
		FROM ''%strips.csv'' DELIMITER  '','' CSV HEADER', fullpath);
	UPDATE TripsInput
	SET Geom = ST_Transform(ST_SetSRID(ST_MakeLine(ARRAY[ST_MakePoint(XStart, YStart),
		ST_MakePoint(XEnd, YEnd)]), 4326), 5676);

	DROP TABLE IF EXISTS TripsInputInstants;
	CREATE TABLE TripsInputInstants AS (
	SELECT CarId, TripId, TStart, XStart, YStart, 
		ST_Transform(ST_SetSRID(ST_MakePoint(XStart, YStart), 4326), 5676) as Geom
	FROM TripsInput
	UNION ALL
	SELECT T1.CarId, T1.TripId, T1.TEnd, T1.XEnd, T1.YEnd, 
		ST_Transform(ST_SetSRID(ST_MakePoint(T1.XEnd, T1.YEnd), 4326), 5676) as Geom
	FROM TripsInput T1 INNER JOIN (
		SELECT CarId, TripId, max(TEnd) as MaxTend
		FROM TripsInput 
		GROUP BY CarId, TripId
	) T2 ON T1.CarId = T2.CarId AND T1.TripId = T2.TripId AND T1.TEnd = T2.MaxTend );
	ALTER TABLE TripsInputInstants ADD COLUMN inst tgeompoint;
	UPDATE TripsInputInstants
	SET inst = tgeompointinst(Geom, TStart);

	DROP TABLE IF EXISTS Trips CASCADE;
	CREATE TABLE Trips (
		CarId integer NOT NULL,
		TripId integer NOT NULL,
		Trip tgeompoint,
		Traj geometry,
		PRIMARY KEY (CarId, TripId),
		FOREIGN KEY (CarId) REFERENCES Cars (CarId) 
	);
	INSERT INTO Trips
		SELECT CarId, TripId, tgeompointseq(array_agg(inst ORDER BY TStart))
		FROM TripsInputInstants
		GROUP BY CarId, TripId;
	UPDATE Trips
	SET Traj = trajectory(Trip);

	CREATE INDEX Trips_CarId_idx ON Trips USING btree(CarId);
	CREATE UNIQUE INDEX Trips_pkey_idx ON Trips USING btree(CarId, TripId);
	CREATE INDEX Trips_gist_idx ON Trips USING gist(trip);
	
	DROP VIEW IF EXISTS Trips1;
	CREATE VIEW Trips1 AS
	SELECT * FROM Trips LIMIT 100;
	
	-- Drop temporary tables
	DROP TABLE RegionsInput;
	DROP TABLE TripsInput;
	DROP TABLE TripsInputInstants;

	RETURN 'The End';
END;
$$ LANGUAGE 'plpgsql';
-------------------------------------------------------------------------------
				</programlisting>
				The script above creates a procedure to load pregenerated BerlinMOD data (in CSV format and WGS84 coordinates) at various scale factors. The procedure has two parameters: the scale factor and the directory where the CSV files are located. It supposes by default that the scale factor is <varname>0.005</varname> and that the CSV files are located in the directory <varname>/usr/local/BerlinMOD/&lt;scale factor&gt;/</varname>. Notice that the procedure creates GiST indexes for the tables. Alternatively, SP-GiST indexes could be used. The procedure can be called, for example, as follows.
				<programlisting>
SELECT berlinmod_load('0.05');
				</programlisting>
			</para>
		</sect1>

		<sect1>
			<title>Loading the Data in Partitioned Tables</title>
			<para>As we discussed in <xref linkend="tutorial" />, partioning allows one to split a large table into smaller physical pieces. We show next how to modify the scripts given in the previous section to take advantage of partioning. We will partition the <varname>Trips</varname> table by date using list partitioning, where each partitition will contain all the trips that start at a particular date. We will use the procedure <varname>create_partitions_by_date</varname> shown in <xref linkend="tutorial" /> for automatically creating the partitions according to the date range of the corresponding scale factor.
			</para>
			<programlisting>
[...]				
DROP TABLE IF EXISTS TripsInput CASCADE;
CREATE TABLE TripsInput (
	CarId integer,
	TripId integer,
	TripDate date,
	TStart timestamp without time zone,
	TEnd timestamp without time zone,
	XStart double precision,
	YStart double precision,
	XEnd double precision,
	YEnd double precision,
	Geom geometry(LineString)
);
EXECUTE format('COPY TripsInput(CarId, TripId, TStart, TEnd, XStart, YStart, XEnd, YEnd) 
	FROM ''%strips.csv'' DELIMITER  '','' CSV HEADER', fullpath);
UPDATE TripsInput
SET Geom = ST_Transform(ST_SetSRID(ST_MakeLine(ARRAY[ST_MakePoint(XStart, YStart),
		ST_MakePoint(XEnd, YEnd)]), 4326), 5676);
UPDATE TripsInput T1 
SET TripDate = T2.TripDate
FROM (SELECT DISTINCT TripId, date_trunc('day', MIN(TStart) OVER 
	(PARTITION BY TripId)) AS TripDate FROM TripsInput) T2
WHERE T1.TripId = T2.TripId;
[...]				
DROP TABLE IF EXISTS Trips CASCADE;
CREATE TABLE Trips (
	CarId integer NOT NULL,
	TripId integer NOT NULL,
	TripDate date,
	Trip tgeompoint,
	Traj geometry,
	PRIMARY KEY (CarId, TripId, TripDate),
	FOREIGN KEY (CarId) REFERENCES Cars (CarId) 
) PARTITION BY LIST(TripDate);

-- Create the partitions 
SELECT MIN(TripDate), MAX(TripDate) INTO mindate, maxdate FROM TripsInputInstants;
PERFORM create_partitions_by_date('Trips', mindate, maxdate);

INSERT INTO Trips(CarId, TripId, TripDate, Trip)
SELECT CarId, TripId, TripDate, tgeompointseq(array_agg(inst ORDER BY TStart))
FROM TripsInputInstants
GROUP BY CarId, TripId, TripDate;
UPDATE Trips
SET Traj = trajectory(Trip);

CREATE INDEX Trips_CarId_idx ON Trips USING btree(CarId);
CREATE UNIQUE INDEX Trips_pkey_idx ON Trips USING btree(CarId, TripId, TripDate);
CREATE INDEX Trips_gist_idx ON Trips USING gist(trip);
[...]				
			</programlisting>

			<para>With respect to the script given in the previous section, we need to add an additional column <varname>TripDate</varname> to the tables <varname>TripsInput</varname>, <varname>TripsInputInstants</varname> (not shown), and <varname>Trips</varname> that will be used for partitioning.
			</para>

		</sect1>

		<sect1>
			<title>BerlinMOD/R Queries</title>
			<para>The script for querying BerlinMOD data loaded in MobilityDB with the BerlinMOD/R queries is available <ulink url="https://docs.mobilitydb.com/data/berlinmod_queries.sql">here</ulink>.</para>
			<orderedlist>
				<listitem>
					<para>What are the models of the vehicles with licence plate numbers from <varname>Licences</varname>?</para>
					<programlisting>
SELECT DISTINCT L.Licence, C.Model AS Model
FROM Cars C, Licences L
WHERE C.Licence = L.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>How many vehicles exist that are passenger cars?</para>
					<programlisting>
SELECT COUNT (Licence)
FROM Cars C
WHERE Type = 'passenger';
					</programlisting>
				</listitem>
				
				<listitem>
					<para>Where have the vehicles with licences from <varname>Licences1</varname> been at each of the instants from <varname>Instants1</varname>?</para>
					<programlisting>
SELECT DISTINCT L.Licence, I.InstantId, I.Instant AS Instant,
	valueAtTimestamp(T.Trip, I.Instant) AS Pos
FROM Trips T, Licences1 L, Instants1 I
WHERE T.CarId = L.CarId AND valueAtTimestamp(T.Trip, I.Instant) IS NOT NULL
ORDER BY L.Licence, I.InstantId;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>Which vehicles have passed the points from <varname>Points</varname>?</para>
					<programlisting>
SELECT DISTINCT P.PointId, P.Geom, C.Licence
FROM Trips T, Cars C, Points P
WHERE T.CarId = C.CarId AND T.Trip &amp;&amp; P.Geom
AND ST_Intersects(trajectory(T.Trip), P.Geom) 
ORDER BY P.PointId, C.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>What is the minimum distance between places, where a vehicle with a licence from <varname>Licences1</varname> and a vehicle with a licence from <varname>Licences2</varname> have been?</para>
					<programlisting>
SELECT L1.Licence AS Licence1, L2.Licence AS Licence2,
	MIN(ST_Distance(trajectory(T1.Trip), trajectory(T2.Trip))) AS MinDist
FROM Trips T1, Licences1 L1, Trips T2, Licences2 L2
WHERE T1.CarId = L1.CarId AND T2.CarId = L2.CarId AND T1.CarId &lt; T2.CarId
GROUP BY L1.Licence, L2.Licence 
ORDER BY L1.Licence, L2.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>What are the pairs of trucks that have ever been as close as 10m or less to each other?</para>
					<programlisting>
SELECT DISTINCT C1.Licence AS Licence1, C2.Licence AS Licence2
FROM Trips T1, Cars C1, Trips T2, Cars C2
WHERE T1.CarId = C1.CarId AND T2.CarId = C2.CarId
AND T1.CarId &lt; T2.CarId AND C1.Type = 'truck' AND C2.Type = 'truck' 
AND T1.Trip &amp;&amp; expandSpatial(T2.Trip, 10) 
AND tdwithin(T1.Trip, T2.Trip, 10.0) ?= true
ORDER BY C1.Licence, C2.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>What are the licence plate numbers of the passenger cars that have reached the points from <varname>Points</varname> first of all passenger cars during the complete observation period?</para>
					<programlisting>
WITH Timestamps AS (
	SELECT DISTINCT C.Licence, P.PointId, P.Geom, 
		MIN(startTimestamp(atValue(T.Trip,P.Geom))) AS Instant
	FROM Trips T, Cars C, Points1 P
	WHERE T.CarId = C.CarId AND C.Type = 'passenger'
	AND T.Trip &amp;&amp; P.Geom AND ST_Intersects(trajectory(T.Trip), P.Geom)
	GROUP BY C.Licence, P.PointId, P.Geom
)
SELECT T1.Licence, T1.PointId, T1.Geom, T1.Instant
FROM Timestamps T1
WHERE T1.Instant &lt;= ALL (
	SELECT T2.Instant
	FROM Timestamps T2
	WHERE T1.PointId = T2.PointId )
ORDER BY T1.PointId, T1.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>What are the overall travelled distances of the vehicles with licence plate numbers from <varname>Licences1</varname> during the periods from <varname>Periods1</varname>?</para>
					<programlisting>
SELECT L.Licence, P.PeriodId, P.Period, SUM(length(atPeriod(T.Trip, P.Period))) AS Dist
FROM Trips T, Licences1 L, Periods1 P
WHERE T.CarId = L.CarId AND T.Trip &amp;&amp; P.Period
GROUP BY L.Licence, P.PeriodId, P.Period 
ORDER BY L.Licence, P.PeriodId;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>What is the longest distance that was travelled by a vehicle during each of the periods from <varname>Periods</varname>?</para>
					<programlisting>
WITH Distances AS (
	SELECT P.PeriodId, P.Period, T.CarId, SUM(length(atPeriod(T.Trip, P.Period))) AS Dist
	FROM Trips T, Periods P
	WHERE T.Trip &amp;&amp; P.Period
	GROUP BY P.PeriodId, P.Period, T.CarId
)
SELECT PeriodId, Period, MAX(Dist) AS MaxDist
FROM Distances
GROUP BY PeriodId, Period
ORDER BY PeriodId;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>When and where did the vehicles with licence plate numbers from <varname>Licences1</varname> meet other vehicles (distance &lt; 3m) and what are the latter licences?</para>
					<programlisting>
WITH Values AS (
	SELECT DISTINCT L1.Licence AS QueryLicence, C2.Licence AS OtherLicence,
	atPeriodSet(T1.Trip, getTime(atValue(tdwithin(T1.Trip, T2.Trip, 3.0), TRUE))) AS Pos
	FROM Trips T1, Licences1 L1, Trips T2, Licences2 C2 
	WHERE T1.CarId = L1.CarId AND T2.CarId = C2.CarId AND T1.CarId &lt; T2.CarId
	AND expandSpatial(T1.Trip, 3) &amp;&amp; expandSpatial(T2.Trip, 3) 
	AND dwithin(T1.Trip, T2.Trip, 3.0)
)
SELECT QueryLicence, OtherLicence, array_agg(Pos ORDER BY startTimestamp(Pos)) AS Pos
FROM Values 
GROUP BY QueryLicence, OtherLicence
ORDER BY QueryLicence, OtherLicence;

					</programlisting>
				</listitem>
				
				<listitem>
					<para>Which vehicles passed a point from <varname>Points1</varname> at one of the instants from <varname>Instants1</varname>?</para>
					<programlisting>
SELECT P.PointId, P.Geom, I.InstantId, I.Instant, C.Licence
FROM Trips T, Cars C, Points1 P, Instants1 I
WHERE T.CarId = C.CarId AND T.Trip @&gt; STBOX(P.Geom, I.Instant)
AND valueAtTimestamp(T.Trip, I.Instant) = P.Geom
ORDER BY P.PointId, I.InstantId, C.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>Which vehicles met at a point from <varname>Points1</varname> at an instant from <varname>Instants1</varname>?</para>
					<programlisting>
SELECT DISTINCT P.PointId, P.Geom, I.InstantId, I.Instant,
	C1.Licence AS Licence1, C2.Licence AS Licence2
FROM Trips T1, Cars C1, Trips T2, Cars C2, Points1 P, Instants1 I
WHERE T1.CarId = C1.CarId AND T2.CarId = C2.CarId AND T1.CarId &lt; T2.CarId 
AND T1.Trip @&gt; STBOX(P.Geom, I.Instant) AND T2.Trip @&gt; STBOX(P.Geom, I.Instant)
AND valueAtTimestamp(T1.Trip, I.Instant) = P.Geom
AND valueAtTimestamp(T2.Trip, I.Instant) = P.Geom
ORDER BY P.PointId, I.InstantId, C1.Licence, C2.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>Which vehicles travelled within one of the regions from <varname>Regions1</varname> during the periods from <varname>Periods1</varname>?</para>
					<programlisting>
SELECT DISTINCT R.RegionId, P.PeriodId, P.Period, C.Licence
FROM Trips T, Cars C, Regions1 R, Periods1 P
WHERE T.CarId = C.CarId AND T.trip &amp;&amp; STBOX(R.Geom, P.Period)
AND ST_Intersects(trajectory(atPeriod(T.Trip, P.Period)), R.Geom)
ORDER BY R.RegionId, P.PeriodId, C.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>Which vehicles travelled within one of the regions from <varname>Regions1</varname> at one of the instants from <varname>Instants1</varname>?</para>
					<programlisting>
SELECT DISTINCT R.RegionId, I.InstantId, I.Instant, C.Licence
FROM Trips T, Cars C, Regions1 R, Instants1 I
WHERE T.CarId = C.CarId AND T.Trip &amp;&amp; STBOX(R.Geom, I.Instant)
AND ST_Contains(R.Geom, valueAtTimestamp(T.Trip, I.Instant))
ORDER BY R.RegionId, I.InstantId, C.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>Which vehicles passed a point from <varname>Points1</varname> during a period from <varname>Periods1</varname>?</para>
					<programlisting>
SELECT DISTINCT PO.PointId, PO.Geom, PR.PeriodId, PR.Period, C.Licence
FROM Trips T, Cars C, Points1 PO, Periods1 PR
WHERE T.CarId = C.CarId AND T.Trip &amp;&amp; STBOX(PO.Geom, PR.Period)
AND ST_Intersects(trajectory(atPeriod(T.Trip, PR.Period)),PO.Geom)
ORDER BY PO.PointId, PR.PeriodId, C.Licence;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>List the pairs of licences for vehicles, the first from <varname>Licences1</varname>, the second from <varname>Licences2</varname>, where the corresponding vehicles are both present within a region from <varname>Regions1</varname> during a period from <varname>QueryPeriod1</varname>, but do not meet each other there and then.</para>
					<programlisting>
SELECT P.PeriodId, P.Period, R.RegionId, L1.Licence AS Licence1, L2.Licence AS Licence2
FROM Trips T1, Licences1 L1, Trips T2, Licences2 L2, Periods1 P, Regions1 R
WHERE T1.CarId = L1.CarId AND T2.CarId = L2.CarId AND L1.Licence &lt; L2.Licence
AND T1.Trip &amp;&amp; STBOX(R.Geom, P.Period) AND T2.Trip &amp;&amp; STBOX(R.Geom, P.Period)
AND ST_Intersects(trajectory(atPeriod(T1.Trip, P.Period)), R.Geom)
AND ST_Intersects(trajectory(atPeriod(T2.Trip, P.Period)), R.Geom)
AND tintersects(atPeriod(T1.Trip, P.Period), atPeriod(T2.Trip, P.Period)) %= FALSE
ORDER BY PeriodId, RegionId, Licence1, Licence2;
					</programlisting>
				</listitem>
				
				<listitem>
					<para>Which point(s) from <varname>Points</varname> have been visited by a maximum number of different vehicles?</para>
					<programlisting>
WITH PointCount AS (
	SELECT P.PointId, COUNT(DISTINCT T.CarId) AS Hits
	FROM Trips T, Points P
	WHERE ST_Intersects(trajectory(T.Trip), P.Geom)
	GROUP BY P.PointId 
)
SELECT PointId, Hits
FROM PointCount AS P
WHERE P.Hits = ( SELECT MAX(Hits) FROM PointCount );
					</programlisting>
				</listitem>
				
			</orderedlist>
		</sect1>
	</appendix>
</book>
